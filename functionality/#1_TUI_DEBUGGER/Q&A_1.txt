#Target workflows: 
 - Q: Besides mailbox producer/consumer and general HSX apps, are there other priority scenarios (e.g., long-running executive deployments, CI automation) that should shape the debugger’s feature set?
 - A: we should be able to connect to a process that is running, and "take control". it would be nice if we could get to the level that we can add live breakpoints, but that might be pushed further down the line.
   we did at some point discuss to add a BRK instruction, so we could manually code in breakpoints during compile time. what would be nice is to be able to control those breakpoints from the debugger interactively, to either skip them or break on them
#Session model: 
 - Q: Should one debugger instance be able to manage multiple PIDs concurrently, or is “one session per PID/MiniVM” sufficient?
 - A: in this case I think one debugger pr pid is the only suitable option. but it should be possible to connect multiple debug sessions to the exec so that we can handle debugging on other pids.  
    if it should be possible to connect several debuggers to the same pid, i don't know. maybe that is confusing, and we can have a lock on that. 
#Trace source & retention: 
 - Q: Do we stream the existing execd trace, or introspect live instruction fetches from the VM? How deep should the history be, and do we need persistence across sessions?
 - A: Good question. what do you think? if we rely on the execd, it means that we cannot trace if we run the VM only.  but maybe that is a usecase we don't need to support. but a part of me kind of would like us to support it.
    if the clear easiest way is to have an execd to connect to for debugging, maybe we set that as a requirement. no debugging on a VM directly, only through the execd. I think that's OK
#Disassembly linkage: 
 - Q: Do we rely on existing .mvasm/.hxo metadata, or should the debugger include its own disassembler for on-the-fly decoding?
 - A: This is also a good question. i think we should be able to call dissasemble on a hxe if we don't have any metadata. but it would also be nice to be able to load the output'ed json from the llc so we get all the details of every instruction and every symbol. 

#Clock control granularity: 
 - Q: Besides step/run/stop, do we need breakpoints, conditional stepping, or time-based throttling in this first iteration?
 - A: yes, all these things would be good to have. maybe we can order them in a must have to nice to have list, based on an investigation of how difficult it is to implement. i meantioned compiled-in BRK instructions earlier.
 

#TUI framework constraints: 
 - Q:Are pure-terminal libraries acceptable (e.g., textual, prompt_toolkit), or do we need to support environments without full ANSI support (like vanilla Windows cmd.exe)?
 - A: if we can run powershell on windows, it is accepted. 

#Auxiliary panel data sources: 
 - Q: For the lower-left widget (mbox/dmesg/stdio), do we envision a pluggable system so other telemetry (scheduler stats, custom logs) can be swapped in?
 - A: yes, i think so. if you mean that we create python modules for, really for each panel maybe, regardless.. then we can display the panels where we want in the TUI. the idea with the lower left panel was to have it be "tab" organized or something like that. and we can have a checkbox to turn the feature on or off, to save processing time
 
#Automation outputs: 
 - Q: When running in scripted mode, are JSON responses the preferred format, or do we need pluggable serializers?
 - A: JSON is probably fine. i think the connection to the execd in the python implementation should be over tcp/ip ports as the shell is today. but later on, when we get to the C implementation, the traffic must go over serial shell. but that is a discussion for later on
 

#Security / access control: 
 - Q: Any authentication or sandbox concerns when connecting to execd, especially if we expose richer debugger commands?
 - A: no, i don't see a reason for authentication or sandboxing at this point. 
 
#Packaging expectations:
 - Q: Should the debugger ship as part of the existing HSX tooling package, or as a standalone entry point/binary?
 - A: it should be part of the suite
 
 
 

