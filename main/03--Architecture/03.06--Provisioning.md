# Architecture View â€” Provisioning & Persistence

## Role & Responsibilities
- Distribute HSX app payloads to nodes (CAN broadcast, SD card, host preload).
- Manage lifecycle of tasks (load, restart, FRAM-backed persistence).
- Provide hooks for calibration data and firmware configuration.
- **Preprocess HXE metadata**: Parse and register values/commands/mailboxes from `.value`/`.cmd`/`.mailbox` sections (HXE v2) before VM execution.
- Strip metadata sections before loading to VM, or mark them for VM to ignore.
- Maintain a consistent deployment story across MCUs that cannot load code directly into RAM; the executive brokers `.hxe` images and applies runtime configuration on behalf of HSX tasks.

## Interfaces
- Provisioning flows: CAN GET/SET/LOAD frames, SD card manifest, host CLI commands load and restart.
- FRAM persistence via value subsystem (val.persist) and executive services.
- Bootloader/host coordination for node startup sequencing.
- Command surface extends the executive (e.g., `load`, `restart`, `val persist`, provisioning status commands) so shell/automation can control deployment.

## Relationships
- Executive orchestrates provisioning before handing control to MiniVM.
- Value subsystem stores persistent parameters; mailbox conveys status/progress.
- Toolchain produces HXE images and optional manifests consumed by provisioning.
- Provisioning relies on mailbox/value hooks for status and configuration updates during deployment.
- Persistence layout shared with value subsystem via [05--Implementation/shared/persistence_layout.md](../05--Implementation/shared/persistence_layout.md), enabling provisioning to restore calibrated values (FRAM/EEPROM) regardless of target MCU.

## Notes
- Supports single host firmware across nodes; only HSX apps vary.
- Designed for offline (SD) or online (CAN master) deployment strategies.
- AVR deployments load HSXEs from CAN/SD at boot instead of reserving flash for permanent copies; see [docs/resource_budgets.md](../../docs/resource_budgets.md) for staging buffer assumptions.
- Persistence ensures calibration survives power cycles without exposing hardware details to HSX apps.
- Current Python implementation supports host-side `load`/`restart`; MCU targets will implement CAN/SD ingest and FRAM writes using the same architectural hooks (context/persistence metadata).
- DO-4.b: Future option for FRAM-backed caches on constrained MCUs; keep persistence hooks abstract so AVR vs STM32 deployments can choose hardware (may be deferred).
