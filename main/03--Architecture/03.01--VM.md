# Architecture View — MiniVM

## Role & Responsibilities
- Execute HSX ISA instructions for a single task.
- Maintain architectural state via a register workspace pointer.
- Expose traps (SVC/BRK) and emit debug events consumed by the executive.

## High-Level Structure
```
                  Executive Control Plane
        +-----------------------------------------+
        | RPC / SVC coordination (attach, step)   |
        +------------------+----------------------+
                           |
                           v
                +-------------------------+
                |  MiniVM Core            |
                |  - HSX ISA decode/exec  |
                |  - SVC/BRK trap engine  |
                |  - Event emitter        |
                +-----------+-------------+
                            |
                            v
                +-------------------------+
                | Register Workspace RAM  |
                | 16×32-bit window at     |
                | reg_base (per task)     |
                +-------------------------+
                            |
                            v
                +-------------------------+
                | Application Image       |
                | (.hxe resident in VM    |
                | memory; FRAM/flash TBD) |
                +-------------------------+
```
The VM always runs under executive control in production. The executive drives execution via control-plane commands (load, step, clock) and handles all syscall traps. A standalone test mode exists for VM development but is not used in production deployments.

## Interfaces
- Controlled via executive commands such as load, attach, step, read_mem, write_mem.
- Context structure fields include pc, reg_base, stack_base, sp, psw.
- Event emission hooks (emit_event) notify breakpoints, sleep, mailbox wait/wake.

## Register Workspace & ISA
- HSX ISA defines 16 general-purpose 32-bit registers accessed via a workspace pointer (`reg_base`). Rotating `reg_base` points to a different 64-byte bank in VM RAM; this is how task context switches occur without copying registers.
- Each task owns a `TaskContext` structure (pc, sp, psw, reg_base, stack_base, stack_limit, etc.). The executive, when attached, swaps contexts by persisting the structure and calling into the VM to load a different context before issuing `step()` calls.
- The VM enforces the HSX calling convention (register-first with stack spill). Detailed ABI rules, stack layout, and compiler requirements are documented in the design spec ([04--Design/04.01--VM.md](../04--Design/04.01--VM.md)), but they underpin the architectural assumption that toolchain, VM, and executive share the same ABI contract.
- Instruction set focuses on integer/logic control flow, half-precision floating point, and SVC traps for services; future ISA extensions will be appended without breaking existing opcodes.

### Context & Workspace Management (today)
- When an HSX task is loaded, the VM reserves a register bank and stack slice via `_allocate_task_memory`, recording the `reg_base` and stack bounds in the task's state.
- The executive keeps snapshots of each task (`state["context"]` plus memory image). To switch PIDs, `_activate_task` calls `MiniVM.restore_state`, which reconstructs the `TaskContext` (including `reg_base`) and reloads registers from the task's register bank before stepping.
- This architecture means the workspace pointer never travels over IPC; it lives in shared VM memory and is selected by loading the appropriate context snapshot. A future C port can keep this structure while optimising memory layout/allocation.

## Relationships
- Managed by host executive (Python prototype today, C port later).
- Shares mailbox/FS/HAL services provided by the executive layer.
- Works with toolchain-produced HXE images.

## Memory & Code Loading
- `.hxe` binaries are the canonical application format. In the Python prototype the image resides fully in host RAM; in the MCU implementation we expect `.hxe` to be stored in FRAM/flash with an optional runtime cache in MCU RAM. The same architectural hooks (code base pointer, integrity checks) apply regardless of storage medium.
- **HXE Format v2 (0x0002):** Executive preprocesses metadata sections (`.value`, `.cmd`, `.mailbox`) from HXE header before loading to VM. These declarative sections define values, commands, and mailboxes that the executive registers with the app's PID. The VM receives only code/rodata/bss—metadata sections are stripped or ignored during load. This eliminates all registration overhead from VM execution, as the executive completes setup before the first VM instruction runs.
- Data sections and stack arenas occupy contiguous RAM slices per task. The executive manages allocation/reclamation of these slices and ensures the VM context references the correct register and stack bases.

## Execution Modes & Executive Interface
**Production mode (always with executive):**
The VM always runs under an executive that:
- Loads HXE code into the VM via the control-plane API
- Drives execution by calling `step()` or `clock(n)` to retire instructions
- Handles all SVC traps (mailboxes, values/commands, provisioning, I/O)
- Manages multi-task scheduling and context switching

**Development/test standalone mode:**
For VM testing only, MiniVM can run without an executive. In this mode it manages its own instruction loop until halted or until syscalls return `HSX_ERR_ENOSYS`. This mode cannot support HXE applications that require executive services.

**Control interface:**
- Control commands (`load`, `step`, `read_mem`, `write_mem`, etc.) map to VM façade operations that manipulate `TaskContext` data, including register workspace pointer swaps.
- SVC traps provide the execution-time interface into executive services. The VM captures argument registers (R0–R3) and forwards them to the executive without interpreting semantics.
- Event emission (`emit_event`) is the back-channel for breakpoints, sleep requests, mailbox wait/wake, and error conditions that the executive consumes.

**Modular executive:**
The executive consists of pluggable backends (filesystem sources, protocol handlers, HAL implementations) that are compiled/linked together. On desktop (Python), the executive is a separate process; on MCU, VM and executive are linked into one flash image.

## Notes
- Register workspace concept inspired by TMS9900.
- Single-task interpreter; multi-task scheduling resides entirely in the executive.
- Debug capabilities (breakpoints, run-to-PC) are provided by the executive.
- Python implementation is the reference prototype. As we move toward a C port, we plan an intermediate phase that keeps the VM in Python but mirrors C-style structure (explicit data structs, minimal dynamic features, deterministic control flow). This bridges the gap while retaining rapid iteration, and the long-term C implementation will follow the same architecture.
- On MCU targets, VM and executive are compiled and linked together into a single flash image with backend modules selected at compile time (filesystem source, protocol handler, HAL implementation).
- Current implementation status: the Python VM still performs full-state copies during context switches; issue [issues/#2_scheduler](../../issues/#2_scheduler/01--Issue.md) tracks the refactor to pure workspace-pointer swapping so behaviour matches this architecture. Performance analysis and potential future optimisations (e.g., hot-set mirrors) are captured in [support/hsx_vm_register_model_analysis.md](../support/hsx_vm_register_model_analysis.md).
- Resource planning for per-task stacks and register banks is summarised in `docs/resource_budgets.md`; the AVR128DA28 profile assumes ≈1.5 KiB stack + 64 B register window per task with room for mailbox/value metadata.
