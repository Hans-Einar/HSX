# Architecture View — MiniVM

## Role & Responsibilities
- Execute HSX ISA instructions for a single task.
- Maintain architectural state via a register workspace pointer.
- Expose traps (SVC/BRK) and emit debug events consumed by the executive.

## High-Level Structure
```
                  Executive Control Plane
        +-----------------------------------------+
        | RPC / SVC coordination (attach, step)   |
        +------------------+----------------------+
                           |
                           v
                +-------------------------+
                |  MiniVM Core            |
                |  - HSX ISA decode/exec  |
                |  - SVC/BRK trap engine  |
                |  - Event emitter        |
                +-----------+-------------+
                            |
                            v
                +-------------------------+
                | Register Workspace RAM  |
                | 16×32-bit window at     |
                | reg_base (per task)     |
                +-------------------------+
                            |
                            v
                +-------------------------+
                | Application Image       |
                | (.hxe resident in VM    |
                | memory; FRAM/flash TBD) |
                +-------------------------+
```
The executive can take control of the VM via control-plane commands, but the VM is also capable of running independently (single task) when no executive is attached. In both modes it executes instructions against the register workspace and application image, emitting events that the executive or standalone shims consume.

## Interfaces
- Controlled via executive commands such as load, attach, step, read_mem, write_mem.
- Context structure fields include pc, reg_base, stack_base, sp, psw.
- Event emission hooks (emit_event) notify breakpoints, sleep, mailbox wait/wake.

## Register Workspace & ISA
- HSX ISA defines 16 general-purpose 32-bit registers accessed via a workspace pointer (`reg_base`). Rotating `reg_base` points to a different 64-byte bank in VM RAM; this is how task context switches occur without copying registers.
- Each task owns a `TaskContext` structure (pc, sp, psw, reg_base, stack_base, stack_limit, etc.). The executive, when attached, swaps contexts by persisting the structure and calling into the VM to load a different context before issuing `step()` calls.
- The VM enforces the HSX calling convention (register-first with stack spill). Detailed ABI rules, stack layout, and compiler requirements are documented in the design spec ([04--Design/04.01--VM.md](../04--Design/04.01--VM.md)), but they underpin the architectural assumption that toolchain, VM, and executive share the same ABI contract.
- Instruction set focuses on integer/logic control flow, half-precision floating point, and SVC traps for services; future ISA extensions will be appended without breaking existing opcodes.

### Context & Workspace Management (today)
- When an HSX task is loaded, the VM reserves a register bank and stack slice via `_allocate_task_memory`, recording the `reg_base` and stack bounds in the task's state.
- The executive keeps snapshots of each task (`state["context"]` plus memory image). To switch PIDs, `_activate_task` calls `MiniVM.restore_state`, which reconstructs the `TaskContext` (including `reg_base`) and reloads registers from the task's register bank before stepping.
- In standalone mode the same mechanism is used internally: MiniVM saves/restores context when yielding to internal wait states (e.g., sleep, mailbox wait).
- This architecture means the workspace pointer never travels over IPC; it lives in shared VM memory and is selected by loading the appropriate context snapshot. A future C port can keep this structure while optimising memory layout/allocation.

## Relationships
- Managed by host executive (Python prototype today, C port later).
- Shares mailbox/FS/HAL services provided by the executive layer.
- Works with toolchain-produced HXE images.

## Memory & Code Loading
- `.hxe` binaries are the canonical application format. In the Python prototype the image resides fully in host RAM; in the MCU implementation we expect `.hxe` to be stored in FRAM/flash with an optional runtime cache in MCU RAM. The same architectural hooks (code base pointer, integrity checks) apply regardless of storage medium.
- **HXE Format v2 (0x0002):** Executive preprocesses metadata sections (`.value`, `.cmd`, `.mailbox`) from HXE header before loading to VM. These declarative sections define values, commands, and mailboxes that the executive registers with the app's PID. The VM receives only code/rodata/bss—metadata sections are stripped or ignored during load. This eliminates all registration overhead from VM execution, as the executive completes setup before the first VM instruction runs.
- Data sections and stack arenas occupy contiguous RAM slices per task. When the executive attaches, it manages allocation/reclamation of these slices and ensures the VM context references the correct register and stack bases. Standalone mode simply uses the initial allocation and runs until HAL events or SVC stubs require host intervention.

## Execution Modes & Executive Interface
- **Standalone mode:** MiniVM can operate without an attached executive (useful for single application scenarios or bring-up). In this mode it manages its own instruction loop until halted or until SVC stubs signal missing services.
- **Attached mode:** When an executive connects, MiniVM hands over clock control—its internal loop pauses and the executive drives execution via `step()`/`debug_step()` calls while persisting contexts. Detaching returns control to the internal clock.
- Control commands (`load`, `attach`, `step`, `read_mem`, `write_mem`, etc.) map to VM façade operations that manipulate `TaskContext` data, including register workspace pointer swaps.
- SVC traps provide the execution-time interface into executive services (mailboxes, values/commands, provisioning). The VM captures argument registers (R0–R3) and forwards them to the executive without interpreting semantics.
- Event emission (`emit_event`) is the back-channel for breakpoints, sleep requests, mailbox wait/wake, and error conditions; the executive or standalone shim consumes these events.

## Notes
- Register workspace concept inspired by TMS9900.
- Single-task interpreter; multi-task scheduling resides entirely in the executive when attached.
- Debug capabilities (breakpoints, run-to-PC) are enabled only when the executive attaches.
- Python implementation is the reference prototype. As we move toward a C port, we plan an intermediate phase that keeps the VM in Python but mirrors C-style structure (explicit data structs, minimal dynamic features, deterministic control flow). This bridges the gap while retaining rapid iteration, and the long-term C implementation will follow the same architecture.
- Current implementation status: the Python VM still performs full-state copies during context switches; issue [issues/#2_scheduler](../../issues/#2_scheduler/01--Issue.md) tracks the refactor to pure workspace-pointer swapping so behaviour matches this architecture. Performance analysis and potential future optimisations (e.g., hot-set mirrors) are captured in [support/hsx_vm_register_model_analysis.md](../support/hsx_vm_register_model_analysis.md).
- Resource planning for per-task stacks and register banks is summarised in `docs/resource_budgets.md`; the AVR128DA28 profile assumes ≈1.5 KiB stack + 64 B register window per task with room for mailbox/value metadata.
