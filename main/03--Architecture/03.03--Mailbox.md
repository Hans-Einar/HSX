# Architecture View — Mailbox Subsystem

## Role & Responsibilities
- Provide message queues/mailboxes for HSX tasks and services.
- Act as the executive's primary IPC mechanism (akin to OS message queues) while keeping the service layer fast and native.
- Support multiple namespaces (svc, app, shared) with configurable delivery modes.
- Deliver stdio bindings and telemetry fan-out.
- Serve as the transport for value/command subscriptions and async responses.
- **Declarative creation**: Process `.mailbox` metadata section from HXE format v2 during app load, pre-creating app mailboxes before VM execution.

## Interfaces
- **Declarative**: HXE metadata section (`.mailbox`) processed by executive to create mailboxes before VM execution.
- **Runtime**: Mailbox operations exposed through VM traps handled by the executive. The detailed ABI (module IDs, function selectors, status codes) is defined during the design phase (see [04--Design/04.03--Mailbox.md](../04--Design/04.03--Mailbox.md)).
- Descriptor pools and per-task handles live in MiniVM memory managed by the executive. Handle indirection keeps the VM ABI stable even if descriptor internals evolve.
- Event notifications (`mailbox_wait`, `mailbox_wake`, `mailbox_timeout`, `mailbox_error`) flow from the VM to the executive so the scheduler and tooling can react without polling.
- Namespaces (`svc:`, `pid:`, `app:`, `shared:`) provide isolation between standard services, task-private channels, and shared telemetry. The architecture mandates namespace support; specific prefixes and limits are captured in the design artifacts.

## Relationships
- Core IPC channel between HSX tasks and host/external services.
- Value/command subsystem can publish via mailbox taps.
- Shell/debugger listen to mailboxes for stdio and telemetry.
- Scheduler depends on mailbox wait/wake events to block and resume tasks without busy loops.

## Notes
- Inspired by VMS/RSX-11 mailboxes with fan-out/tap semantics.
- Supports blocking semantics so tasks sleep without busy loops.
- Embedded profiles can scale descriptor pool to device constraints.
- Current Python implementation still uses snapshot-based context switching; once [issues/#2_scheduler](../../issues/#2_scheduler/01--Issue.md) lands, mailbox waiters will rely exclusively on the register workspace model the architecture describes.
- Memory footprint guidance (descriptor pool, event buffers) is maintained alongside the broader resource plan in [docs/resource_budgets.md](../../docs/resource_budgets.md); AVR targets start with ~16 descriptors (≈1 KiB SRAM) and scale as budgets allow.
