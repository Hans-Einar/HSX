# Architecture View — Executive

## Role & Responsibilities
- Function as a lightweight operating system for HSX: coordinating tasks, providing services, and abstracting hardware while running in native host code for performance.
- Implemented on host-side to take advantage of native hardware speeds.
- Coordinate MiniVM tasks: scheduling, attach/detach, run control.
- Provide IPC services (mailboxes), stdio routing, and HAL bindings.
- Expose RPC interface to shell/debugger clients.
- Manage provisioning of HSX apps and FRAM persistence.
- Offer value/command access layer so tasks can be observed/controlled externally.

## High-Level Structure
```
        Shell / Debugger / Automation
              |  JSON RPC / CLI
              v
+-----------------------------------+
|          HSX Executive           |
|  - Session manager (attach/detach)
|  - Scheduler (round-robin, waits)
|  - IPC services (mailbox manager)
|  - Value/command registry         |
|  - Provisioning / persistence     |
+----------------+------------------+
                 |
                 | VM control (step, context swap)
                 v
         +---------------------+
         |      MiniVM         |
         +---------------------+
                 |
                 | HAL services
        +--------+--------+
        |  UART / CAN /   |
        |  FRAM / FS / IO |
        +-----------------+
```
- Executive sits between host tooling and MiniVM, orchestrating task scheduling, IPC, and lifecycle.
- HAL drivers provide hardware access; executive abstracts them for HSX tasks.

## Interfaces
- **Control plane:** JSON-over-TCP RPC protocol (`docs/executive_protocol.md`) exposing commands like `ping`, `info`, `load`, `attach`, `clock`, `step`, `ps`, `sched`, `trace`, `mailbox` ops, `val`/`cmd` access.
- **Event stream:** Long-lived subscription delivering step events, debug stops, mailbox activity, value changes; feeds shell/debugger.
  - Sessions may operate in **owner** mode (PID lock) or **observer** mode (no PID lock). Observers share the event bus and receive read-only telemetry; owners retain control priority and cannot be blocked by observers thanks to per-session cursors and eviction rules documented in `docs/executive_protocol.md`.
- **SVC bridge:** Handles SVC traps from MiniVM (mailboxes, values, provisioning, FS) and routes them to HAL or host services. Executive control traps (`yield`, `sleep_ms`) now live on module `0x06` with a temporary alias on `0x07` for legacy payloads.
- **Provisioning hooks:** Load `.hxe` images from host path, CAN, SD; manage FRAM-backed persistence.
- **HAL integration:** UART/CAN/FRAM/FS drivers (native C on MCU, shims in Python prototype) invoked by executive.
- **Debugger API:** `session.open`, `events.subscribe`, and related RPCs provide a structured event channel for the debugger. Events include monotonically increasing sequence numbers, timestamps, PID, type, and payload fields (`pc`, `opcode`, `mailbox`, etc.), matching the contract in `docs/executive_protocol.md` and the debugger playbook (`functionality/#1_TUI_DEBUGGER`).

## Relationships
- Owns MiniVM instance(s) and selects active task per time slice.
- Relies on toolchain outputs (.hxe) for task images.
- Serves shell, debugger, provisioning clients via network or local transport.
- Coordinates with value/command layer (`(3.4)val_cmd.md`) to expose telemetry/control endpoints.
- Works hand in hand with the scheduler issue remediation (`issues/#2_scheduler`) to enforce the single-instruction contract.

## Notes
- PID-scoped sessions ensure exclusive control per debugger.
- Event fan-out model underpins debugger and telemetry tooling.
- Designed for Python implementation first, with roadmap to native C port on embedded targets.
- Current Python implementation still uses snapshot-based context switches; architectural intent is to reuse register/stack arenas and swap contexts without copying (see `issues/#2_scheduler`).
- The architecture supports standalone operation (MiniVM without executive) but assumes the executive will take over when present, halting VM’s internal loop and driving execution via `step()`.

## Scheduling overview
- Cooperative round-robin scheduler that advances one MiniVM instruction per task turn, preserving deterministic PID interleaving.
- Task states include ready, running, waiting on mailbox, sleeping, paused, and terminal states; the design specification (`main/(4)design/(4.2)executive.md`) details exact transitions and wait/wake rules.
- Mailbox waits and sleep requests yield control back to the scheduler, while external events (timeouts, debugger commands) update task state without re-entering the VM unsafely.
```
READY ─► RUNNING ─► READY
                └─► WAIT_MBX ──(wake/timeout)──► READY
                └─► SLEEPING ──(deadline)──────► READY
                └─► PAUSED / RETURNED (terminal)
```
- Memory footprint targets for the executive (scheduler state, mailbox manager, buffers) are tracked in `docs/resource_budgets.md`; the AVR baseline allocates ≤5.5 KiB SRAM for the core runtime so that HSX tasks retain sufficient stack space.

## Event streaming & debugger integration
- The executive aggregates VM and scheduler events (instruction retire, breakpoint hits, mailbox activity, watchdog notifications) into a bounded queue. Subscribers attach via `events.subscribe`, optionally filtering by PID and event categories.
- Back-pressure is handled through acknowledgements (`events.ack`) and a drop-oldest policy once queues exceed configured depth. Each event carries `seq` (uint64), `ts` (float seconds or ISO8601 string), `pid`, `type`, and a `data` object whose schema is documented in `docs/executive_protocol.md`.
- Only one debugger may hold a PID lock at a time; additional subscribers may listen in passive mode (read-only) for telemetry panels.
- Event streaming extends the existing RPC transport and underpins the debugger/TUI feature set described in `functionality/#1_TUI_DEBUGGER/(4)design.md`.
