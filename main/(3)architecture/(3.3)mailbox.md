# Architecture View — Mailbox Subsystem

## Role & Responsibilities
- Provide message queues/mailboxes for HSX tasks and services.
- Act as the executive's primary IPC mechanism (akin to OS message queues) while keeping the service layer fast and native.
- Support multiple namespaces (svc, app, shared) with configurable delivery modes.
- Deliver stdio bindings and telemetry fan-out.
- Serve as the transport for value/command subscriptions and async responses.

## Interfaces
- **SVC module 0x05:** `MAILBOX_OPEN`, `BIND`, `SEND`, `RECV`, `PEEK`, `TAP` with per-task handles.
- **Descriptor pool:** preallocated descriptors stored in MiniVM memory, indexed by the executive; per-task handle tables map small integers → descriptor references.
- **Event notifications:** MiniVM emits `mailbox_wait`, `mailbox_wake`, `mailbox_timeout`, `mailbox_error` events so the executive can update scheduler state and tooling.
- **Namespace conventions:** `svc:` (per-task stdio/control channels), `app:` (shared application channels), `shared:` (fan-out/tap capable).

## Relationships
- Core IPC channel between HSX tasks and host/external services.
- Value/command subsystem can publish via mailbox taps.
- Shell/debugger listen to mailboxes for stdio and telemetry.
- Scheduler depends on mailbox wait/wake events to block and resume tasks without busy loops.

## Notes
- Inspired by VMS/RSX-11 mailboxes with fan-out/tap semantics.
- Supports blocking semantics so tasks sleep without busy loops.
- Embedded profiles can scale descriptor pool to device constraints.
- Current Python implementation still uses snapshot-based context switching; once `issues/#2_scheduler` lands, mailbox waiters will rely exclusively on the register workspace model the architecture describes.
