# Architecture View â€” Provisioning & Persistence

## Role & Responsibilities
- Distribute HSX app payloads to nodes (CAN broadcast, SD card, host preload).
- Manage lifecycle of tasks (load, restart, FRAM-backed persistence).
- Provide hooks for calibration data and firmware configuration.
- Maintain a consistent deployment story across MCUs that cannot load code directly into RAM; the executive brokers `.hxe` images and applies runtime configuration on behalf of HSX tasks.

## Interfaces
- Provisioning flows: CAN GET/SET/LOAD frames, SD card manifest, host CLI commands load and restart.
- FRAM persistence via value subsystem (val.persist) and executive services.
- Bootloader/host coordination for node startup sequencing.
- Command surface extends the executive (e.g., `load`, `restart`, `val persist`, provisioning status commands) so shell/automation can control deployment.

## Relationships
- Executive orchestrates provisioning before handing control to MiniVM.
- Value subsystem stores persistent parameters; mailbox conveys status/progress.
- Toolchain produces HXE images and optional manifests consumed by provisioning.
- Provisioning relies on mailbox/value hooks for status and configuration updates during deployment.

## Notes
- Supports single host firmware across nodes; only HSX apps vary.
- Designed for offline (SD) or online (CAN master) deployment strategies.
- Persistence ensures calibration survives power cycles without exposing hardware details to HSX apps.
- Current Python implementation supports host-side `load`/`restart`; MCU targets will implement CAN/SD ingest and FRAM writes using the same architectural hooks (context/persistence metadata).
