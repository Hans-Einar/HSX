# Design Spec - Debugger Protocol & CLI Debugger
# 04.09--Debugger Design (v3, repo style)
**Status:** DRAFT | **Date:** 2025-10-30 | **Owner:** HSX Core

> **Design stance:** The debugger is a user-facing interface to the HSX runtime. It performs no autonomous scheduling, embeds no VM logic, and coordinates all operations through the executive RPC protocol. All debugging and control actions are explicitly driven by user commands.

**Authoritative context (repo-local):**
- Architecture: [03.06--Toolkit](../03--Architecture/03.06--Toolkit.md), [03.00--Architecture](../03--Architecture/03.00--Architecture.md)
- Study & Requirements: [02--Study](../02--Study/02--Study.md), [02.01--Requirements](../02--Study/02.01--Requirements.md)
- Implementation-phase specs (normative inputs referenced by design):
  [docs/executive_protocol.md](../../docs/executive_protocol.md), [docs/abi_syscalls.md](../../docs/abi_syscalls.md)

**Traceability (fill from 02.01--Requirements):** Refs DR-8.1, DG-8.1, DG-8.2, DG-8.3.

## 1. Scope
- Debugger protocol for session management, event streaming, and runtime control between debugger clients and the HSX executive (DR-8.1, DG-8.2).
- CLI debugger providing command-line interface for debugging, inspection, and automation with JSON output support (DR-8.1, DG-8.1, DG-8.3).
- Session isolation with PID locking to prevent conflicting debugger operations (DR-8.1, DG-8.2).
- Event-driven architecture for real-time state updates without polling (DR-8.1, DG-8.2).
- Cross-platform support for Windows, macOS, and Linux environments (DG-8.3).

## 2. Preconditions
- Executive implements debugger session/event RPCs (`session.open`, `events.subscribe`, etc.) and enforces PID locks per [docs/executive_protocol.md](../../docs/executive_protocol.md) (DR-8.1, DG-8.2).
- MiniVM and executive emit structured events (`trace_step`, `debug_break`, `mailbox_*`, `scheduler`, `watch_update`, `stdout/stderr`) (DR-8.1, DG-5.2).
- Toolchain provides symbol metadata required for disassembly, stack reconstruction, and watch expressions (DR-3.1, DG-3.3, DG-3.5).
- Runtime environment has networking support for JSON-over-TCP communication (DR-8.1, DG-8.3).

## 3. Postconditions
- Debugger clients can attach to executive, control PID execution, and inspect runtime state without behavioral differences across platforms (DR-1.3, DG-1.4, DG-8.3).
- Session management enforces exclusive control per PID while allowing observer mode for read-only monitoring (DR-8.1, DG-8.2).
- Event streaming delivers real-time updates with back-pressure handling and reconnection support (DR-8.1, DG-8.2).
- CLI debugger provides both interactive REPL and scriptable JSON commands for automation/CI integration (DR-8.1, DG-8.3).

## 4. Architectural Overview

### 4.1 Design Principles
- **Executive-driven control:** All runtime manipulation flows through executive RPC; debugger maintains no local VM state beyond caches.
- **Event-driven updates:** State changes delivered via structured event stream; no polling loops required.
- **Session isolation:** PID locks prevent conflicting control; observer mode allows read-only monitoring.
- **Protocol versioning:** Capability negotiation enables graceful degradation with older executives.
- **Platform portability:** Unified codebase supports Windows, macOS, Linux via Python cross-platform libraries.

### 4.2 Component Architecture

#### 4.2.1 Debugger Core Package (`hsxdbg`)
Python module providing shared functionality for all debugger frontends:

- **Transport layer (`hsxdbg.transport`):** Wraps JSON-over-TCP RPC with connection management, request/response handling, and reconnection logic.
- **Session manager (`hsxdbg.session`):** Manages connection lifecycle, protocol negotiation, PID attachments, and session state.
- **Event bus (`hsxdbg.events`):** Async dispatcher multiplexing executive events to interested subscribers with bounded queues.
- **State cache (`hsxdbg.cache`):** Mirrors registers, memory ranges, call stacks, watch variables, and mailbox descriptors to minimize RPC round-trips.
- **Command layer (`hsxdbg.commands`):** Typed command helpers (`step`, `resume`, `set_breakpoint`, `read_memory`) shielding clients from raw JSON.

#### 4.2.2 CLI Frontend (`hsx dbg`)
Command-line interface built on debugger core:

- **Command parser:** Handles interactive REPL (via `prompt_toolkit`) and single-command invocations.
- **JSON output mode:** Machine-readable output for scripting and CI/CD integration.
- **Tab completion:** Context-aware completion for commands, symbols, and addresses.
- **History management:** Persistent command history across sessions.

## 5. Debugger Protocol Specification

### 5.1 Session Management

#### 5.1.1 Session Lifecycle
```json
// Open session
Request: {
  "version": 1,
  "cmd": "session.open",
  "client": "hsx-dbg-cli",
  "capabilities": {
    "features": ["events", "stack", "watch", "breakpoints"],
    "max_events": 256
  },
  "pid_lock": 2  // or null for no lock
}

Response: {
  "status": "ok",
  "session_id": "<uuid>",
  "capabilities": {
    "features": ["events", "stack", "watch", "breakpoints"],
    "max_events": 256
  },
  "heartbeat_interval": 30,
  "protocol_version": 1
}

// Close session
Request: {
  "version": 1,
  "cmd": "session.close",
  "session": "<uuid>"
}

Response: {
  "status": "ok"
}
```

#### 5.1.2 Session Locks
- **Exclusive mode (`pid_lock` specified):** Session acquires exclusive control of PID; other exclusive sessions blocked.
- **Observer mode (`pid_lock: null`):** Read-only access; cannot modify execution state.
- **Lock conflict:** Attempting to acquire locked PID returns `{"status": "error", "error": "pid_locked"}`.

#### 5.1.3 Keepalive
```json
Request: {
  "version": 1,
  "cmd": "session.keepalive",
  "session": "<uuid>"
}

Response: {
  "status": "ok",
  "ts": 1730319687.512
}
```

### 5.2 Event Streaming

#### 5.2.1 Subscribe to Events
```json
Request: {
  "version": 1,
  "cmd": "events.subscribe",
  "session": "<uuid>",
  "filters": {
    "pid": [2],  // null for all PIDs
    "categories": ["debug_break", "trace_step", "scheduler", "mailbox", "watch", "stdout", "stderr"],
    "since_seq": null  // or last processed sequence for reconnect
  }
}

Response: {
  "status": "ok",
  "subscription_id": "<uuid>"
}

// Executive streams newline-delimited JSON events:
{"seq": 1024, "ts": 1730319687.512, "type": "debug_break", "pid": 2, "data": {"pc": 4096, "symbol": "main.loop", "reason": "BRK"}}
{"seq": 1025, "ts": 1730319687.515, "type": "trace_step", "pid": 2, "data": {"pc": 4100, "opcode": 0x0201, "flags": "Z"}}
```

#### 5.2.2 Event Schema
Common fields for all events:
- `seq` (uint64): Monotonic sequence number for ordering and gap detection.
- `ts` (float): Timestamp in seconds since epoch.
- `type` (string): Event category.
- `pid` (int or null): Associated process ID.
- `data` (object): Type-specific payload.

Event types:
- **`trace_step`:** Single instruction execution. Data: `{pc, opcode, flags}`.
- **`debug_break`:** Breakpoint hit or BRK instruction. Data: `{pc, reason, breakpoint_id?, symbol?}`.
- **`scheduler`:** Task state transition. Data: `{state, prev_pid?, next_pid?}`.
- **`mailbox_send` / `mailbox_recv`:** Mailbox operations. Data: `{descriptor, length, flags}`.
- **`watch_update`:** Watched variable changed. Data: `{watch_id, value, formatted}`.
- **`stdout` / `stderr`:** Stdio output. Data: `{text}`.
- **`warning`:** System warning. Data: `{message, category}`.

#### 5.2.3 Back-pressure and ACKs
```json
// Client acknowledges processed events
Request: {
  "version": 1,
  "cmd": "events.ack",
  "session": "<uuid>",
  "subscription_id": "<uuid>",
  "last_seq": 1025
}

Response: {
  "status": "ok"
}
```

- Each session owns bounded ring buffer (`max_events` negotiated during `session.open`).
- Overflow drops oldest entries and emits `warning` event with `reason: "backpressure"`.
- Clients send `events.ack` to free space eagerly; events expire after timeout (default 5s).

#### 5.2.4 Unsubscribe
```json
Request: {
  "version": 1,
  "cmd": "events.unsubscribe",
  "session": "<uuid>",
  "subscription_id": "<uuid>"
}

Response: {
  "status": "ok"
}
```

### 5.3 Execution Control

#### 5.3.1 Attach to PID
```json
Request: {
  "version": 1,
  "cmd": "attach",
  "session": "<uuid>",
  "pid": 2
}

Response: {
  "status": "ok",
  "pid": 2,
  "state": "paused",
  "pc": 4096,
  "app_name": "producer",
  "filepath": "examples/demos/build/mailbox/producer.hxe"
}
```

#### 5.3.2 Detach from PID
```json
Request: {
  "version": 1,
  "cmd": "detach",
  "session": "<uuid>",
  "pid": 2
}

Response: {
  "status": "ok"
}
```

#### 5.3.3 Step Execution
```json
Request: {
  "version": 1,
  "cmd": "step",
  "session": "<uuid>",
  "pid": 2,
  "count": 1  // default 1
}

Response: {
  "status": "ok",
  "pc": 4100,
  "reason": "ok"  // or "break", "svc", "fault"
}
```

#### 5.3.4 Continue Execution
```json
Request: {
  "version": 1,
  "cmd": "continue",
  "session": "<uuid>",
  "pid": 2
}

Response: {
  "status": "ok"
}
```

#### 5.3.5 Pause Execution
```json
Request: {
  "version": 1,
  "cmd": "pause",
  "session": "<uuid>",
  "pid": 2
}

Response: {
  "status": "ok",
  "pc": 4150
}
```

### 5.4 Breakpoint Management

#### 5.4.1 Set Breakpoint
```json
Request: {
  "version": 1,
  "cmd": "bp.set",
  "session": "<uuid>",
  "pid": 2,
  "addr": 4096  // or "symbol": "main.loop"
}

Response: {
  "status": "ok",
  "breakpoint_id": 1,
  "addr": 4096,
  "symbol": "main.loop"
}
```

#### 5.4.2 Clear Breakpoint
```json
Request: {
  "version": 1,
  "cmd": "bp.clear",
  "session": "<uuid>",
  "pid": 2,
  "addr": 4096  // or "breakpoint_id": 1
}

Response: {
  "status": "ok"
}
```

#### 5.4.3 List Breakpoints
```json
Request: {
  "version": 1,
  "cmd": "bp.list",
  "session": "<uuid>",
  "pid": 2
}

Response: {
  "status": "ok",
  "breakpoints": [
    {"breakpoint_id": 1, "addr": 4096, "enabled": true, "symbol": "main.loop"},
    {"breakpoint_id": 2, "addr": 4200, "enabled": true, "symbol": "process_message"}
  ]
}
```

### 5.5 State Inspection

#### 5.5.1 Process List
```json
Request: {
  "version": 1,
  "cmd": "ps",
  "session": "<uuid>",
  "pid": null  // or specific PID
}

Response: {
  "status": "ok",
  "processes": [
    {
      "pid": 2,
      "app_name": "producer",
      "state": "paused",
      "filepath": "examples/demos/build/mailbox/producer.hxe",
      "pc": 4096,
      "sp": 0x7FF0
    }
  ]
}
```

#### 5.5.2 Read Registers
```json
Request: {
  "version": 1,
  "cmd": "reg.get",
  "session": "<uuid>",
  "pid": 2,
  "reg": "R0"  // or null for all
}

Response: {
  "status": "ok",
  "registers": {
    "PC": 4096,
    "SP": 0x7FF0,
    "R0": 0,
    "R1": 0x40EF,
    "R2": 5,
    // ... R3-R15
  }
}
```

#### 5.5.3 Write Register
```json
Request: {
  "version": 1,
  "cmd": "reg.set",
  "session": "<uuid>",
  "pid": 2,
  "reg": "R0",
  "value": 42
}

Response: {
  "status": "ok"
}
```

#### 5.5.4 Read Memory
```json
Request: {
  "version": 1,
  "cmd": "mem.read",
  "session": "<uuid>",
  "pid": 2,
  "addr": 0x7FF0,
  "length": 16
}

Response: {
  "status": "ok",
  "addr": 0x7FF0,
  "data": "007F0000040000001 00A00001C0A0000",
  "ascii": "..............."
}
```

#### 5.5.5 Write Memory (Optional)
```json
Request: {
  "version": 1,
  "cmd": "mem.write",
  "session": "<uuid>",
  "pid": 2,
  "addr": 0x7FF0,
  "data": "00000000"
}

Response: {
  "status": "ok"
}
```

#### 5.5.6 Stack Trace
```json
Request: {
  "version": 1,
  "cmd": "stack.info",
  "session": "<uuid>",
  "pid": 2,
  "max_frames": 32
}

Response: {
  "status": "ok",
  "frames": [
    {"depth": 0, "pc": 4096, "sp": 0x7FF0, "fp": 0x7FFC, "symbol": "mailbox_send", "file": "mailbox.c", "line": 42},
    {"depth": 1, "pc": 3584, "sp": 0x8000, "fp": 0x800C, "symbol": "main", "file": "main.c", "line": 15},
    {"depth": 2, "pc": 2048, "sp": 0x8020, "fp": 0x802C, "symbol": "_start"}
  ]
}
```

**Implementation:** Executive walks stack using frame pointers and return addresses, looking up symbols from loaded .sym file (see 04.02--Executive.md Section 5.3).

#### 5.5.7 Disassembly
```json
Request: {
  "version": 1,
  "cmd": "disasm.read",
  "session": "<uuid>",
  "pid": 2,
  "addr": 0x1000,
  "count": 20,
  "mode": "around_pc"  // or "from_addr"
}

Response: {
  "status": "ok",
  "instructions": [
    {
      "pc": 0x0FF8,
      "word": 0x01020304,
      "mnemonic": "LDI",
      "operands": "R1, 0x5",
      "symbol": "main",
      "file": "main.c",
      "line": 12
    },
    {
      "pc": 0x0FFC,
      "word": 0x10120000,
      "mnemonic": "ADD",
      "operands": "R1, R2, R0",
      "file": "main.c",
      "line": 13
    }
  ],
  "has_symbols": true
}
```

**Modes:**
- `from_addr`: Returns `count` instructions starting at `addr`
- `around_pc`: Returns `count/2` instructions before and after current PC

**Implementation:** Executive loads .sym file on task load, caches disassembly. Falls back to on-the-fly disassembly without symbols if .sym unavailable (see 04.02--Executive.md Section 5.4).

#### 5.5.8 Symbol Enumeration
```json
Request: {
  "version": 1,
  "cmd": "symbols.list",
  "session": "<uuid>",
  "pid": 2,
  "type": "function"  // or "variable", "all"
}

Response: {
  "status": "ok",
  "symbols": [
    {
      "name": "main",
      "address": 0x0100,
      "size": 64,
      "type": "function",
      "file": "main.c",
      "line": 10
    },
    {
      "name": "init_system",
      "address": 0x0204,
      "size": 32,
      "type": "function",
      "file": "init.c",
      "line": 5
    }
  ]
}
```

**Implementation:** Executive exposes symbols from loaded .sym file (see 04.02--Executive.md Section 5.5).

#### 5.5.9 Memory Regions
```json
Request: {
  "version": 1,
  "cmd": "memory.regions",
  "session": "<uuid>",
  "pid": 2
}

Response: {
  "status": "ok",
  "regions": [
    {
      "name": "code",
      "start": 0x0000,
      "end": 0x1FFF,
      "type": "text",
      "permissions": "r-x"
    },
    {
      "name": "data",
      "start": 0x2000,
      "end": 0x2FFF,
      "type": "data",
      "permissions": "rw-"
    },
    {
      "name": "stack",
      "start": 0x7000,
      "end": 0x7FFF,
      "type": "stack",
      "permissions": "rw-"
    }
  ]
}
```

**Implementation:** Executive reports memory layout from .sym file or HXE header (see 04.02--Executive.md Section 5.6).

### 5.6 Watch Management

#### 5.6.1 Add Watch
```json
Request: {
  "version": 1,
  "cmd": "watch.add",
  "session": "<uuid>",
  "pid": 2,
  "expr": "counter"  // symbol name or address expression
}

Response: {
  "status": "ok",
  "watch_id": 1,
  "expr": "counter",
  "value": 5,
  "addr": 0x2000
}
```

#### 5.6.2 Remove Watch
```json
Request: {
  "version": 1,
  "cmd": "watch.remove",
  "session": "<uuid>",
  "watch_id": 1
}

Response: {
  "status": "ok"
}
```

#### 5.6.3 List Watches
```json
Request: {
  "version": 1,
  "cmd": "watch.list",
  "session": "<uuid>",
  "pid": 2
}

Response: {
  "status": "ok",
  "watches": [
    {"watch_id": 1, "expr": "counter", "value": 5, "addr": 0x2000},
    {"watch_id": 2, "expr": "queue.depth", "value": 3, "addr": 0x2010}
  ]
}
```

## 6. CLI Debugger Design

### 6.1 Command Structure
The CLI debugger (`hsx dbg`) provides both interactive REPL and single-command modes:

```bash
# Interactive mode
$ hsx dbg --host localhost --port 5000
hsxdbg> attach 2
Attached to PID 2: producer
hsxdbg> break main.loop
Breakpoint 1 set at 0x1000 (main.loop)
hsxdbg> continue
Running... (Ctrl+C to pause)
Breakpoint 1 hit at 0x1000 (main.loop)
hsxdbg> regs
PC:   0x1000
SP:   0x7FF0
R0:   0x00000000
...

# Single-command mode
$ hsx dbg --host localhost --port 5000 --cmd "attach 2" --cmd "regs" --json
{"status": "ok", "registers": {"PC": 4096, "SP": 32752, ...}}

# Script file mode
$ hsx dbg --host localhost --port 5000 --script test.dbg
```

### 6.2 Command Reference

| Command | Arguments | Description |
|---------|-----------|-------------|
| `attach` | `<pid>` | Attach debugger session to PID |
| `detach` | - | Release session and PID lock |
| `step` | `[n]` | Single-step n instructions (default 1) |
| `continue` | - | Resume execution until breakpoint or completion |
| `pause` | - | Pause execution at current PC |
| `break` / `bp` | `<addr\|symbol>` | Set breakpoint at address or symbol |
| `clear` | `<addr\|symbol\|id>` | Remove breakpoint |
| `breaks` | - | List all breakpoints |
| `watch` | `<expr>` | Add watch expression |
| `unwatch` | `<id>` | Remove watch |
| `watches` | - | List all watches |
| `ps` | `[pid]` | List tasks or show details for PID |
| `regs` | `[name] [value]` | Read or write register |
| `mem` | `<addr> <len>` | Dump memory region |
| `stack` | - | Show call stack |
| `disasm` | `[addr] [len]` | Disassemble instructions |
| `info` | - | Show session and PID info |
| `help` | `[command]` | Show help for command |
| `quit` / `exit` | - | Close session and exit |

### 6.3 Output Modes

#### 6.3.1 Human-Readable Output (Default)
```
hsxdbg> regs
PC:   0x1000  (main.loop)
SP:   0x7FF0
R0:   0x00000000
R1:   0x000040EF
R2:   0x00000005
...
```

#### 6.3.2 JSON Output (--json flag)
```json
{
  "status": "ok",
  "registers": {
    "PC": 4096,
    "SP": 32752,
    "R0": 0,
    "R1": 16623,
    "R2": 5
  }
}
```

### 6.4 Interactive Features

#### 6.4.1 Tab Completion
- Command names
- Symbol names (from loaded metadata)
- Register names
- File paths

#### 6.4.2 Command History
- Persistent history across sessions (`~/.hsxdbg_history`)
- History search (Ctrl+R)
- Up/Down arrow navigation

#### 6.4.3 Aliases
```
hsxdbg> alias b break
hsxdbg> alias c continue
hsxdbg> alias s step
```

## 7. Error Handling

### 7.1 Protocol Errors
- **Version mismatch:** Warn user and attempt graceful degradation.
- **Unsupported command:** Return `{"status": "error", "error": "unsupported_cmd:<name>"}`.
- **Session required:** Return `{"status": "error", "error": "session_required"}`.
- **PID locked:** Return `{"status": "error", "error": "pid_locked"}`.

### 7.2 Connection Errors
- **Connection loss:** Auto-retry with exponential backoff; preserve session state for reconnection.
- **Timeout:** Configurable timeout for RPC requests (default 30s).
- **Event back-pressure:** Detect queue overflow, request slow-down, resynchronize with `since_seq`.

### 7.3 CLI Errors
- Invalid command: Show error message and suggest similar commands.
- Missing arguments: Show command usage.
- Invalid address/symbol: Show error and list available symbols.

## 8. Testing Strategy

### 8.1 Unit Tests
- Session lifecycle (open, close, keepalive, timeout)
- Event bus routing and filtering
- Command parsing and JSON serialization
- Breakpoint/watch management

### 8.2 Integration Tests
- Attach to simulated executive
- Breakpoint hit workflow
- Event streaming under load
- Reconnection after disconnect
- CLI command execution

### 8.3 Cross-Platform Validation
- Windows PowerShell
- macOS Terminal
- Linux terminals (GNOME Terminal, tmux)

### 8.4 Performance Benchmarks
- Event throughput (target: 500+ events/sec without backpressure)
- Command latency (target: <100ms round-trip)
- Memory usage (target: <50MB for typical session)

## 9. Documentation Requirements

### 9.1 Protocol Documentation
- Update [docs/executive_protocol.md](../../docs/executive_protocol.md) with session/event endpoints
- Document event schema and back-pressure protocol
- Provide protocol version compatibility matrix

### 9.2 CLI Documentation
- User guide with examples and common workflows
- Command reference with detailed descriptions
- Troubleshooting guide for common issues

### 9.3 Developer Documentation
- API reference for `hsxdbg` package
- Extension guide for custom frontends
- Event handler implementation guide

## 10. Traceability
- **Design Requirements:** DR-1.3, DR-3.1, DR-8.1.
- **Design Goals:** DG-1.4, DG-8.1, DG-8.2, DG-8.3.
- **Design Options:** DO-relay (future remote debugging), DO-8.a (advanced features).
