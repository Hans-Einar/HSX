# Design Spec — Executive

## Preconditions
- MiniVM emits structured events (debug_stop, mailbox, trace) and honours SVC/BRK semantics described in DG-5/6 (DR-8.1, DG-4.2, DG-5.2).
- Mailbox, value/command, and provisioning services are present (per (3.3)/(3.4) architecture) so executive callbacks can delegate work (DR-6.1, DR-7.1, DR-5.3).
- Toolchain provides .hxe images and (when available) symbol metadata enabling stack reconstruction and disassembly annotations (DR-3.1, DG-3.3, DR-2.5).
- Host environment exposes networking/transport required for the debugger CLI/TUI (TCP loopback on desktop, UART relay on embedded targets) (DR-8.1, DG-8.3).

## Postconditions
- Executive scheduler enforces single-instruction quanta with PID locking and exported state for debugger tooling (DR-5.1, DG-5.4, DG-5.3).
- Session/event RPCs (session.open, events.subscribe, etc.) stream structured events with back-pressure controls documented in docs/executive_protocol.md (DR-8.1, DG-5.2, DG-8.2).
- PID-level services (ps/info, stack, memory, watch) provide the data expected by the HSX debugger/TUI as outlined in unctionality/#1_TUI_DEBUGGER (DR-8.1, DG-8.1).
- Provisioning, stdio, mailbox, and persistence hooks remain backwards compatible while exposing the new debugger instrumentation (DR-1.1, DR-5.3, DR-6.1, DR-7.1).

## Scope
- Host controller managing MiniVM lifecycle, scheduling, and IPC services (DR-5.1, DR-5.3, DG-5.1).
- JSON-over-TCP RPC server consumed by shell/debugger/tooling (DR-8.1, DG-5.2, DG-8.1).
- Event capture and fan-out (trace, breakpoints, mailbox transitions) (DR-8.1, DG-5.2).
- Provisioning workflows (load/reload tasks, FRAM persistence) for CAN/SD/host sources (DR-1.1, DR-5.3, DG-1.2).
- Debug traps (`BRK`, single-step), SVC invocations, and error events emit structured payloads compatible with the executive event protocol (DR-8.1, DG-5.2).

- Drive VM via **attached** stepping (`vm_set_context`, `vm_step/clock`), **no automatic VM scheduling**.  
- Implement **SVC bridge**: dispatch SVCs to module handlers (mailbox/val/cmd/provisioning/HAL).  
- Manage **sessions** (exclusive debugger), **breakpoints**, **event stream** (ACK/rate‑limit).  
- Provide **host control‑plane** for tooling (attach, step/clock, bp.set/clear, reg.get/set, ps).


## Data Structures
- **ExecutiveState:**
  - `tasks: Dict[int, TaskRecord]` (PID → metadata).
  - `task_states: Dict[int, Dict[str, Any]]` (MiniVM snapshots).
  - `current_pid`, `waiting_tasks`, `auto_thread`, `auto_event`, `clock_mode`.
  - Logging/accounting: `_next_log_seq`, `log_buffer`, `scheduler_trace`, `scheduler_counters`.
  - Session registry: `self.sessions[session_id] = Session`.
- **TaskRecord:**
  ```python
  {
      "pid": int,
      "state": str,      # running, ready, waiting_mbx, paused, returned, terminated
      "pc": int,
      "priority": int,
      "quantum": int,
      "program": str,
      "vm_state": Dict[str, Any],
      "stdout": str,
      "sleep_pending": bool,
      "reg_base": int,
      "stack_base": int,
      "stack_limit": int,
      "stack_size": int,
      "trace": bool,
      "exit_status": Optional[int],
  }
  ```
- **Session record:** `Session(id, client_info, lock_pid, capabilities, keepalive_ts, event_cursor, filters)`; ensures one debugger per PID.
- **Event bus:** bounded ring buffer storing `Event{seq, ts, type, pid, payload}` items plus per-session cursors. Owner and observer sessions share the same queue, but observers never block owners because their cursors are evicted first when retention limits trigger.
- **Provisioning state:** `self.provisioning = {"active_images": {...}, "fram_keys": {...}, "pending": []}`; storing `.hxe` metadata, FRAM key mapping, CAN/SD transfer progress.
- **Resource budgets (per target, TBD):** max PID count, register bank arena, stack pool size, mailbox descriptors, FRAM capacity; to be captured in `docs/resource_budgets.md` per P0 task.




//new_start

## 2. Public Interfaces
### 2.1 SVC/ABI (module 0x06 EXEC) — summarized
> The authoritative table lives in **[abi_syscalls.md](../../docs/abi_syscalls.md)**. Executive implements these:
| Func | R0 | R1 | R2 | R3 | Ret | Errors | Time base |
|---|---|---|---|---|---|---|---|
| `GET_VERSION` | buf | len | – | – | n | – | µs/ticks |
| `STEP` | – | – | – | – | rc | – | µs/ticks |
| `CLOCK` | n | – | – | – | rc | – | µs/ticks |
| `ATTACH`/`DETACH` | pid | – | – | – | rc | EPERM | – |
| `PS` | buf | len | flags | – | n | – | – |
| `SCHED` | op | arg | – | – | rc | EINVAL | – |

*(Exact set per abi_syscalls; table here is a design anchor.)*

### 2.2 Host Control‑Plane (non‑SVC, for tooling)
| API | Args | Returns | Notes |
|---|---|---|---|
| `session.open(pid?)` | pid or null | rc | Claims exclusive debug session (locks). |
| `session.close()` | – | rc | Releases lock. |
| `ps()` | – | list[pid, state, pc] | Snapshot of tasks. |
| `vm.set_context(pid)` | pid | rc | Select active PID (passes through to VM). |
| `vm.step()` / `vm.clock(n)` | – / n | StepResult | Drives VM under scheduler rules. |
| `reg.get(pid, reg_id)` | pid, const | u32 | Reads register via VM (may use `vm_set_context` + `vm_reg_get`). |
| `reg.set(pid, reg_id, value)` | pid, const, u32 | rc | Writes register (policy‑gated). |
| `bp.set(pid, addr)` | pid, code addr | rc | Adds to **per‑PID** breakpoint set. |
| `bp.clear(pid, addr)` | pid, code addr | rc | Removes breakpoint. |
| `bp.list(pid)` | pid | list[addr] | Lists breakpoints. |

> Tool breakpoints are **pure Executive logic** (no code patching required); they work by **pre‑step PC compare**.
//new_stop


## Algorithms / Behaviour
- **RPC handling:**
  1. Parse JSON payload, validate `version` (currently 1).
  2. Retrieve/verify session; enforce lock semantics (only one debugger per PID).
  3. Dispatch to handler (load, attach, clock, sched, mailbox, val, cmd, provisioning).
  4. Convert exceptions to `{status: "error", error: ...}`; log in `log_buffer`.
- **Attach/detach:**
  - `attach(pid)` stops auto clock, calls `_activate_task`, marks session lock.
  - `detach()` clears lock, resumes internal clock if previously running; ensures `MiniVM.attached` flag false.
  - PID-specific attach allowed; global attach (pid=None) if only one task.
- **Scheduler state machine:** detailed states, transitions, and invariants are captured in the dedicated section below.
- **Clock modes:**
  - `manual`: only `step` RPC drives progress.
  - `auto`: background thread calling `step(batch)` at configured rate.
  - `detached`: MiniVM internal loop (standalone mode) when no executive.
- **Event streaming:**
  - Collect events from `MiniVM.consume_events()` (debug_stop, svc, mailbox events) + executive instrumentation (scheduler trace, provisioning logs) and append them to the shared ring (`max_events = 512`, retention ≈5 s).
  - Subscribers hold per-session cursors and filter sets. Owners receive delivery priority; observer sessions (no PID lock) are unsubscribed first if they fail to ACK.
  - ACK protocol: clients send `events.ack` with the highest processed sequence. The executive reclaims entries once every subscriber has advanced or the retention timer evicts them. Drops emit `warning` events with `reason:"event_dropped"` and the missing `seq` so clients can resynchronise via `since_seq`.
- **Provisioning flow:**
  1. Host CLI sends `load path` or CAN/SD transfer triggers.
  2. Executive verifies `.hxe` header, allocates PID, sets up register/stack arenas.
  3. If FRAM keys exist, load persisted values before resuming task.
  4. For CAN/SD, use mailbox or val layer to report progress/errors to host.
- **Persistence:** `val.persist` binds value to FRAM key; executive loads on task start and writes on `val.set` (with debounce) or shutdown. FRAM layout TBD in `docs/resource_budgets.md` (P0).
- **StdIO routing:** On task load, executive binds `svc:stdio.*` mailboxes; shell `listen` attaches to these handles.
- **Resource envelopes:** Follow `docs/resource_budgets.md` for flash/SRAM targets (<=28 KiB text, <=5.5 KiB SRAM for runtime) and per-task stack/register allocations when mapping C structures and linker scripts.
- **Debugger session handshake:** `session.open` negotiates protocol version/capabilities, acquires optional PID locks, and returns heartbeat interval plus maximum event buffer size. `session.keepalive` refreshes idle timers; `session.close` releases locks and unsubscribes from events.

## Event streaming contract
> Keep `docs/executive_protocol.md` in sync with this section during implementation (new event types, fields, and RPCs must be documented).
- **Subscribe flow**
  1. Client issues `session.open` with fields such as `client` (string identifier), `version` (protocol integer), `capabilities` (`{"features":["events","stack","watch"],"max_events":256}`), and optional `pid_lock` (int or `null` for passive mode).
  2. Executive responds with `session_id`, negotiated feature list, heartbeat interval, and capability warnings (e.g., `unsupported_feature`).
  3. Client sends `events.subscribe`:
     ```json
     {
       "version": 1,
       "cmd": "events.subscribe",
       "session": "<id>",
       "filters": {
         "pid": [1, 3],
         "categories": ["debug_break", "trace_step", "scheduler", "mailbox", "watch"],
         "since_seq": null
       }
     }
     ```
  4. Executive streams newline-delimited JSON events until `events.unsubscribe`, session close, or disconnect.
- **Event schema**
  ```json
  {
    "seq": 1024,
    "ts": 1739730951.512,
    "type": "debug_break",
    "pid": 2,
    "data": {
      "pc": 4096,
      "symbol": "main.loop",
      "reason": "BRK"
    }
  }
  ```
  - Required fields: `seq` (monotonic uint64), `ts` (float seconds since epoch), `type` (string), `pid` (int or `null`), `data` (object).
  - Canonical types: `trace_step` (`pc`, `opcode`, `flags`), `debug_break` (`pc`, `reason`, `breakpoint_id`), `scheduler` (`state`, `prev_pid`, `next_pid`), `mailbox_send` / `mailbox_recv` (`descriptor`, `length`, `flags`), `watch_update` (`watch_id`, `value`, `formatted`), `stdout` / `stderr` (`text`), `warning` (`message`, `category`).
  - Unknown fields MUST be ignored by clients for forward compatibility.
- **Back-pressure**
  - Each session owns a bounded ring buffer (`max_events` negotiated during `session.open`; default 256). Overflow triggers oldest-drop with a `warning` event (`reason: "backpressure"`).
  - Clients send `events.ack` with highest processed `seq` to free space eagerly; otherwise events expire after a configurable timeout (default 5 seconds).
  - `events.unsubscribe` stops streaming and releases resources; executive automatically unsubscribes when sessions close.
- **Error handling**
  - Invalid or unsupported categories yield `status:"error","error":"unsupported_category:<name>"`.
  - Subscriptions without an active session return `session_required`.
  - Clients should reconnect via `session.open` and resume with `since_seq` (last processed sequence) after transient failures.

## Scheduler state machine
```text
        +---------+        step()        +----------+
        |  READY  | --------------------> | RUNNING  |
        +----+----+                       +----+-----+
             ^                                 |
             |                                 | single instruction
             |                                 v
             |                        +------------------+
             +------------------------|  Post-instruction|
                                      +----+-------------+
                                           |
                                           | mailbox wait satisfied / yield
                                           v
                                         READY

                           no data, blocking
                         +-------------------+
                         |                   |
                         v                   |
                   +-----------+             |
                   | WAIT_MBX  |-------------+
                   +-----+-----+
                         |
            timeout      | wake (data / capacity)
                v        v
             TIMEOUT --> READY

RUNNING -- sleep_ms --> SLEEPING -- wake deadline --> READY
RUNNING -- debugger pause --> PAUSED -- resume/step --> READY
RUNNING -- task exit --> RETURNED
```

### State definitions
- **READY:** task eligible for selection; resides in a round-robin queue ordered by PID (priorities can extend this later).
- **RUNNING:** executive has restored the task context and issued exactly one `MiniVM.step()`. After retire, the scheduler evaluates trap results to determine the next state.
- **WAIT_MBX:** task blocked on mailbox send/receive; descriptor wait list records PID. Wake events originate from mailbox manager (`mailbox_wake`) or timeouts.
- **SLEEPING:** task requested `sleep_ms`. A timer heap tracks wake deadlines; tasks return to READY when the deadline elapses.
- **PAUSED:** debugger or shell suspended execution. Auto-clock stops; only manual resume/step transitions the task back to READY.
- **RETURNED / TERMINATED:** terminal states after SVC exit or fatal error. Cleanup removes task from scheduling structures.

### Invariants
- **Single-instruction quantum:** every scheduler turn executes exactly one MiniVM instruction per active PID. `TaskContext.accounted_steps` tracks accumulated work for diagnostics and fairness auditing.
- **Exclusive RUNNING:** at most one task occupies RUNNING; the executive never issues nested `step()` calls while a PID is active.
- **Wait list integrity:** a PID appears in at most one wait queue. Wake/timeout paths remove the PID before requeueing to avoid duplicate scheduling.
- **Deterministic order:** READY queue preserves PID order unless priority overrides are explicitly requested. Timeout and wake reinsertion occurs at the tail to prevent starvation.
- **Debugger safety:** when transitioning to PAUSED the executive flushes outstanding events and halts auto-clock threads to avoid re-entering the VM until control is released.

### Wait/Wake integration
- **Mailbox:** `MailboxManager` reports waiters and wake events. On wake the executive marks the PID READY, emits `mailbox_wake`, and replays the pending payload during the next `MAILBOX_RECV`.
- **Sleep timers:** monotonic min-heap keyed by deadline; scheduler polls before each round-robin iteration and moves expired entries to READY while emitting `task_wake`.
- **External interrupts:** attach/kill requests update state outside the VM. If a task is RUNNING when a debugger pause arrives, the executive schedules the pause after the current instruction to satisfy the single-instruction contract.

### Fairness & accounting
- Round-robin order ensures each READY task receives a turn; tasks that immediately re-yield (e.g., due to blocking waits) remain at the tail to avoid tight loops.
- Scheduler metrics (`scheduler_trace`, `scheduler_counters`) log transitions (`READY→RUNNING`, `RUNNING→WAIT_MBX`, etc.) so tooling can detect starvation or imbalance.
- Future priority support will adjust selection order but must preserve the single-instruction invariant and wait/wake semantics outlined here.
- Resource monitoring: runtime should expose instrumentation (e.g., `resource_usage` RPC) to compare live descriptor/stack usage against the budgets captured in `docs/resource_budgets.md`. Test plans should include section-size checks (build-time `avr-size`) and run-time assertions that prevent exceeding configured SRAM caps.

## Edge Cases
- MiniVM disconnect/crash detection with automatic restart (if configured) and session notification.
- Concurrent clients: enforce PID locks, plan read-only observer mode without breaking shell semantics.
- Resource exhaustion: descriptor/value table saturation, FRAM key collisions, event queue overflow (throttle or drop with diagnostics).
- Clock throttling when all tasks blocked (mailbox wait) to avoid busy looping.
- Mailbox waiters in current Python implementation rely on snapshot copies; after register-window remediation executive must ensure `_store_active_state` no longer clones register banks.
- Provisioning failure (CRC mismatch, missing FRAM key) should roll back to previous image and notify host via event stream.
- CAN-induced command storms must respect session locks and rate limit to prevent starvation.





//new_start


## 3. Scheduler & Run‑Control (attached)
### 3.1 Semantics
- **Single‑instruction quantum**: a scheduler slice retires 1 instruction *(or up to a configured quantum via `vm_clock(n)`) **unless** halted by SVC/BRK/fault/breakpoint*.  
- **Blocking/wake**: mailbox waits or sleep park the PID; timeouts wake; fairness maintained among READY PIDs.  
- **Session lock**: only one debugger can attach to a PID set; enforced at Executive level.

### 3.2 Breakpoint manager (Executive‑side)
- Maintains **per‑PID** sets of PC addresses.  
- **Pre‑step gate**: before calling `vm_step/clock`, Executive reads the **PC** (`reg.get(pid, REG_PC)`). If it matches a breakpoint, **do not step**; emit `debug_break`.  
- **Post‑step check**: also honours BRK opcode (VM returns `reason=break`).  
- **Actions**: on break ⇒ publish event, keep PID in READY/STOPPED state until user resumes or clears bp.

### 3.3 Pseudocode
```text
for pid in sched.ready():
  if debug_session and pid in bp_table and reg.get(pid, REG_PC) in bp_table[pid]:
    emit(debug_break(pid, pc)); continue
  res = vm.clock(quantum)  # or vm.step()
  if res.reason == svc: handle_svc(res.svc_id, pid)
  elif res.reason == break: emit(debug_break(pid, res.pc))
  elif res.reason == fault: emit(fault(pid, res.pc)); park(pid)
  sched.account(pid, res)

4. Event Protocol

Categories/fields live in executive_protocol.md
.

ACK/rate‑limit & back‑pressure rules apply to debug_break, fault, svc_error, sched_slice, etc.

Reconnect semantics: session lock, keepalive, replay window (tooling design ties in).


//new_stop






## Security & Access Control (Design Option)
- Implementation is deferred; this section captures lightweight guidance referenced by other docs so the topic stays traceable without implying active enforcement.
- Trust boundary: current prototypes assume trusted shell/debugger clients on a lab network. No authentication or ACL checks exist on RPC sessions, provisioning channels, or value/command calls.
- Potential policy hooks (future):
  - Session-level capabilities negotiated during `session.open` (observer vs control, optional shared secrets).
  - Value/command descriptors extended with `auth_level`/token hints enforced by the executive before dispatch.
  - Provisioning manifest signatures layered atop existing `.hxe` CRC checks.
  - Rate-limited mailbox/CAN ingress to mitigate flooding.
- References: `docs/security.md` tracks the placeholder scope and will evolve into normative requirements once stakeholders supply security goals.
- Until the design option graduates, keep the executive/tooling language explicit about the lack of enforcement to avoid misleading downstream specs.
## Testing Considerations
- RPC integration via `python/tests/test_exec_smoke.py`, CLI smoke scripts.
- Auto-clock and run-to-PC regression cases (`python/tests/test_vm_pause.py`).
- Session lock conflict tests (simultaneous shell/debugger attaches).
- Provisioning/persistence simulations (mock CAN transfers, FRAM load/save unit tests).
- Post-remediation tests for scheduler fairness and non-copying context switches (ties to `issues/#2_scheduler` DoD).
- Event-stream regression tests to ensure subscribers see deterministic sequences and drop notifications.
- Resource budget checks: integrate section-size assertions (e.g., `avr-size`) and runtime telemetry verifying stack/mailbox usage stays within limits from `docs/resource_budgets.md`.
- Security/ACL tests for command/val access once policy defined.

## Traceability
- **Design Requirements:** DR-1.1, DR-1.2, DR-1.3, DR-2.5, DR-3.1, DR-5.1, DR-5.2, DR-5.3, DR-6.1, DR-7.1, DR-8.1.
- **Design Goals:** DG-1.2, DG-1.3, DG-1.4, DG-2.3, DG-3.1�3.5, DG-4.2, DG-5.1�5.4, DG-6.1�6.4, DG-7.1�7.3, DG-8.1�8.3.
- **Design Options:** DO-5.a, DO-6.a, DO-7.a, DO-relay.

