# Design Spec - Executive

## 1. Scope
- Host controller managing MiniVM lifecycle, scheduling, and IPC services (DR-5.1, DR-5.3, DG-5.1).
- JSON-over-TCP RPC server consumed by shell, debugger, and tooling clients (DR-8.1, DG-5.2, DG-8.1).
- Event capture and fan-out for trace, breakpoint, and mailbox transitions (DR-8.1, DG-5.2).
- Provisioning workflows that load and reload tasks, manage FRAM persistence, and serve CAN, SD, or host sources (DR-1.1, DR-5.3, DG-1.2).
- Debug traps (BRK, single-step), SVC invocations, and error events emitted as structured payloads compatible with the executive protocol (DR-8.1, DG-5.2).

### 1.1 Operating Principles
- Drive the VM strictly via attached stepping (`vm_set_context`, `vm_step`, `vm_clock`); no autonomous scheduling runs inside the VM.
- Provide an SVC bridge that dispatches module requests (mailbox, value, command, provisioning, HAL shims) to host handlers.
- Manage debugger sessions, breakpoint lists, and event stream delivery with acknowledgement and rate limiting.
- Expose a host control plane for tooling (attach, step/clock, breakpoint management, register access, process status).

## 2. Preconditions
- MiniVM emits structured events (debug_stop, mailbox, trace) and honours SVC/BRK semantics as described in DG-5 and DG-6 (DR-8.1, DG-4.2, DG-5.2).
- Mailbox, value/command, and provisioning services exist (per architecture sections 3.3 and 3.4) so executive callbacks can delegate work (DR-6.1, DR-7.1, DR-5.3).
- Toolchain provides `.hxe` images and, when available, symbol metadata that enables stack reconstruction and disassembly annotations (DR-3.1, DG-3.3, DR-2.5).
- Host environment exposes networking or transport required for the debugger CLI/TUI (TCP loopback on desktop, UART relay on embedded targets) (DR-8.1, DG-8.3).

## 3. Postconditions
- Scheduler enforces single-instruction quanta with PID locking and exposes state required by debugger tooling (DR-5.1, DG-5.4, DG-5.3).
- Session and event RPCs (`session.open`, `events.subscribe`, etc.) stream structured events with documented back-pressure controls (DR-8.1, DG-5.2, DG-8.2).
- PID-level services (`ps`, `stack`, `memory`, `watch`) provide the data expected by the HSX debugger/TUI (`functionality/#1_TUI_DEBUGGER`) (DR-8.1, DG-8.1).
- Provisioning, stdio, mailbox, and persistence hooks remain backwards compatible while exposing the new debugger instrumentation (DR-1.1, DR-5.3, DR-6.1, DR-7.1).

## 4. State & Data Model
### 4.1 ExecutiveState
- `tasks: Dict[int, TaskRecord]` stores PID metadata.
- `task_states: Dict[int, Dict[str, Any]]` caches MiniVM snapshots.
- `current_pid`, `waiting_tasks`, `auto_thread`, `auto_event`, `clock_mode` hold scheduler control.
- Logging and accounting (`_next_log_seq`, `log_buffer`, `scheduler_trace`, `scheduler_counters`) capture diagnostics.
- `sessions: Dict[str, Session]` records active client sessions and their locks.

### 4.2 TaskRecord
```python
{
    "pid": int,
    "state": str,            # running, ready, waiting_mbx, paused, returned, terminated
    "pc": int,
    "priority": int,
    "quantum": int,
    "program": str,
    "vm_state": Dict[str, Any],
    "stdout": str,
    "sleep_pending": bool,
    "reg_base": int,
    "stack_base": int,
    "stack_limit": int,
    "stack_size": int,
    "trace": bool,
    "exit_status": Optional[int],
}
```

### 4.3 Sessions, Events, and Provisioning
- Session records (`Session(id, client_info, lock_pid, capabilities, keepalive_ts, event_cursor, filters)`) guarantee at most one debugger per PID while allowing observer sessions.
- Event bus: bounded ring buffer of `Event{seq, ts, type, pid, payload}` with per-session cursors. Owner sessions retain priority; observer cursors are evicted first when retention limits trigger.
- Provisioning: see [04.07--Provisioning.md](04.07--Provisioning.md)
- Resource budgets (per target, TBD) capture limits for PID count, register arenas, stack pools, mailbox descriptors, and FRAM capacity. Final numbers live in `docs/resource_budgets.md` and feed scheduler/resource guardrails.

## 5. Interfaces
### 5.1 SVC / ABI (module 0x06 EXEC)
> Authoritative definitions live in [abi_syscalls.md](../../docs/abi_syscalls.md).

| Func | R0 | R1 | R2 | R3 | Return | Errors | Time base |
|------|----|----|----|----|--------|--------|-----------|
| `GET_VERSION` | buf | len | - | - | n | - | us/ticks |
| `STEP` | - | - | - | - | rc | - | us/ticks |
| `CLOCK` | n | - | - | - | rc | - | us/ticks |
| `ATTACH` / `DETACH` | pid | - | - | - | rc | EPERM | - |
| `PS` | buf | len | flags | - | n | - | - |
| `SCHED` | op | arg | - | - | rc | EINVAL | - |

*Exact function set must match `abi_syscalls.md`; this table anchors the design discussion.*

### 5.2 Host Control-Plane APIs (non-SVC)
| API | Args | Returns | Notes |
|-----|------|---------|-------|
| `session.open(pid?)` | PID or `null` | rc | Claims exclusive debug session (locks PID set). |
| `session.close()` | - | rc | Releases session lock and subscriptions. |
| `ps()` | - | list[pid, state, pc] | Snapshot of tasks. |
| `vm.set_context(pid)` | pid | rc | Selects active PID before register/memory ops. |
| `vm.step()` / `vm.clock(n)` | - / n | StepResult | Drives VM under scheduler rules. |
| `reg.get(pid, reg_id)` | pid, const | u32 | Reads register via VM helpers. |
| `reg.set(pid, reg_id, value)` | pid, const, u32 | rc | Writes register (policy gated). |
| `bp.set(pid, addr)` | pid, code addr | rc | Adds breakpoint to per-PID set. |
| `bp.clear(pid, addr)` | pid, code addr | rc | Removes breakpoint. |
| `bp.list(pid)` | pid | list[addr] | Lists breakpoints. |

Tool breakpoints remain executive-side comparisons; no code patching inside the guest is required.

## 6. Operational Behaviour
### 6.1 RPC Handling
1. Parse JSON payload and validate the protocol `version` (currently 1).
2. Retrieve and verify the session, enforcing lock semantics (one debugger per PID set).
3. Dispatch to the handler (load, attach, clock, scheduler, mailbox, value/command, provisioning).
4. Convert exceptions to `{"status": "error", "error": ...}` and append diagnostics to `log_buffer`.

### 6.2 Attach and Detach Flow
- `attach(pid)` stops auto clocking, calls `_activate_task`, and marks the session lock.
- `detach()` clears locks, resumes internal clocking if previously running, and ensures `MiniVM.attached` is false.
- PID-specific attach is supported; a `pid=None` attach allows a global session when only one task exists.

### 6.3 Clock Modes
- `manual`: only explicit `step` or `clock` RPCs advance execution.
- `auto`: background thread issues batched steps at a configured rate.
- `detached`: MiniVM runs its internal loop when no executive attachment exists.

### 6.4 Event Intake and Distribution
- Collect events from `MiniVM.consume_events()` (debug_break, svc, mailbox, trace) plus executive instrumentation (scheduler trace, provisioning logs) and append to the shared ring (`max_events = 512`, retention ~5 s default).
- Each subscriber maintains cursors and filter sets. Owners receive priority; observers are unsubscribed first when they fail to acknowledge.
- ACK protocol: clients issue `events.ack` with the highest processed sequence. Executive reclaims entries once every subscriber has advanced or the retention timer expires. Drops emit `warning` events with `reason: "event_dropped"` so clients can resynchronise via `since_seq`.

### 6.5 Provisioning Flow
1. Host CLI issues `load <path>` or a CAN/SD transfer triggers provisioning.
2. Executive verifies the `.hxe` header, allocates a PID, and prepares register and stack arenas.
3. If FRAM keys exist, persisted values load before the task resumes.
4. CAN/SD transfers report progress and errors through mailbox or value channels back to the host.

### 6.6 Persistence Hooks
- `val.persist` binds values to FRAM keys. The executive loads persisted values on task start and writes updates on `val.set` (with debounce) or on shutdown. FRAM layout guidance lives in `docs/resource_budgets.md` (P0).

### 6.7 StdIO Routing
- On task load the executive binds `svc:stdio.*` mailboxes. Shell `listen` commands attach to these descriptors for stdout and stderr streaming.

### 6.8 Resource Envelopes
- Honor limits from `docs/resource_budgets.md`: <=28 KiB text, <=5.5 KiB SRAM for runtime, plus per-task stack and register allocations when mapping C structures and linker scripts.

### 6.9 Debugger Session Handshake
- `session.open` negotiates protocol version and capabilities, acquires optional PID locks, and returns heartbeat interval plus maximum event buffer size.
- `session.keepalive` refreshes idle timers. `session.close` releases locks and unsubscribes from all event feeds.

## 7. Event Streaming Contract
> Keep `docs/executive_protocol.md` aligned with this section; new event types, fields, or RPCs must be documented there.

### 7.1 Subscribe Flow
1. Client issues `session.open` with fields such as `client` (identifier), `version` (protocol integer), `capabilities` (`{"features": ["events", "stack", "watch"], "max_events": 256}`), and optional `pid_lock` (int or `null`).
2. Executive responds with `session_id`, negotiated capability set, heartbeat interval, and warnings for unsupported features.
3. Client sends `events.subscribe`:

```json
{
  "version": 1,
  "cmd": "events.subscribe",
  "session": "<id>",
  "filters": {
    "pid": [1, 3],
    "categories": ["debug_break", "trace_step", "scheduler", "mailbox", "watch"],
    "since_seq": null
  }
}
```

4. Executive streams newline-delimited JSON events until `events.unsubscribe`, session close, or disconnect.

### 7.2 Event Schema
```json
{
  "seq": 1024,
  "ts": 1739730951.512,
  "type": "debug_break",
  "pid": 2,
  "data": {
    "pc": 4096,
    "symbol": "main.loop",
    "reason": "BRK"
  }
}
```
- Required fields: `seq` (monotonic uint64), `ts` (float seconds since epoch), `type` (string), `pid` (int or `null`), `data` (object).
- Canonical types include `trace_step` (`pc`, `opcode`, `flags`), `debug_break` (`pc`, `reason`, `breakpoint_id`), `scheduler` (`state`, `prev_pid`, `next_pid`), `mailbox_send` / `mailbox_recv` (`descriptor`, `length`, `flags`), `watch_update` (`watch_id`, `value`, `formatted`), `stdout` / `stderr` (`text`), and `warning` (`message`, `category`).
- Clients must ignore unknown fields for forward compatibility.

### 7.3 Back-pressure and ACKs
- Each session owns a bounded ring buffer (`max_events` negotiated during `session.open`; default 256). Overflow drops oldest entries and emits a `warning` event with `reason: "backpressure"`.
- Clients send `events.ack` with the highest processed sequence to free space eagerly; otherwise events expire after a configurable timeout (default 5 s).
- `events.unsubscribe` stops streaming and releases buffers automatically when sessions close.

### 7.4 Error Handling
- Invalid or unsupported categories return `status: "error"` with `error: "unsupported_category:<name>"`.
- Subscriptions without an active session return `session_required`.
- After transient failures clients reconnect with `session.open` and resume from the last processed sequence via `since_seq`.

### 7.5 Reconnect and Keepalive
- Session locks, keepalive heartbeats, and replay windows work together to resume streams predictably. Tooling maintains a replay window sized to the negotiated `max_events` while the executive drops inactive observers first to protect owner sessions.

## 8. Scheduler & Run Control
### 8.1 State Machine
```text
        +---------+        step()        +----------+
        |  READY  | --------------------> | RUNNING  |
        +----+----+                       +----+-----+
             ^                                 |
             |                                 | single instruction
             |                                 v
             |                        +------------------+
             +------------------------|  Post-instruction|
                                      +----+-------------+
                                           |
                                           | mailbox wait satisfied / yield
                                           v
                                         READY

                           no data, blocking
                         +-------------------+
                         |                   |
                         v                   |
                   +-----------+             |
                   | WAIT_MBX  |-------------+
                   +-----+-----+
                         |
            timeout      | wake (data / capacity)
                v        v
             TIMEOUT --> READY

RUNNING -- sleep_ms --> SLEEPING -- wake deadline --> READY
RUNNING -- debugger pause --> PAUSED -- resume/step --> READY
RUNNING -- task exit --> RETURNED
```

### 8.2 State Definitions
- **READY:** task eligible for selection in the round-robin queue (future priority overlays allowed).
- **RUNNING:** executive has restored context and retired exactly one `MiniVM.step()`; post-instruction handling determines next state.
- **WAIT_MBX:** task blocked on mailbox send/receive; descriptor wait lists record PID and wake on mailbox or timeout.
- **SLEEPING:** task requested `sleep_ms`; timer heap tracks wake deadlines.
- **PAUSED:** debugger or shell suspended execution; auto-clock stops until resume.
- **RETURNED / TERMINATED:** terminal states after SVC exit or fatal error. Cleanup removes task from scheduling structures.

### 8.3 Invariants
- Single-instruction quantum: each scheduler turn executes one instruction per active PID. `TaskContext.accounted_steps` tracks totals for diagnostics.
- Exclusive RUNNING: the executive never issues nested `step()` calls while a PID is active.
- Wait list integrity: a PID appears in at most one wait queue; wake and timeout paths remove entries before requeueing.
- Deterministic order: READY queue preserves PID order unless explicit priority overrides apply. Wake and timeout reinsertion occurs at the tail to avoid starvation.
- Debugger safety: transitioning to PAUSED flushes events and halts auto-clock threads before re-entering the VM.

### 8.4 Wait/Wake Integration
- Mailbox manager reports waiters and wake events. On wake the executive marks the PID READY, emits `mailbox_wake`, and replays pending payloads during the next mailbox receive call.
- Sleep timers use a monotonic min-heap keyed by deadline; scheduler polls before each round-robin iteration and moves expired entries to READY while emitting `task_wake`.
- External interrupts such as attach/kill requests update state outside the VM. If a task is RUNNING when a debugger pause arrives, the executive schedules the pause after the current instruction to preserve the single-instruction contract.

### 8.5 Fairness & Accounting
- Round-robin order ensures each READY task receives a turn; tasks that immediately re-yield stay at the tail to avoid tight loops.
- Metrics (`scheduler_trace`, `scheduler_counters`) log transitions (READY->RUNNING, RUNNING->WAIT_MBX, etc.) so tooling can detect imbalance or starvation.
- Future priority support must maintain the single-instruction invariant and respect wait/wake semantics.
- Runtime instrumentation (for example `resource_usage` RPC) compares live descriptor and stack usage against the budgets in `docs/resource_budgets.md`; test plans include build-time (`avr-size`) and run-time (guard page) checks.

### 8.6 Breakpoint Management
- Maintain per-PID breakpoint sets.
- Pre-step gate: before calling `vm_step` or `vm_clock`, read `REG_PC`. If it matches a breakpoint, emit `debug_break` and skip execution.
- Post-step check: respect BRK opcodes by interpreting `StepResult.reason == break` and emitting `debug_break`.
- Breakpoints leave the PID in READY/STOPPED state until the user resumes or clears them.

### 8.7 Run Loop Pseudocode
```text
for pid in sched.ready():
    if debug_session and pid in bp_table and reg.get(pid, REG_PC) in bp_table[pid]:
        emit(debug_break(pid, pc))
        continue
    res = vm.clock(quantum)  # or vm.step()
    if res.reason == svc:
        handle_svc(res.svc_id, pid)
    elif res.reason == break:
        emit(debug_break(pid, res.pc))
    elif res.reason == fault:
        emit(fault(pid, res.pc))
        park(pid)
    sched.account(pid, res)
```

### 8.8 Event Protocol Integration
- Event categories and field definitions are governed by `docs/executive_protocol.md`. ACK, rate limiting, and back-pressure rules apply uniformly to `debug_break`, `fault`, `svc_error`, `sched_slice`, and related events.
- Reconnect semantics reuse the session lock, keepalive, and replay window defined in the event streaming contract.

## 9. Edge Cases
- Detect MiniVM disconnects or crashes, automatically restart if configured, and notify sessions.
- Enforce PID locks for concurrent clients; plan for read-only observer mode without breaking shell semantics.
- Handle resource exhaustion: descriptor or value table saturation, FRAM key collisions, event queue overflow (throttle or drop with diagnostics).
- Throttle clocks when all tasks block on mailbox waits to avoid busy loops.
- Current Python implementation snapshots mailbox waiters; after register-window remediation ensure `_store_active_state` stops cloning register banks.
- Provisioning failure (CRC mismatch, missing FRAM key) rolls back to the previous image and notifies the host via event stream.
- CAN-induced command storms must respect session locks and rate limits to prevent starvation.

## 10. Security & Access Control (Design Option)
- Current prototypes assume trusted shell/debugger clients on a lab network; no authentication or ACL checks exist on RPC sessions, provisioning channels, or value/command calls.
- Potential hooks:
  - Session-level capabilities negotiated during `session.open` (observer versus control, optional shared secrets).
  - Value/command descriptors extended with `auth_level` or token hints enforced before dispatch.
  - Provisioning manifest signatures layered atop existing `.hxe` CRC checks.
  - Rate-limited mailbox or CAN ingress to mitigate flooding.
- `docs/security.md` tracks this placeholder scope and will evolve once security goals are defined. Documentation must remain explicit about the lack of enforcement until the design option graduates.

## 11. Testing Strategy
- RPC integration via `python/tests/test_exec_smoke.py` plus CLI smoke scripts.
- Auto-clock and run-to-PC regression coverage (`python/tests/test_vm_pause.py`).
- Session lock conflict tests for simultaneous shell/debugger attaches.
- Provisioning and persistence simulations (mock CAN transfers, FRAM load/save unit tests).
- Post-remediation scheduler tests confirming fairness and non-copying context switches (ties to `issues/#2_scheduler` DoD).
- Event-stream regression tests verifying deterministic sequences and drop notifications for subscribers.
- Resource budget checks: integrate section-size assertions (`avr-size`) and runtime telemetry to verify stack/mailbox usage stays within documented limits.
- Security/ACL tests for command/value access once policy hooks exist.

## 12. Traceability
- Design Requirements: DR-1.1, DR-1.2, DR-1.3, DR-2.5, DR-3.1, DR-5.1, DR-5.2, DR-5.3, DR-6.1, DR-7.1, DR-8.1.
- Design Goals: DG-1.2, DG-1.3, DG-1.4, DG-2.3, DG-3.1..DG-3.5, DG-4.2, DG-5.1..DG-5.4, DG-6.1..DG-6.4, DG-7.1..DG-7.3, DG-8.1..DG-8.3.
- Design Options: DO-5.a, DO-6.a, DO-7.a, DO-relay.
