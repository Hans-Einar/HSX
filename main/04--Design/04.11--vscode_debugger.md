# Design Spec - VS Code Debug Adapter Protocol Integration
# 04.11--vscode_debugger Design (v3, repo style)
**Status:** DRAFT | **Date:** 2025-10-31 | **Owner:** HSX Core

> **Design stance:** The VS Code debug adapter translates between the Debug Adapter Protocol (DAP) and the HSX executive RPC protocol, enabling source-level debugging in VS Code and compatible IDEs. The adapter performs no direct VM manipulation and coordinates all operations through the executive.

**Authoritative context (repo-local):**
- Debugger Protocol: [04.09--Debugger.md](04.09--Debugger.md)
- TUI Debugger: [04.10--TUI_Debugger.md](04.10--TUI_Debugger.md)
- Architecture: [03.06--Toolkit](../03--Architecture/03.06--Toolkit.md), [03.00--Architecture](../03--Architecture/03.00--Architecture.md)
- Study & Requirements: [02--Study](../02--Study/02--Study.md), [02.01--Requirements](../02--Study/02.01--Requirements.md)
- Implementation-phase specs: [docs/executive_protocol.md](../../docs/executive_protocol.md)

**Traceability (fill from 02.01--Requirements):** Refs DR-8.1, DG-8.1, DG-8.3.

## 1. Scope
- Debug Adapter Protocol (DAP) implementation for VS Code and compatible IDEs (DG-8.1, DG-8.3).
- Protocol translation between DAP (JSON-RPC over stdio/TCP) and HSX executive RPC (DR-8.1).
- Source-level debugging with breakpoints, stepping, variable inspection in IDE UI (DG-8.1).
- VS Code extension providing debug configuration and adapter lifecycle management (DG-8.3).
- Cross-platform support for Windows, macOS, and Linux development environments (DG-8.3).

## 2. Preconditions
- HSX executive implements debugger protocol per [04.09--Debugger.md](04.09--Debugger.md) (DR-8.1).
- Toolchain produces .sym files with complete source line mapping (DR-3.1, DG-3.3).
- VS Code version 1.70.0 or later installed on development machine (DG-8.3).
- Python 3.8+ available for debug adapter implementation (DG-8.3).
- Source files available at paths consistent with .sym file metadata (DR-3.1).

## 3. Postconditions
- Developers can debug HSX applications using VS Code's native debugging UI (DR-8.1, DG-8.1).
- Breakpoints set in source files translate to executive breakpoint commands (DR-8.1).
- Step over/into/out operations work at source line granularity (DG-8.1).
- Variables, registers, and call stacks display in VS Code debug panels (DG-8.1).
- Debug sessions integrate seamlessly with existing VS Code workflows (DG-8.3).

## 4. Architectural Overview

### 4.1 Design Principles
- **Protocol bridging:** Clean translation between DAP and HSX executive protocol without state duplication.
- **IDE-native experience:** Leverage VS Code's built-in debugging UI rather than custom panels.
- **Source-level abstraction:** Map instruction-level operations to source lines for developer experience.
- **Session coordination:** Maintain synchronization between IDE state and executive session state.
- **Error transparency:** Surface executive errors clearly in IDE UI.

### 4.2 Component Architecture

```
┌────────────────┐         ┌──────────────────┐         ┌────────────────┐
│   VS Code      │  DAP    │  HSX Debug       │  RPC    │  HSX Executive │
│   Extension    │◄────────┤  Adapter         │◄────────┤  (execd.py)    │
│                │         │  (hsx-dap.py)    │         │                │
└────────────────┘         └──────────────────┘         └────────────────┘
        │                          │                            │
        │                          │                            │
    UI Layer              Protocol Translation          Runtime Control
```

**Components:**
1. **VS Code Extension:** Provides debug configuration UI and launches adapter process.
2. **Debug Adapter (`hsx-dap.py`):** Python process implementing DAP server, translating to/from HSX executive RPC.
3. **Symbol Loader:** Reads .sym files to map between source lines and instruction addresses.
4. **Executive Client:** Connection manager for HSX executive RPC protocol.

## 5. Debug Adapter Protocol (DAP) Implementation

### 5.1 DAP Lifecycle

**Initialization Sequence:**
```
VS Code                     Debug Adapter              Executive
   |                              |                         |
   |--initialize----------------->|                         |
   |<--capabilities---------------|                         |
   |--launch/attach-------------->|                         |
   |                              |--session.open---------->|
   |                              |<--session_id------------|
   |                              |--events.subscribe------>|
   |<--initialized----------------|                         |
   |--configurationDone---------->|                         |
```

**Supported DAP Requests:**
- `initialize`: Negotiate capabilities (source breakpoints, step operations, variable inspection)
- `launch`: Start new debug session with executable path
- `attach`: Attach to running HSX process (future enhancement)
- `setBreakpoints`: Set/clear breakpoints in source files
- `continue`: Resume execution until next breakpoint
- `next`: Step over (source line granularity)
- `stepIn`: Step into function calls (source line granularity)
- `stepOut`: Step out of current function
- `pause`: Pause execution at current location
- `stackTrace`: Retrieve call stack with source locations
- `scopes`: Enumerate variable scopes (registers, locals)
- `variables`: Retrieve variable values in scope
- `evaluate`: Evaluate watch expressions or hover queries
- `disconnect`: End debug session

### 5.2 Debug Adapter Implementation

**File: `python/hsx-dap.py`**

```python
#!/usr/bin/env python3
"""
HSX Debug Adapter for VS Code Debug Adapter Protocol (DAP).
Translates between DAP and HSX executive RPC protocol.
"""

import asyncio
import json
import logging
import os
import sys
from pathlib import Path
from typing import Any, Dict, List, Optional

# DAP library - use existing Python DAP implementation
# Options: debugpy.adapter, ptvsd, or custom implementation
from debugpy.server import api as debugpy_api


class HSXDebugAdapter:
    """Debug adapter bridging VS Code DAP and HSX executive protocol."""
    
    def __init__(self):
        self.executive_client: Optional[ExecutiveClient] = None
        self.session_id: Optional[str] = None
        self.pid: Optional[int] = None
        self.breakpoints: Dict[str, List[int]] = {}  # file -> [breakpoint_ids]
        self.symbol_loader: Optional[SymbolLoader] = None
        self.stopped = False
        self.event_task: Optional[asyncio.Task] = None
    
    async def on_initialize(self, args: Dict[str, Any]) -> Dict[str, Any]:
        """Handle DAP initialize request."""
        return {
            'supportsConfigurationDoneRequest': True,
            'supportsSetVariable': True,
            'supportsConditionalBreakpoints': False,
            'supportsHitConditionalBreakpoints': False,
            'supportsEvaluateForHovers': True,
            'supportsStepBack': False,
            'supportsRestartFrame': False,
            'supportsGotoTargetsRequest': False,
            'supportsStepInTargetsRequest': False,
            'supportsCompletionsRequest': False,
            'supportsExceptionOptions': False,
            'supportsValueFormattingOptions': True,
            'supportsDisassembleRequest': True,
            'supportsInstructionBreakpoints': True,
            'supportsReadMemoryRequest': True,
            'supportsWriteMemoryRequest': True,
        }
    
    async def on_launch(self, args: Dict[str, Any]) -> None:
        """Handle DAP launch request."""
        # Extract configuration
        program = args['program']
        host = args.get('host', 'localhost')
        port = args.get('port', 9998)
        stop_on_entry = args.get('stopOnEntry', True)
        
        # Connect to executive
        self.executive_client = ExecutiveClient(host, port)
        await self.executive_client.connect()
        
        # Open debug session
        response = await self.executive_client.request({
            'cmd': 'session.open',
            'client': 'vscode-dap',
            'capabilities': {
                'features': ['events', 'stack', 'watch', 'breakpoints']
            }
        })
        self.session_id = response['session_id']
        
        # Load program into executive
        response = await self.executive_client.request({
            'cmd': 'load',
            'path': str(Path(program).resolve())
        })
        self.pid = response['image']['pid']
        
        # Load symbol file for source mapping
        sym_file = Path(program).with_suffix('.sym')
        if sym_file.exists():
            self.symbol_loader = SymbolLoader(sym_file)
        else:
            logging.warning(f"Symbol file not found: {sym_file}")
            self.symbol_loader = None
        
        # Subscribe to executive events
        await self.executive_client.request({
            'cmd': 'events.subscribe',
            'session': self.session_id,
            'filters': {
                'pid': [self.pid],
                'categories': ['debug_break', 'trace_step', 'stdout', 'stderr']
            }
        })
        
        # Start event processing loop
        self.event_task = asyncio.create_task(self.event_loop())
        
        # Send initialized event to VS Code
        self.send_event('initialized', {})
        
        # Stop on entry if requested
        if stop_on_entry:
            self.stopped = True
            self.send_event('stopped', {
                'reason': 'entry',
                'threadId': self.pid,
                'allThreadsStopped': True
            })
    
    async def on_setBreakpoints(self, args: Dict[str, Any]) -> Dict[str, Any]:
        """Handle DAP setBreakpoints request."""
        source = args['source']
        file_path = source['path']
        requested_bps = args.get('breakpoints', [])
        
        # Clear existing breakpoints for this file
        if file_path in self.breakpoints:
            for bp_id in self.breakpoints[file_path]:
                await self.executive_client.request({
                    'cmd': 'bp.clear',
                    'session': self.session_id,
                    'pid': self.pid,
                    'breakpoint_id': bp_id
                })
            self.breakpoints[file_path] = []
        
        # Set new breakpoints
        result_bps = []
        for bp_spec in requested_bps:
            line = bp_spec['line']
            
            # Resolve source line to instruction address
            addr = None
            if self.symbol_loader:
                addr = self.symbol_loader.resolve_line_to_addr(file_path, line)
            
            if addr is not None:
                # Set breakpoint at resolved address
                try:
                    response = await self.executive_client.request({
                        'cmd': 'bp.set',
                        'session': self.session_id,
                        'pid': self.pid,
                        'addr': addr
                    })
                    
                    bp_id = response['breakpoint_id']
                    self.breakpoints.setdefault(file_path, []).append(bp_id)
                    
                    result_bps.append({
                        'verified': True,
                        'line': line,
                        'id': bp_id
                    })
                except Exception as e:
                    logging.error(f"Failed to set breakpoint at {file_path}:{line}: {e}")
                    result_bps.append({
                        'verified': False,
                        'line': line,
                        'message': f"Failed to set breakpoint: {e}"
                    })
            else:
                result_bps.append({
                    'verified': False,
                    'line': line,
                    'message': 'No executable code at this line'
                })
        
        return {'breakpoints': result_bps}
    
    async def on_continue(self, args: Dict[str, Any]) -> Dict[str, Any]:
        """Handle DAP continue request."""
        await self.executive_client.request({
            'cmd': 'continue',
            'session': self.session_id,
            'pid': self.pid
        })
        
        self.stopped = False
        return {'allThreadsContinued': True}
    
    async def on_next(self, args: Dict[str, Any]) -> None:
        """Handle DAP next (step over) request."""
        # Step at source line level: keep stepping until line changes
        if not self.symbol_loader:
            # Fallback to single instruction step
            await self.executive_client.request({
                'cmd': 'step',
                'session': self.session_id,
                'pid': self.pid,
                'count': 1
            })
        else:
            current_line = await self.get_current_source_line()
            
            # Step until line changes (with safety limit)
            for _ in range(1000):
                await self.executive_client.request({
                    'cmd': 'step',
                    'session': self.session_id,
                    'pid': self.pid,
                    'count': 1
                })
                
                new_line = await self.get_current_source_line()
                if new_line != current_line:
                    break
        
        self.stopped = True
        self.send_event('stopped', {
            'reason': 'step',
            'threadId': self.pid,
            'allThreadsStopped': True
        })
    
    async def on_stepIn(self, args: Dict[str, Any]) -> None:
        """Handle DAP stepIn request."""
        # Similar to next, but don't skip over function calls
        # For now, treat same as next (single step until line changes)
        await self.on_next(args)
    
    async def on_stepOut(self, args: Dict[str, Any]) -> None:
        """Handle DAP stepOut request."""
        # Continue until return from current function
        # Simplified: step until stack depth decreases
        initial_depth = await self.get_stack_depth()
        
        for _ in range(10000):  # Safety limit
            await self.executive_client.request({
                'cmd': 'step',
                'session': self.session_id,
                'pid': self.pid,
                'count': 1
            })
            
            current_depth = await self.get_stack_depth()
            if current_depth < initial_depth:
                break
        
        self.stopped = True
        self.send_event('stopped', {
            'reason': 'step',
            'threadId': self.pid,
            'allThreadsStopped': True
        })
    
    async def on_pause(self, args: Dict[str, Any]) -> None:
        """Handle DAP pause request."""
        await self.executive_client.request({
            'cmd': 'pause',
            'session': self.session_id,
            'pid': self.pid
        })
        
        self.stopped = True
        self.send_event('stopped', {
            'reason': 'pause',
            'threadId': self.pid,
            'allThreadsStopped': True
        })
    
    async def on_stackTrace(self, args: Dict[str, Any]) -> Dict[str, Any]:
        """Handle DAP stackTrace request."""
        response = await self.executive_client.request({
            'cmd': 'stack.info',
            'session': self.session_id,
            'pid': self.pid,
            'max_frames': args.get('levels', 20)
        })
        
        frames = []
        for i, frame in enumerate(response['frames']):
            source_info = None
            if self.symbol_loader:
                source_info = self.symbol_loader.lookup_source_from_pc(frame['pc'])
            
            stack_frame = {
                'id': i,
                'name': frame.get('symbol', f"0x{frame['pc']:04X}"),
                'line': source_info['line'] if source_info else 0,
                'column': 0,
            }
            
            if source_info:
                stack_frame['source'] = {
                    'name': os.path.basename(source_info['file']),
                    'path': source_info['file']
                }
            
            frames.append(stack_frame)
        
        return {'stackFrames': frames, 'totalFrames': len(frames)}
    
    async def on_scopes(self, args: Dict[str, Any]) -> Dict[str, Any]:
        """Handle DAP scopes request."""
        return {
            'scopes': [
                {
                    'name': 'Registers',
                    'variablesReference': 1000,
                    'expensive': False
                },
                {
                    'name': 'Locals',
                    'variablesReference': 2000,
                    'expensive': False
                }
            ]
        }
    
    async def on_variables(self, args: Dict[str, Any]) -> Dict[str, Any]:
        """Handle DAP variables request."""
        ref = args['variablesReference']
        
        if ref == 1000:  # Registers scope
            response = await self.executive_client.request({
                'cmd': 'reg.get',
                'session': self.session_id,
                'pid': self.pid
            })
            
            variables = []
            for name, value in sorted(response['registers'].items()):
                variables.append({
                    'name': name,
                    'value': f"0x{value:04X}" if isinstance(value, int) else str(value),
                    'type': 'register',
                    'variablesReference': 0
                })
            
            return {'variables': variables}
        
        elif ref == 2000:  # Locals scope
            # TODO: Implement local variable display from watch list or debug info
            return {'variables': []}
        
        return {'variables': []}
    
    async def on_evaluate(self, args: Dict[str, Any]) -> Dict[str, Any]:
        """Handle DAP evaluate request (hover, watch)."""
        expression = args['expression']
        context = args.get('context', 'watch')
        
        # Try to evaluate as register name
        if expression.upper() in ('PC', 'SP', 'R0', 'R1', 'R2', 'R3', 'R4', 'R5', 
                                   'R6', 'R7', 'R8', 'R9', 'R10', 'R11', 'R12', 
                                   'R13', 'R14', 'R15'):
            response = await self.executive_client.request({
                'cmd': 'reg.get',
                'session': self.session_id,
                'pid': self.pid,
                'reg': expression.upper()
            })
            value = response['registers'][expression.upper()]
            return {
                'result': f"0x{value:04X}",
                'type': 'register',
                'variablesReference': 0
            }
        
        # TODO: Support watch expressions via executive watch API
        return {
            'result': f"<cannot evaluate '{expression}'>",
            'variablesReference': 0
        }
    
    async def on_disconnect(self, args: Dict[str, Any]) -> None:
        """Handle DAP disconnect request."""
        # Close debug session
        if self.session_id:
            await self.executive_client.request({
                'cmd': 'session.close',
                'session': self.session_id
            })
        
        # Cancel event loop
        if self.event_task:
            self.event_task.cancel()
        
        # Close executive connection
        if self.executive_client:
            await self.executive_client.close()
    
    async def event_loop(self):
        """Process events from executive and forward to VS Code."""
        try:
            while True:
                event = await self.executive_client.receive_event()
                
                if event['type'] == 'debug_break':
                    self.stopped = True
                    self.send_event('stopped', {
                        'reason': 'breakpoint',
                        'threadId': self.pid,
                        'allThreadsStopped': True
                    })
                
                elif event['type'] == 'stdout':
                    self.send_event('output', {
                        'category': 'stdout',
                        'output': event['data']['text']
                    })
                
                elif event['type'] == 'stderr':
                    self.send_event('output', {
                        'category': 'stderr',
                        'output': event['data']['text']
                    })
        
        except asyncio.CancelledError:
            pass
        except Exception as e:
            logging.error(f"Event loop error: {e}")
    
    async def get_current_source_line(self) -> Optional[tuple]:
        """Get current source location (file, line)."""
        response = await self.executive_client.request({
            'cmd': 'reg.get',
            'session': self.session_id,
            'pid': self.pid,
            'reg': 'PC'
        })
        pc = response['registers']['PC']
        
        if self.symbol_loader:
            source_info = self.symbol_loader.lookup_source_from_pc(pc)
            if source_info:
                return (source_info['file'], source_info['line'])
        
        return None
    
    async def get_stack_depth(self) -> int:
        """Get current call stack depth."""
        response = await self.executive_client.request({
            'cmd': 'stack.info',
            'session': self.session_id,
            'pid': self.pid,
            'max_frames': 100
        })
        return len(response['frames'])
    
    def send_event(self, event_type: str, body: Dict[str, Any]):
        """Send DAP event to VS Code."""
        # Implementation depends on DAP library used
        # Example: print JSON to stdout for stdio-based DAP
        message = {
            'type': 'event',
            'event': event_type,
            'body': body
        }
        print(json.dumps(message), flush=True)


class ExecutiveClient:
    """Client for HSX executive RPC protocol."""
    
    def __init__(self, host: str, port: int):
        self.host = host
        self.port = port
        self.reader: Optional[asyncio.StreamReader] = None
        self.writer: Optional[asyncio.StreamWriter] = None
    
    async def connect(self):
        """Connect to executive."""
        self.reader, self.writer = await asyncio.open_connection(
            self.host, self.port
        )
    
    async def close(self):
        """Close connection."""
        if self.writer:
            self.writer.close()
            await self.writer.wait_closed()
    
    async def request(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        """Send request and receive response."""
        payload.setdefault('version', 1)
        request_line = json.dumps(payload) + '\n'
        
        self.writer.write(request_line.encode('utf-8'))
        await self.writer.drain()
        
        response_line = await self.reader.readline()
        return json.loads(response_line)
    
    async def receive_event(self) -> Dict[str, Any]:
        """Receive event from executive."""
        line = await self.reader.readline()
        return json.loads(line)


class SymbolLoader:
    """Loader for .sym files providing source mapping."""
    
    def __init__(self, sym_file: Path):
        with open(sym_file) as f:
            self.sym_data = json.load(f)
        
        # Build lookup tables
        self.pc_to_source = {}
        self.line_to_pc = {}
        
        for inst in self.sym_data.get('instructions', []):
            pc = inst['pc']
            file = inst.get('file')
            line = inst.get('line')
            
            if file and line:
                self.pc_to_source[pc] = {'file': file, 'line': line}
                self.line_to_pc.setdefault((file, line), []).append(pc)
    
    def resolve_line_to_addr(self, file: str, line: int) -> Optional[int]:
        """Find instruction address for source file:line."""
        addrs = self.line_to_pc.get((file, line))
        return addrs[0] if addrs else None
    
    def lookup_source_from_pc(self, pc: int) -> Optional[Dict[str, Any]]:
        """Find source location for PC."""
        return self.pc_to_source.get(pc)


def main():
    """Entry point for debug adapter."""
    logging.basicConfig(
        level=logging.DEBUG,
        format='%(asctime)s [%(levelname)s] %(message)s',
        handlers=[logging.FileHandler('/tmp/hsx-dap.log')]
    )
    
    adapter = HSXDebugAdapter()
    # Run adapter with appropriate DAP library
    # Example with debugpy or custom stdio-based protocol
    asyncio.run(adapter.run())


if __name__ == '__main__':
    main()
```

## 6. VS Code Extension

### 6.1 Extension Structure

**Directory Layout:**
```
vscode-hsx/
├── package.json              # Extension manifest
├── src/
│   └── extension.ts         # Extension activation code
├── debugAdapter/
│   └── hsx-dap.py           # Debug adapter implementation
├── .vscodeignore
├── README.md
└── CHANGELOG.md
```

### 6.2 Extension Manifest

**package.json:**
```json
{
  "name": "hsx-debug",
  "displayName": "HSX Debugger",
  "description": "Debug HSX applications with source-level stepping",
  "version": "0.1.0",
  "publisher": "hsx",
  "categories": ["Debuggers"],
  "keywords": ["hsx", "debugger", "embedded"],
  "engines": {
    "vscode": "^1.70.0"
  },
  "activationEvents": [
    "onDebug:hsx"
  ],
  "main": "./out/extension.js",
  "contributes": {
    "debuggers": [
      {
        "type": "hsx",
        "label": "HSX Debugger",
        "program": "./debugAdapter/hsx-dap.py",
        "runtime": "python3",
        "languages": ["c", "cpp"],
        "configurationAttributes": {
          "launch": {
            "required": ["program"],
            "properties": {
              "program": {
                "type": "string",
                "description": "Path to HSX executable (.hxe)",
                "default": "${workspaceFolder}/build/app.hxe"
              },
              "host": {
                "type": "string",
                "description": "HSX executive hostname",
                "default": "localhost"
              },
              "port": {
                "type": "number",
                "description": "HSX executive port",
                "default": 9998
              },
              "stopOnEntry": {
                "type": "boolean",
                "description": "Stop at program entry point",
                "default": true
              },
              "trace": {
                "type": "boolean",
                "description": "Enable debug adapter protocol tracing",
                "default": false
              }
            }
          },
          "attach": {
            "required": ["pid"],
            "properties": {
              "pid": {
                "type": "number",
                "description": "Process ID to attach to"
              },
              "host": {
                "type": "string",
                "description": "HSX executive hostname",
                "default": "localhost"
              },
              "port": {
                "type": "number",
                "description": "HSX executive port",
                "default": 9998
              }
            }
          }
        },
        "initialConfigurations": [
          {
            "type": "hsx",
            "request": "launch",
            "name": "Debug HSX Application",
            "program": "${workspaceFolder}/build/app.hxe",
            "host": "localhost",
            "port": 9998,
            "stopOnEntry": true
          }
        ],
        "configurationSnippets": [
          {
            "label": "HSX: Launch",
            "description": "Launch HSX application with debugger",
            "body": {
              "type": "hsx",
              "request": "launch",
              "name": "Debug HSX App",
              "program": "^\"\\${workspaceFolder}/build/app.hxe\"",
              "stopOnEntry": true
            }
          }
        ]
      }
    ],
    "breakpoints": [
      {
        "language": "c"
      },
      {
        "language": "cpp"
      }
    ]
  },
  "scripts": {
    "vscode:prepublish": "npm run compile",
    "compile": "tsc -p ./",
    "watch": "tsc -watch -p ./",
    "package": "vsce package"
  },
  "devDependencies": {
    "@types/node": "^18.0.0",
    "@types/vscode": "^1.70.0",
    "typescript": "^4.9.0",
    "vsce": "^2.15.0"
  }
}
```

### 6.3 Extension Activation

**src/extension.ts:**
```typescript
import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
    console.log('HSX debugger extension activated');
    
    // Register debug configuration provider
    const provider = new HSXDebugConfigurationProvider();
    context.subscriptions.push(
        vscode.debug.registerDebugConfigurationProvider('hsx', provider)
    );
}

export function deactivate() {
    console.log('HSX debugger extension deactivated');
}

class HSXDebugConfigurationProvider implements vscode.DebugConfigurationProvider {
    resolveDebugConfiguration(
        folder: vscode.WorkspaceFolder | undefined,
        config: vscode.DebugConfiguration,
        token?: vscode.CancellationToken
    ): vscode.ProviderResult<vscode.DebugConfiguration> {
        
        // If no configuration provided, return default
        if (!config.type && !config.request && !config.name) {
            const editor = vscode.window.activeTextEditor;
            if (editor && (editor.document.languageId === 'c' || editor.document.languageId === 'cpp')) {
                config.type = 'hsx';
                config.name = 'Launch HSX';
                config.request = 'launch';
                config.program = '${workspaceFolder}/build/app.hxe';
                config.stopOnEntry = true;
            }
        }
        
        // Validate required fields
        if (!config.program) {
            return vscode.window.showErrorMessage(
                'Cannot find HSX executable to debug'
            ).then(_ => undefined);
        }
        
        return config;
    }
}
```

## 7. Usage Workflow

### 7.1 Setup

1. Install HSX VS Code extension from marketplace or .vsix file
2. Open HSX project workspace in VS Code
3. Ensure .sym files are generated during build (toolchain flag)
4. Start HSX manager and executive: `python hsx_manager.py`

### 7.2 Debug Session

1. Open C source file in editor
2. Set breakpoints by clicking in editor gutter
3. Press F5 or select "Run > Start Debugging"
4. VS Code launches debug adapter, which connects to executive
5. Program loads and stops at entry point (if configured)
6. Use debug controls:
   - **F5 / Continue**: Run until next breakpoint
   - **F10 / Step Over**: Execute current line, step over function calls
   - **F11 / Step Into**: Step into function calls
   - **Shift+F11 / Step Out**: Return from current function
   - **Ctrl+Shift+F5 / Restart**: Restart debug session
   - **Shift+F5 / Stop**: End debug session

### 7.3 Launch Configuration

Create `.vscode/launch.json`:
```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "hsx",
      "request": "launch",
      "name": "Debug Producer",
      "program": "${workspaceFolder}/examples/demos/build/mailbox/producer.hxe",
      "host": "localhost",
      "port": 9998,
      "stopOnEntry": true
    },
    {
      "type": "hsx",
      "request": "launch",
      "name": "Debug Consumer",
      "program": "${workspaceFolder}/examples/demos/build/mailbox/consumer.hxe",
      "host": "localhost",
      "port": 9998,
      "stopOnEntry": false
    }
  ]
}
```

## 8. Implementation Phases

### 8.1 Phase 1: Minimal Viable Adapter (1-2 weeks)
- Basic DAP request handling (initialize, launch, disconnect)
- Breakpoint set/clear in source files
- Continue and single-step operations
- Stack trace display
- Basic register inspection

**Deliverables:**
- Functional debug adapter with core DAP support
- VS Code extension with launch configuration
- Documentation for setup and usage

### 8.2 Phase 2: Enhanced Features (2-3 weeks)
- Source-level stepping (step over/into/out)
- Variable inspection and watch expressions
- Hover evaluation for registers and symbols
- Memory inspection requests
- Event streaming for stdout/stderr

**Deliverables:**
- Full debugging experience comparable to native debuggers
- Integration tests for DAP protocol
- User guide with examples

### 8.3 Phase 3: Advanced Features (3-4 weeks)
- Attach to running process
- Multi-threaded debugging (multiple PIDs)
- Conditional breakpoints
- Data breakpoints / watchpoints
- Expression evaluation engine

**Deliverables:**
- Advanced debugging capabilities
- Performance optimization
- Extension marketplace publication

## 9. Dependencies and Requirements

### 9.1 Python Dependencies
```
# requirements-dap.txt
debugpy>=1.8.0           # Microsoft DAP implementation
aiofiles>=23.0.0         # Async file I/O for symbol loading
```

### 9.2 Symbol File Requirements
- Complete line mapping for all source files
- Function symbol information for stack traces
- Variable metadata for local inspection (future)

### 9.3 Executive Protocol Requirements
- All debugger RPCs from [04.09--Debugger.md](04.09--Debugger.md) Section 5
- Event streaming support
- Symbol resolution APIs

## 10. Testing Strategy

### 10.1 Unit Tests
- Symbol loader: Line-to-address and address-to-line resolution
- DAP message serialization/deserialization
- Executive client request/response handling

### 10.2 Integration Tests
- Complete debug session lifecycle (launch → step → breakpoint → disconnect)
- Breakpoint hit detection and notification
- Stack trace accuracy with source mapping
- Event forwarding (stdout/stderr)

### 10.3 Manual Testing
- VS Code debugging workflows on different platforms
- Multi-file projects with various source layouts
- Error handling (missing .sym, executive connection failure)

## 11. Alternatives Considered

### 11.1 Language Server Protocol (LSP)
**Purpose:** Code intelligence without debugging
- Syntax highlighting
- Go to definition (using .sym files)
- Hover information
- Code completion

**Effort:** Lower than DAP, provides value independently
**Decision:** Consider as separate future enhancement

### 11.2 GDB Remote Serial Protocol
**Purpose:** Reuse existing GDB-based tooling
- Implement GDB RSP server in executive
- Use existing GDB frontends (VS Code C++ extension, etc.)

**Pros:** Leverage mature ecosystem
**Cons:** Protocol more complex, less control over UX
**Decision:** DAP provides better IDE integration and control

## 12. Traceability
- **Design Requirements:** DR-3.1, DR-8.1.
- **Design Goals:** DG-8.1, DG-8.3.
- **Design Options:** DO-dap-vs-gdb (DAP selected for better IDE integration).
