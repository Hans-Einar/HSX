# Design Spec - Value & Command Layer
# 04.04--ValCmd Design (v3, repo style)
**Status:** DRAFT | **Date:** 2025-10-28 | **Owner:** HSX Core

> **Design stance:** The value and command layer is an executive-owned service providing dynamic parameter management and control dispatch. It performs no autonomous persistence, handles no direct transport encoding, and coordinates with the mailbox and persistence subsystems for notification and storage.

**Authoritative context (repo-local):**
- Architecture: [03.04--ValCmd](../03--Architecture/03.04--ValCmd.md), [03.00--Architecture](../03--Architecture/03.00--Architecture.md)
- Study & Requirements: [02--Study](../02--Study/02--Study.md), [02.01--Requirements](../02--Study/02.01--Requirements.md)
- Implementation-phase specs (normative inputs referenced by design):
  [docs/abi_syscalls.md](../../docs/abi_syscalls.md), [docs/resource_budgets.md](../../docs/resource_budgets.md),
  [include/hsx_value.h](../../include/hsx_value.h), [include/hsx_command.h](../../include/hsx_command.h)

**Traceability (fill from 02.01--Requirements):** Refs DR[..], DG[..], DO[..].

## 1. Scope
- Executive-owned value and command registry providing runtime parameter management and control dispatch (DR-7.1, DG-7.1).
- Support for registration, lookup, get/set operations, command invocation, subscriptions, and persistence policies (DR-7.1, DR-7.3, DG-7.1–7.3).
- Transport bindings for mailbox notifications and CAN/UART framing without embedding transport logic (DR-7.1, DG-7.3).
- Integration with FRAM persistence layer for calibration and state retention (DR-5.3, DG-7.3).
- CLI/TUI enumeration and manipulation with change notification through event stream (DR-8.1, DG-8.1, DG-8.2).

## 2. Preconditions
- Executive provides mailbox/event infrastructure ([04.03--Mailbox.md](04.03--Mailbox.md)), persistence services, and session APIs required for value/watch interaction (DR-6.1, DR-7.1, DR-5.3, DG-6.1, DG-7.3).
- MiniVM SVC dispatcher routes module 0x07 (VALUE) and module 0x08 (COMMAND) traps to executive handlers per architecture specification (DR-7.1, DG-7.2).
- Toolchain and application code define value/command descriptors with metadata (group ID, value ID, names, units, ranges) aligning with runtime expectations (DR-3.1, DG-7.1).
- FRAM/persistence layer available for storing calibration values per `docs/resource_budgets.md` allocation (DR-5.3, DG-7.3).

## 3. Postconditions
- Value/command registry fully supports registration, lookup, get/set operations, command invocation, subscriptions, and persistence as specified (DR-7.1, DR-7.3, DG-7.1–7.3).
- CLI/TUI tooling can enumerate, manipulate values/commands, and receive change notifications through structured event stream (DR-8.1, DG-8.1, DG-8.2).
- Persistence and transport bindings (UART, CAN, mailbox) integrate seamlessly with executive APIs without duplicating transport logic (DR-5.3, DG-7.3).
- Applications and firmware can reliably use values/commands without behavioral drift between Python reference and C port implementations (DR-1.3, DG-1.4).

## 4. Architectural Overview

### 4.1 Design Principles
- **Executive-driven model:** Value and command subsystems own no scheduler; all change propagation, persistence writes, and notifications are orchestrated by the executive.
- **Deterministic addressing:** Values and commands use `(group_id, value_id)` tuples forming unique OIDs; lookup is O(1) via array indexing or hash map for sparse deployments.
- **Resource bounded:** Registry sizes, string table capacity, and persistence key space are statically configured per `docs/resource_budgets.md`.
- **Compact storage:** Value entries use 8-byte records optimized for embedded targets; optional descriptors provide rich metadata for tooling.
- **Transport agnostic:** Core registry logic delegates notifications to mailbox subsystem and persistence to FRAM layer.

### 4.2 Data Structures

#### 4.2.1 Value Entry (`hsx_val_entry`)
Compact 8-byte record for runtime storage.

| Field | Type | Bits/Size | Description |
|-------|------|-----------|-------------|
| `group_id` | uint8 | 8 | Group identifier (0-255). |
| `value_id` | uint8 | 8 | Value identifier within group (0-255). |
| `flags` | bitfield | 8 | RO, Persist, Sticky, Pin, Bool flags. |
| `auth_level` | uint8 | 8 | Authorization level (0=public, 1-255=restricted). |
| `last_f16` | f16 | 16 | Last published value (IEEE 754 half-precision). |
| `desc_head` | ptr | 16 | Pointer to first descriptor in linked list; NULL if none. |

OID (Object ID) = `(group_id << 8) | value_id` provides unique 16-bit identifier.

#### 4.2.2 Group Descriptor (`hsx_group_desc`)
Shared descriptor for group metadata. Multiple values and commands can reference the same group descriptor.

| Field | Type | Description |
|-------|------|-------------|
| `desc_type` | uint8 | Descriptor type tag (0x01 = GROUP). |
| `group_id` | uint8 | Group identifier this descriptor describes. |
| `group_name` | string ptr | Null-terminated group name. |
| `next` | ptr | Pointer to next descriptor in chain; NULL if end. |

Group descriptors are deduplicated: all values/commands sharing the same `group_id` reference the same group descriptor instance.

#### 4.2.3 Value Descriptor Types (Mix-in Pattern)
Values can have zero or more descriptors chained via `next` pointers, allowing flexible composition of metadata.

##### 4.2.3.1 Name Descriptor (`hsx_name_desc`)
Provides human-readable name for the value.

| Field | Type | Description |
|-------|------|-------------|
| `desc_type` | uint8 | Descriptor type tag (0x02 = NAME). |
| `reserved` | uint8 | Reserved for alignment. |
| `value_name` | string ptr | Null-terminated value name. |
| `next` | ptr | Pointer to next descriptor in chain; NULL if end. |

##### 4.2.3.2 Unit Descriptor (`hsx_unit_desc`)
Provides unit information and display formatting.

| Field | Type | Description |
|-------|------|-------------|
| `desc_type` | uint8 | Descriptor type tag (0x03 = UNIT). |
| `reserved` | uint8 | Reserved for alignment. |
| `unit` | uint32 | Packed 4-character unit code (e.g., 'degC', 'km/h'). |
| `epsilon` | f16 | Minimum change threshold for notifications. |
| `rate_ms` | uint16 | Minimum milliseconds between notifications. |
| `next` | ptr | Pointer to next descriptor in chain; NULL if end. |

##### 4.2.3.3 Range Descriptor (`hsx_range_desc`)
Provides validation and display range information.

| Field | Type | Description |
|-------|------|-------------|
| `desc_type` | uint8 | Descriptor type tag (0x04 = RANGE). |
| `reserved` | uint8 | Reserved for alignment. |
| `min_val` | f16 | Range minimum (for validation/display). |
| `max_val` | f16 | Range maximum. |
| `next` | ptr | Pointer to next descriptor in chain; NULL if end. |

##### 4.2.3.4 Persistent Descriptor (`hsx_persist_desc`)
Provides persistence configuration.

| Field | Type | Description |
|-------|------|-------------|
| `desc_type` | uint8 | Descriptor type tag (0x05 = PERSIST). |
| `reserved` | uint8 | Reserved for alignment. |
| `persist_key` | uint16 | FRAM address or key identifier; 0 if not persisted. |
| `debounce_ms` | uint16 | Debounce delay before writing to FRAM. |
| `next` | ptr | Pointer to next descriptor in chain; NULL if end. |

**Descriptor Chain Example:**
A value with name, unit, and range descriptors would have:
```
value_entry.desc_head -> name_desc -> unit_desc -> range_desc -> NULL
```

Descriptors are optional; omit to save RAM on constrained targets. New descriptor types can be added without breaking existing code by checking `desc_type` and following the `next` pointer chain.

#### 4.2.4 Command Entry (`hsx_cmd_entry`)
Similar compact structure for commands.

| Field | Type | Size | Description |
|-------|------|------|-------------|
| `group_id` | uint8 | 8 | Group identifier. |
| `value_id` | uint8 | 8 | Command identifier within group. |
| `flags` | bitfield | 8 | Pin flag (requires auth token). |
| `auth_level` | uint8 | 8 | Authorization level. |
| `reserved` | uint16 | 16 | Reserved for future arguments/return types. |
| `desc_head` | ptr | 16 | Pointer to first descriptor in linked list; NULL if none. |

#### 4.2.5 Command Descriptor Types
Commands can also use the mix-in descriptor pattern for flexible metadata.

##### 4.2.5.1 Command Name Descriptor (`hsx_cmd_name_desc`)
Provides human-readable name and help text for the command.

| Field | Type | Description |
|-------|------|-------------|
| `desc_type` | uint8 | Descriptor type tag (0x10 = CMD_NAME). |
| `reserved` | uint8 | Reserved for alignment. |
| `cmd_name` | string ptr | Command name. |
| `help` | string ptr | Help text for CLI display. |
| `next` | ptr | Pointer to next descriptor in chain; NULL if end. |

Commands share the same **Group Descriptor** (section 4.2.2) as values, enabling unified group naming across both values and commands in the same group.

#### 4.2.6 String Tables
Deduplicated null-terminated strings referenced by descriptors. Shared across all values and commands to minimize memory footprint.

### 4.3 Registry Model
- **Value table:** Fixed-size array indexed by OID or hash map for sparse deployments.
- **Command table:** Separate fixed-size array with similar indexing strategy.
- **Lookup complexity:** O(1) for dense OID space; O(log N) or O(N) for sparse deployments with hash/linear search.
- **Capacity:** Configured per platform in `docs/resource_budgets.md` (e.g., embedded: 64 values, 16 commands; desktop: 256+ values).

### 4.4 Operational Behavior

#### 4.4.1 Registration (VALUE_REGISTER, CMD_REGISTER)
1. Allocate slot from fixed-size table; return error if table full.
2. Create OID = `(group_id << 8) | value_id`.
3. Store compact entry (flags, auth_level, initial value for values).
4. Optionally build descriptor chain:
   - Check if group descriptor exists for `group_id`; create and deduplicate if needed.
   - Allocate and link additional descriptors (name, unit, range, persist) as provided.
   - Set `desc_head` to point to first descriptor in chain.
   - Each descriptor's `next` pointer links to the subsequent descriptor, ending with NULL.
5. Copy descriptor strings into shared string table (deduplicated).
6. Assign persist key in persistent descriptor if provided; auto-allocate from FRAM pool if Persist flag set.
7. Emit `value_registered` or `cmd_registered` event for tooling.

#### 4.4.2 Lookup (VALUE_LOOKUP, CMD_LOOKUP)
- O(1) array index by OID for dense deployments.
- Hash map or linear search fallback for sparse OID space.
- Return entry pointer or error if OID not found.

#### 4.4.3 Get/Set (VALUE_GET, VALUE_SET)
1. **GET:** Read `last_f16` from entry; enforce auth_level if restricted; return value.
2. **SET:**
   - Enforce auth_level and check RO flag; return `EPERM` if unauthorized or read-only.
   - Compare new f16 against `last_f16` using epsilon threshold.
   - Check rate_limit (rate_ms); skip notification if within suppression window.
   - Update `last_f16` if changed beyond epsilon.
   - If Persist flag set, schedule debounced FRAM write to avoid wear.
   - Enqueue mailbox notification `(oid, f16)` to subscribers.
   - Optionally enqueue CAN publish frame.
   - Emit `value_changed` event.

#### 4.4.4 Subscription (VALUE_SUB)
- Store mailbox handle in subscription list for given OID or group.
- Executive delivers `(oid, f16)` frames on value changes respecting rate_limit.
- Subscriber receives notifications via mailbox receive operations.

#### 4.4.5 Persistence (VALUE_PERSIST)
- Toggle Persist flag on/off for given OID.
- On system boot: load persisted values from FRAM using persist_key.
- On value update: schedule debounced write to FRAM (e.g., 100ms delay, coalesced).
- Handle FRAM read failures by flagging value as STALE; notify watchers.

#### 4.4.6 Command Invocation (CMD_CALL)
1. Verify auth token if command has Pin flag set; return `EPERM` if unauthorized.
2. Synchronous mode: execute handler function, return errno directly.
3. Asynchronous mode: post `(oid, rc)` result to caller's mailbox.
4. Commands do not carry arguments in v1 (button semantics); future extensions may add argument payloads.
5. Emit `cmd_invoked` and `cmd_completed` events.

#### 4.4.7 CAN Binding
- Map OID to CAN payload (2-byte OID) with op-coded frames:
  - `GET`: request value
  - `SET`: publish new value
  - `PUB`: broadcast value change
  - `CALL`: invoke command
  - `RET`: command result
- Optional sequence number and errno bytes for reliability.
- No argument payload beyond metadata in v1.

#### 4.4.8 Shell/CLI Integration
- Support numeric addressing: `group:value` (e.g., `1:5`).
- Support named lookups via descriptor tables: `motor:speed`.
- Parse float strings into f16 for SET operations.
- Display units, ranges, and help text from descriptors.

## 5. External Interfaces

### 5.1 SVC API (Modules 0x07 VALUE, 0x08 COMMAND)

> Authoritative definitions live in [abi_syscalls.md](../../docs/abi_syscalls.md) and [include/hsx_value.h](../../include/hsx_value.h).

| Fn | Module | Name | Arguments (`R0..R3`) | Return (`R0..R1`) | Errors | Notes |
|----|--------|------|----------------------|-------------------|--------|-------|
| 0x00 | 0x07 | `VALUE_REGISTER` | `R0=group_id`, `R1=value_id`, `R2=flags`, `R3=desc_ptr` | `R0=status`, `R1=oid` | `ENOSPC`, `EEXIST` | Register new value; desc_ptr optional. |
| 0x01 | 0x07 | `VALUE_LOOKUP` | `R0=oid` or `R0=group_id`, `R1=value_id` | `R0=status`, `R1=entry_ptr` | `ENOENT` | Lookup by OID or group:value. |
| 0x02 | 0x07 | `VALUE_GET` | `R0=oid` | `R0=status`, `R1=f16_value` | `ENOENT`, `EPERM` | Read current value. |
| 0x03 | 0x07 | `VALUE_SET` | `R0=oid`, `R1=f16_value` | `R0=status` | `ENOENT`, `EPERM`, `EROFS` | Write value; triggers notifications. |
| 0x04 | 0x07 | `VALUE_SUB` | `R0=oid`, `R1=mbx_handle` | `R0=status` | `ENOENT`, `EINVAL` | Subscribe to value changes. |
| 0x05 | 0x07 | `VALUE_PERSIST` | `R0=oid`, `R1=enable` | `R0=status` | `ENOENT`, `ENOSPC` | Toggle persistence for value. |
| 0x00 | 0x08 | `CMD_REGISTER` | `R0=group_id`, `R1=cmd_id`, `R2=flags`, `R3=desc_ptr` | `R0=status`, `R1=oid` | `ENOSPC`, `EEXIST` | Register command. |
| 0x01 | 0x08 | `CMD_LOOKUP` | `R0=oid` or `R0=group_id`, `R1=cmd_id` | `R0=status`, `R1=entry_ptr` | `ENOENT` | Lookup command. |
| 0x02 | 0x08 | `CMD_CALL` | `R0=oid`, `R1=flags` | `R0=status`, `R1=rc` | `ENOENT`, `EPERM` | Invoke command; async if flagged. |

### 5.2 Executive Integration
- **Notification dispatch:** Value changes trigger mailbox sends to subscribers via executive mailbox manager.
- **Persistence coordination:** Executive schedules debounced FRAM writes and handles load-on-boot from persist_key mappings.
- **Event emission:** Value/command operations emit structured events (`value_changed`, `value_registered`, `cmd_invoked`) for tooling per `docs/executive_protocol.md`.

### 5.3 Instrumentation and Observability
- **RPC commands:** `val.list`, `val.get <oid>`, `val.set <oid> <value>`, `val.watch <oid>`, `cmd.list`, `cmd.call <oid>`.
- **Event stream:** Structured events enable debugger watch panels, change history, and audit logging.
- **Resource usage:** Executive tracks table occupancy, string table usage, and FRAM key allocation against budgets.

## 6. Edge Cases and Error Handling
- **Table capacity exhaustion:** Return `ENOSPC` to registering task; document recommended limits per platform in `docs/resource_budgets.md`.
- **Duplicate OID registration:** Return `EEXIST`; optionally allow re-registration with updated metadata.
- **Task restart:** Clear entries associated with terminated PID; optionally allow reuse of group:value IDs with existing string/persist metadata.
- **FRAM read failure:** Fall back to default value or last known value flagged as STALE; notify watchers via event stream.
- **Auth token mismatch:** Return `EPERM` for VALUE_SET or CMD_CALL with insufficient auth_level; log attempt for security diagnostics.
- **Epsilon/rate_limit edge cases:** Values that oscillate at epsilon boundary may produce notification storms; enforce rate_limit strictly.
- **CAN frame loss:** Accept out-of-order or duplicate frames gracefully; implement sequence numbers for reliability.
- **Future array/matrix support:** Implement via auxiliary descriptor pools without changing base 8-byte entry size; defer to design option DO-7.b.

## 7. Testing Strategy
- **Unit coverage:**
  - VALUE_REGISTER, VALUE_GET, VALUE_SET with all flag combinations (RO, Persist, Sticky, Pin, Bool).
  - CMD_REGISTER, CMD_CALL with sync/async modes and auth levels.
  - Epsilon threshold and rate_limit enforcement.
  - Subscription delivery and unsubscribe paths.
- **Persistence tests:**
  - FRAM write/load cycles with debounce validation.
  - Error paths: FRAM CRC failure, key exhaustion, wear counter overflow.
- **Transport validation:**
  - CAN round-trip: GET/SET/PUB/CALL/RET frame encoding/decoding.
  - UART shell flows: `val ls`, `val get`, `val set`, `val watch`, `cmd list`, `cmd call`.
- **Integration tests:**
  - Debugger watch panel updates driven by value change events.
  - Mailbox subscription delivery with multiple subscribers (fan-out mode).
  - Provisioning reload: restore persisted values after simulated power cycle.
- **Stress tests:**
  - High-rate value updates: verify rate_limit throttling.
  - Table exhaustion scenarios with graceful degradation.

## 8. Verification
- See [ValCmd_tests.md](../06--Test/system/ValCmd_tests.md) (if available).
- **Contract coverage:**
  - OID uniqueness and lookup determinism (O(1) for dense, graceful for sparse).
  - Auth_level enforcement for restricted values/commands.
  - Epsilon/rate_limit behavior: no spurious notifications, no missed changes outside thresholds.
  - Persistence correctness: values restored after boot match last persisted state.
- **Behavioral coverage:**
  - Notification fan-out to multiple mailbox subscribers.
  - CAN framing compatibility with external tools.
  - CLI/shell usability: named lookups, numeric addressing, help text display.
- **Limits testing:**
  - Table capacity enforcement (values, commands, string table).
  - FRAM key space exhaustion handling.

## 9. Traceability
- **Design Requirements:** DR-1.3, DR-3.1, DR-5.3, DR-6.1, DR-7.1, DR-7.3, DR-8.1.
- **Design Goals:** DG-1.4, DG-6.1, DG-6.2, DG-7.1, DG-7.2, DG-7.3, DG-7.4, DG-8.1, DG-8.2.
- **Design Options:** DO-7.a (value/command extensions), DO-7.b (array/matrix support).


