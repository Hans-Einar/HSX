# Design Spec - Value & Command Layer
# 04.04--ValCmd Design (v3, repo style)
**Status:** DRAFT | **Date:** 2025-10-28 | **Owner:** HSX Core

> **Design stance:** The value and command layer is an executive-owned service providing dynamic parameter management and control dispatch. It performs no autonomous persistence, handles no direct transport encoding, and coordinates with the mailbox and persistence subsystems for notification and storage.

**Authoritative context (repo-local):**
- Architecture: [03.04--ValCmd](../03--Architecture/03.04--ValCmd.md), [03.00--Architecture](../03--Architecture/03.00--Architecture.md)
- Study & Requirements: [02--Study](../02--Study/02--Study.md), [02.01--Requirements](../02--Study/02.01--Requirements.md)
- Implementation-phase specs (normative inputs referenced by design):
  [docs/abi_syscalls.md](../../docs/abi_syscalls.md), [docs/resource_budgets.md](../../docs/resource_budgets.md),
  [include/hsx_value.h](../../include/hsx_value.h), [include/hsx_command.h](../../include/hsx_command.h)

**Traceability (fill from 02.01--Requirements):** Refs DR[..], DG[..], DO[..].

## 1. Scope
- Executive-owned value and command registry providing runtime parameter management and control dispatch (DR-7.1, DG-7.1).
- Support for registration, lookup, get/set operations, command invocation, subscriptions, and persistence policies (DR-7.1, DR-7.3, DG-7.1–7.3).
- Transport bindings for mailbox notifications and CAN/UART framing without embedding transport logic (DR-7.1, DG-7.3).
- Integration with FRAM persistence layer for calibration and state retention (DR-5.3, DG-7.3).
- CLI/TUI enumeration and manipulation with change notification through event stream (DR-8.1, DG-8.1, DG-8.2).

## 2. Preconditions
- Executive provides mailbox/event infrastructure ([04.03--Mailbox.md](04.03--Mailbox.md)), persistence services, and session APIs required for value/watch interaction (DR-6.1, DR-7.1, DR-5.3, DG-6.1, DG-7.3).
- MiniVM SVC dispatcher routes module 0x07 (VALUE) and module 0x08 (COMMAND) traps to executive handlers per architecture specification (DR-7.1, DG-7.2).
- Toolchain and application code define value/command descriptors with metadata (group ID, value ID, names, units, ranges) aligning with runtime expectations (DR-3.1, DG-7.1).
- FRAM/persistence layer available for storing calibration values per `docs/resource_budgets.md` allocation (DR-5.3, DG-7.3).

## 3. Postconditions
- Value/command registry fully supports registration, lookup, get/set operations, command invocation, subscriptions, and persistence as specified (DR-7.1, DR-7.3, DG-7.1–7.3).
- CLI/TUI tooling can enumerate, manipulate values/commands, and receive change notifications through structured event stream (DR-8.1, DG-8.1, DG-8.2).
- Persistence and transport bindings (UART, CAN, mailbox) integrate seamlessly with executive APIs without duplicating transport logic (DR-5.3, DG-7.3).
- Applications and firmware can reliably use values/commands without behavioral drift between Python reference and C port implementations (DR-1.3, DG-1.4).

## 4. Architectural Overview

### 4.1 Design Principles
- **Executive-driven model:** Value and command subsystems own no scheduler; all change propagation, persistence writes, and notifications are orchestrated by the executive.
- **Centralized storage:** All value/command registry data structures (entries, descriptors, string tables) are allocated in executive heap space, not in HXE application memory. This enables the executive to directly handle CAN/serial protocol requests without VM involvement, providing fast and deterministic response times.
- **Transparent HXE access:** HXE applications access values through operator-overloaded `Value` structs in C code. Read/write operations transparently invoke SVC calls (VALUE_GET/VALUE_SET) to interact with the executive-owned registry. This provides a single point of storage while maintaining clean application code.
- **Deterministic addressing:** Values and commands use `(group_id, value_id)` tuples forming unique OIDs; lookup is O(1) via array indexing or hash map for sparse deployments.
- **Resource bounded:** Registry sizes, string table capacity, and persistence key space are statically configured per `docs/resource_budgets.md`.
- **Compact storage:** Value entries use 8-byte records optimized for embedded targets; optional descriptors provide rich metadata for tooling.
- **Transport agnostic:** Core registry logic delegates notifications to mailbox subsystem and persistence to FRAM layer.

### 4.2 Data Structures

#### 4.2.1 Value Entry (`hsx_val_entry`)
Compact 8-byte record for runtime storage.

| Field | Type | Bits/Size | Description |
|-------|------|-----------|-------------|
| `group_id` | uint8 | 8 | Group identifier (0-255). |
| `value_id` | uint8 | 8 | Value identifier within group (0-255). |
| `flags` | bitfield | 8 | RO, Persist, Sticky, Pin, Bool flags. |
| `auth_level` | uint8 | 8 | Authorization level (0=public, 1-255=restricted). |
| `owner_pid` | uint16 | 16 | Process ID of the HXE app that created this value. |
| `last_f16` | f16 | 16 | Last published value (IEEE 754 half-precision). |
| `desc_head` | ptr | 16 | Pointer to first descriptor in linked list; NULL if none. |

OID (Object ID) = `(group_id << 8) | value_id` provides unique 16-bit identifier. Access is restricted to the owning PID; IPC between HXE apps must use mailboxes.

#### 4.2.2 Group Descriptor (`hsx_group_desc`)
Shared descriptor for group metadata. Multiple values and commands can reference the same group descriptor.

| Field | Type | Description |
|-------|------|-------------|
| `desc_type` | uint8 | Descriptor type tag (0x01 = GROUP). |
| `group_id` | uint8 | Group identifier this descriptor describes. |
| `group_name` | string ptr | Null-terminated group name. |
| `next` | ptr | Pointer to next descriptor in chain; NULL if end. |

Group descriptors are deduplicated: all values/commands sharing the same `group_id` reference the same group descriptor instance.

#### 4.2.3 Value Descriptor Types (Mix-in Pattern)
Values can have zero or more descriptors chained via `next` pointers, allowing flexible composition of metadata.

##### 4.2.3.1 Name Descriptor (`hsx_name_desc`)
Provides human-readable name for the value.

| Field | Type | Description |
|-------|------|-------------|
| `desc_type` | uint8 | Descriptor type tag (0x02 = NAME). |
| `reserved` | uint8 | Reserved for alignment. |
| `value_name` | string ptr | Null-terminated value name. |
| `next` | ptr | Pointer to next descriptor in chain; NULL if end. |

##### 4.2.3.2 Unit Descriptor (`hsx_unit_desc`)
Provides unit information and display formatting.

| Field | Type | Description |
|-------|------|-------------|
| `desc_type` | uint8 | Descriptor type tag (0x03 = UNIT). |
| `reserved` | uint8 | Reserved for alignment. |
| `unit` | uint32 | Packed 4-character unit code (e.g., 'degC', 'km/h'). |
| `epsilon` | f16 | Minimum change threshold for notifications. |
| `rate_ms` | uint16 | Minimum milliseconds between notifications. |
| `next` | ptr | Pointer to next descriptor in chain; NULL if end. |

##### 4.2.3.3 Range Descriptor (`hsx_range_desc`)
Provides validation and display range information.

| Field | Type | Description |
|-------|------|-------------|
| `desc_type` | uint8 | Descriptor type tag (0x04 = RANGE). |
| `reserved` | uint8 | Reserved for alignment. |
| `min_val` | f16 | Range minimum (for validation/display). |
| `max_val` | f16 | Range maximum. |
| `next` | ptr | Pointer to next descriptor in chain; NULL if end. |

##### 4.2.3.4 Persistent Descriptor (`hsx_persist_desc`)
Provides persistence configuration.

| Field | Type | Description |
|-------|------|-------------|
| `desc_type` | uint8 | Descriptor type tag (0x05 = PERSIST). |
| `reserved` | uint8 | Reserved for alignment. |
| `persist_key` | uint16 | FRAM address or key identifier; 0 if not persisted. |
| `debounce_ms` | uint16 | Debounce delay before writing to FRAM. |
| `next` | ptr | Pointer to next descriptor in chain; NULL if end. |

**Descriptor Chain Example:**
A value with name, unit, and range descriptors would have:
```
value_entry.desc_head -> name_desc -> unit_desc -> range_desc -> NULL
```

Descriptors are optional; omit to save RAM on constrained targets. New descriptor types can be added without breaking existing code by checking `desc_type` and following the `next` pointer chain.

#### 4.2.4 Command Entry (`hsx_cmd_entry`)
Similar compact structure for commands.

| Field | Type | Size | Description |
|-------|------|------|-------------|
| `group_id` | uint8 | 8 | Group identifier. |
| `value_id` | uint8 | 8 | Command identifier within group. |
| `flags` | bitfield | 8 | Pin flag (requires auth token). |
| `auth_level` | uint8 | 8 | Authorization level. |
| `owner_pid` | uint16 | 16 | Process ID of the HXE app that created this command. |
| `desc_head` | ptr | 16 | Pointer to first descriptor in linked list; NULL if none. |

#### 4.2.5 Command Descriptor Types
Commands can also use the mix-in descriptor pattern for flexible metadata.

##### 4.2.5.1 Command Name Descriptor (`hsx_cmd_name_desc`)
Provides human-readable name and help text for the command.

| Field | Type | Description |
|-------|------|-------------|
| `desc_type` | uint8 | Descriptor type tag (0x10 = CMD_NAME). |
| `reserved` | uint8 | Reserved for alignment. |
| `cmd_name` | string ptr | Command name. |
| `help` | string ptr | Help text for CLI display. |
| `next` | ptr | Pointer to next descriptor in chain; NULL if end. |

Commands share the same **Group Descriptor** (section 4.2.2) as values, enabling unified group naming across both values and commands in the same group.

#### 4.2.6 String Tables
Deduplicated null-terminated strings referenced by descriptors. Shared across all values and commands to minimize memory footprint.

### 4.3 Registry Model
- **Value table:** Fixed-size array indexed by OID or hash map for sparse deployments.
- **Command table:** Separate fixed-size array with similar indexing strategy.
- **Lookup complexity:** O(1) for dense OID space; O(log N) or O(N) for sparse deployments with hash/linear search.
- **Capacity:** Configured per platform in `docs/resource_budgets.md` (e.g., embedded: 64 values, 16 commands; desktop: 256+ values).

### 4.4 Operational Behavior

#### 4.4.1 Registration (VALUE_REGISTER, CMD_REGISTER)
1. Allocate slot from fixed-size table; return error if table full.
2. Create OID = `(group_id << 8) | value_id`.
3. Capture calling task's PID from executive context and store in `owner_pid` field.
4. Store compact entry (flags, auth_level, owner_pid, initial value for values).
5. Optionally build descriptor chain:
   - Check if group descriptor exists for `group_id`; create and deduplicate if needed.
   - Allocate and link additional descriptors (name, unit, range, persist) as provided.
   - Set `desc_head` to point to first descriptor in chain.
   - Each descriptor's `next` pointer links to the subsequent descriptor, ending with NULL.
6. Copy descriptor strings into shared string table (deduplicated).
7. Assign persist key in persistent descriptor if provided; auto-allocate from FRAM pool if Persist flag set.
8. Emit `value_registered` or `cmd_registered` event for tooling.

#### 4.4.2 Get/Set (VALUE_GET, VALUE_SET)
1. **GET:** 
   - Verify calling task's PID matches `owner_pid`; return `EPERM` if not owned by caller.
   - Read `last_f16` from entry; enforce auth_level if restricted; return value.
2. **SET:**
   - Verify calling task's PID matches `owner_pid`; return `EPERM` if not owned by caller.
   - Enforce auth_level and check RO flag; return `EPERM` if unauthorized or read-only.
   - Compare new f16 against `last_f16` using epsilon threshold.
   - Check rate_limit (rate_ms); skip notification if within suppression window.
   - Update `last_f16` if changed beyond epsilon.
   - If Persist flag set, schedule debounced FRAM write to avoid wear.
   - Enqueue mailbox notification `(oid, f16)` to subscribers.
   - Optionally enqueue CAN publish frame.
   - Emit `value_changed` event.

**PID-based isolation:** Each HXE application can only access values/commands it owns. Inter-process communication between HXE apps must use mailboxes, not direct value access.

#### 4.4.3 Subscription (VALUE_SUB)
- Store mailbox handle in subscription list for given OID or group.
- Executive delivers `(oid, f16)` frames on value changes respecting rate_limit.
- Subscriber receives notifications via mailbox receive operations.

#### 4.4.4 Persistence (VALUE_PERSIST)
- Verify calling task's PID matches `owner_pid`; return `EPERM` if not owned by caller.
- Toggle Persist flag on/off for given OID.
- On system boot: load persisted values from FRAM using persist_key.
- On value update: schedule debounced write to FRAM (e.g., 100ms delay, coalesced).
- Handle FRAM read failures by flagging value as STALE; notify watchers.

#### 4.4.5 Command Invocation (CMD_CALL)
1. Verify calling task's PID matches `owner_pid`; return `EPERM` if not owned by caller.
2. Verify auth token if command has Pin flag set; return `EPERM` if unauthorized.
3. Synchronous mode: execute handler function, return errno directly.
4. Asynchronous mode: post `(oid, rc)` result to caller's mailbox.
5. Commands do not carry arguments in v1 (button semantics); future extensions may add argument payloads.
6. Emit `cmd_invoked` and `cmd_completed` events.

#### 4.4.6 CAN Binding
- Map OID to CAN payload (2-byte OID) with op-coded frames:
  - `GET`: request value
  - `SET`: publish new value
  - `PUB`: broadcast value change
  - `CALL`: invoke command
  - `RET`: command result
- Optional sequence number and errno bytes for reliability.
- No argument payload beyond metadata in v1.
- Executive handles CAN requests directly without PID checks (external access).

#### 4.4.7 Shell/CLI Integration
- Support numeric addressing: `group:value` (e.g., `1:5`).
- Support named lookups via descriptor tables: `motor:speed`.
- Parse float strings into f16 for SET operations.
- Display units, ranges, and help text from descriptors.
- Executive handles shell commands directly without PID checks (external access).

## 5. External Interfaces

### 5.1 SVC API (Modules 0x07 VALUE, 0x08 COMMAND)

> Authoritative definitions live in [abi_syscalls.md](../../docs/abi_syscalls.md) and [include/hsx_value.h](../../include/hsx_value.h).

| Fn | Module | Name | Arguments (`R0..R3`) | Return (`R0..R1`) | Errors | Notes |
|----|--------|------|----------------------|-------------------|--------|-------|
| 0x00 | 0x07 | `VALUE_REGISTER` | `R0=group_id`, `R1=value_id`, `R2=flags`, `R3=desc_ptr` | `R0=status`, `R1=oid` | `ENOSPC`, `EEXIST` | Register new value; captures caller PID; desc_ptr optional. |
| 0x01 | 0x07 | `VALUE_GET` | `R0=oid` | `R0=status`, `R1=f16_value` | `ENOENT`, `EPERM` | Read value owned by caller. |
| 0x02 | 0x07 | `VALUE_SET` | `R0=oid`, `R1=f16_value` | `R0=status` | `ENOENT`, `EPERM`, `EROFS` | Write value owned by caller; triggers notifications. |
| 0x03 | 0x07 | `VALUE_SUB` | `R0=oid`, `R1=mbx_handle` | `R0=status` | `ENOENT`, `EINVAL` | Subscribe to value changes. |
| 0x04 | 0x07 | `VALUE_PERSIST` | `R0=oid`, `R1=enable` | `R0=status` | `ENOENT`, `ENOSPC`, `EPERM` | Toggle persistence for value owned by caller. |
| 0x00 | 0x08 | `CMD_REGISTER` | `R0=group_id`, `R1=cmd_id`, `R2=flags`, `R3=desc_ptr` | `R0=status`, `R1=oid` | `ENOSPC`, `EEXIST` | Register command; captures caller PID. |
| 0x01 | 0x08 | `CMD_CALL` | `R0=oid`, `R1=flags` | `R0=status`, `R1=rc` | `ENOENT`, `EPERM` | Invoke command owned by caller; async if flagged. |

**PID-based access control:** All VALUE/COMMAND operations verify that the calling task's PID matches the `owner_pid` stored in the entry. HXE apps can only access their own values/commands. Inter-process communication must use mailboxes.

### 5.2 Executive Integration
- **Notification dispatch:** Value changes trigger mailbox sends to subscribers via executive mailbox manager.
- **Persistence coordination:** Executive schedules debounced FRAM writes and handles load-on-boot from persist_key mappings.
- **Event emission:** Value/command operations emit structured events (`value_changed`, `value_registered`, `cmd_invoked`) for tooling per `docs/executive_protocol.md`.

### 5.3 Instrumentation and Observability
- **RPC commands:** `val.list`, `val.get <oid>`, `val.set <oid> <value>`, `val.watch <oid>`, `cmd.list`, `cmd.call <oid>`.
- **Event stream:** Structured events enable debugger watch panels, change history, and audit logging.
- **Resource usage:** Executive tracks table occupancy, string table usage, and FRAM key allocation against budgets.

### 5.4 HXE Application Interface
HXE applications interact with the value/command system through operator-overloaded wrapper types that provide transparent access to executive-owned storage.

#### 5.4.1 Memory Allocation Model
- **Executive heap storage:** All registry data (value entries, command entries, descriptors, string tables) resides in the executive's heap, not in HXE application memory.
- **Benefits:**
  - Executive can respond to CAN/serial protocol requests directly without waking or querying the VM.
  - Fast, deterministic response times for external value queries.
  - Single source of truth for all parameter state.
  - Reduced memory footprint in HXE applications (only OID references needed).

#### 5.4.2 Operator Overload Pattern (C Interface)
HXE C code uses `Value` wrapper structs with operator overloads to provide transparent access:

```c
// Typical HXE application code
Value motor_speed;  // Internally stores OID, not actual value

// Read operation (transparent VALUE_GET SVC call)
f16 current_speed = motor_speed;  // operator f16() invokes SVC VALUE_GET

// Write operation (transparent VALUE_SET SVC call)
motor_speed = 1500.0f;  // operator=(f16) invokes SVC VALUE_SET
```

**Implementation details:**
- `Value` struct stores only the OID (2 bytes), not the actual value.
- Overloaded cast operators invoke `VALUE_GET` SVC for reads.
- Overloaded assignment operators invoke `VALUE_SET` SVC for writes.
- No direct memory access to value storage from HXE code.
- All access goes through executive's controlled interface.

#### 5.4.3 Direct Protocol Handling
Because values are executive-owned:
- **CAN requests:** Executive can immediately respond to CAN GET/SET frames without VM context switch.
- **Serial requests:** UART shell commands can read/write values without involving HXE application.
- **Subscriptions:** Mailbox notifications delivered directly from executive value change handlers.
- **Persistence:** FRAM writes occur in executive context, independent of HXE task scheduling.

This architecture separates data storage (executive-managed) from application logic (HXE tasks), enabling deterministic external interfaces while maintaining flexible application code.

## 6. Edge Cases and Error Handling
- **Table capacity exhaustion:** Return `ENOSPC` to registering task; document recommended limits per platform in `docs/resource_budgets.md`.
- **Duplicate OID registration:** Return `EEXIST`; optionally allow re-registration with updated metadata.
- **PID mismatch:** Return `EPERM` when task attempts to access value/command not owned by its PID. Inter-process access must use mailboxes.
- **Task restart:** Executive automatically clears entries associated with terminated PID; optionally allow reuse of group:value IDs with existing string/persist metadata.
- **FRAM read failure:** Fall back to default value or last known value flagged as STALE; notify watchers via event stream.
- **Auth token mismatch:** Return `EPERM` for VALUE_SET or CMD_CALL with insufficient auth_level; log attempt for security diagnostics.
- **Epsilon/rate_limit edge cases:** Values that oscillate at epsilon boundary may produce notification storms; enforce rate_limit strictly.
- **CAN frame loss:** Accept out-of-order or duplicate frames gracefully; implement sequence numbers for reliability.
- **External access (CAN/UART):** Executive handles external requests without PID checks, allowing monitoring and control from outside the VM.
- **Future array/matrix support:** Implement via auxiliary descriptor pools without changing base 8-byte entry size; defer to design option DO-7.b.

## 7. Testing Strategy
- **Unit coverage:**
  - VALUE_REGISTER, VALUE_GET, VALUE_SET with all flag combinations (RO, Persist, Sticky, Pin, Bool).
  - CMD_REGISTER, CMD_CALL with sync/async modes and auth levels.
  - PID-based access control: verify `EPERM` returned when task attempts to access another task's values/commands.
  - Epsilon threshold and rate_limit enforcement.
  - Subscription delivery and unsubscribe paths.
- **Persistence tests:**
  - FRAM write/load cycles with debounce validation.
  - Error paths: FRAM CRC failure, key exhaustion, wear counter overflow.
- **Transport validation:**
  - CAN round-trip: GET/SET/PUB/CALL/RET frame encoding/decoding.
  - UART shell flows: `val ls`, `val get`, `val set`, `val watch`, `cmd list`, `cmd call`.
- **Integration tests:**
  - Debugger watch panel updates driven by value change events.
  - Mailbox subscription delivery with multiple subscribers (fan-out mode).
  - Provisioning reload: restore persisted values after simulated power cycle.
- **Stress tests:**
  - High-rate value updates: verify rate_limit throttling.
  - Table exhaustion scenarios with graceful degradation.

## 8. Verification
- See [ValCmd_tests.md](../06--Test/system/ValCmd_tests.md) (if available).
- **Contract coverage:**
  - OID uniqueness and deterministic access within owner PID scope.
  - PID-based isolation: tasks can only access values/commands they created.
  - Auth_level enforcement for restricted values/commands.
  - Epsilon/rate_limit behavior: no spurious notifications, no missed changes outside thresholds.
  - Persistence correctness: values restored after boot match last persisted state.
- **Behavioral coverage:**
  - Notification fan-out to multiple mailbox subscribers.
  - Inter-process communication via mailboxes (not direct value access).
  - CAN framing compatibility with external tools.
  - CLI/shell usability: named lookups, numeric addressing, help text display.
- **Limits testing:**
  - Table capacity enforcement (values, commands, string table).
  - FRAM key space exhaustion handling.
  - PID cleanup on task termination.

## 9. Traceability
- **Design Requirements:** DR-1.3, DR-3.1, DR-5.3, DR-6.1, DR-7.1, DR-7.3, DR-8.1.
- **Design Goals:** DG-1.4, DG-6.1, DG-6.2, DG-7.1, DG-7.2, DG-7.3, DG-7.4, DG-8.1, DG-8.2.
- **Design Options:** DO-7.a (value/command extensions), DO-7.b (array/matrix support).


