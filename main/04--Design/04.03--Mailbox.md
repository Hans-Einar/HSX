# Design Spec - Mailbox Subsystem
# 04.03--Mailbox Design (v3, repo style)
**Status:** DRAFT | **Date:** 2025-10-28 | **Owner:** HSX Core

> **Design stance:** The mailbox subsystem is an executive-owned IPC service. It provides no autonomous scheduling, performs no direct task switching, and services no operations without explicit executive orchestration. All mailbox wait/wake transitions are driven externally by the executive scheduler.

**Authoritative context (repo-local):**
- Architecture: [03.03--Mailbox](../03--Architecture/03.03--Mailbox.md), [03.00--Architecture](../03--Architecture/03.00--Architecture.md)
- Study & Requirements: [02--Study](../02--Study/02--Study.md), [02.01--Requirements](../02--Study/02.01--Requirements.md)
- Implementation-phase specs (normative inputs referenced by design):
  [docs/abi_syscalls.md](../../docs/abi_syscalls.md), [docs/resource_budgets.md](../../docs/resource_budgets.md),
  [docs/executive_protocol.md](../../docs/executive_protocol.md), [include/hsx_mailbox.h](../../include/hsx_mailbox.h)

**Traceability (fill from 02.01--Requirements):** Refs DR[..], DG[..], DO[..].

## 1. Scope
- Executive-owned mailbox service providing deterministic task-to-task and host-to-task IPC (DR-6.1, DG-6.1).
- Configurable delivery modes (single-reader, fan-out, taps) with explicit policies for blocking, dropping, and tap behavior (DR-6.1, DG-6.1–6.4).
- Namespace support (`svc`, `pid`, `app`, `shared`) enabling stdio streams, telemetry distribution, and debugger integrations (DR-6.1, DG-6.2).
- Portable design compatible with both Python prototype and C executive implementations on constrained targets (DR-1.3, DG-1.4).
- Integration with executive scheduler for wait/wake transitions and timeout handling (DR-5.1, DG-5.1, DG-5.2).

## 2. Preconditions
- Executive scheduler and event system available to drive mailbox wait/wake transitions and timeout enforcement (DR-5.1, DG-5.1, DG-5.2).
- MiniVM SVC dispatch routes mailbox operations (module 0x05) through executive handlers as specified in architecture section 3.3 (DR-6.1, DG-6.1–6.3).
- System memory budgets configured per `docs/resource_budgets.md` (descriptor pool size, ring capacity, staging buffers) appropriate for target platform (DR-5.2, DG-6.2).
- Executive provides task context management (`pid`, `reg_base`, `stack_base`) and state tracking (`READY`, `WAIT_MBX`, `SLEEPING`) required for blocking operations (DR-5.1, DG-5.1).

## 3. Postconditions
- Mailbox subsystem delivers all configured delivery modes (single-reader, fan-out, taps) with documented, deterministic policies for blocking, dropping, and tap behavior (DR-6.1, DG-6.1–6.4).
- Instrumentation and event streaming emit structured events (`mailbox_send`, `mailbox_recv`, `mailbox_timeout`, `mailbox_overrun`) compatible with debugger and tooling consumption (DR-8.1, DG-6.2, DG-8.2).
- Resource usage (descriptor count, queue depth, memory footprint) stays within configured target budgets and can be tuned per platform profile (DR-5.2, DG-6.2).
- Tasks can reliably communicate via mailboxes without behavioural drift between Python reference and C port implementations (DR-1.3, DG-1.4).

## 4. Architectural Overview

### 4.1 Design Principles
- **Executive-driven model:** The mailbox subsystem owns no scheduler; all blocking, wake, and timeout behaviors are orchestrated by the executive through explicit wait list management.
- **Deterministic delivery:** Message ordering within a descriptor follows FIFO semantics; fan-out modes deliver to all readers in consistent order.
- **Resource bounded:** Descriptor count, ring capacity, and handle limits are statically configured or enforced at runtime per `docs/resource_budgets.md`.
- **Portable structures:** Message headers and API surface align with C structures (`hsx_mbx_msg_header_t`) for zero-copy firmware integration.
- **Namespace isolation:** Four namespaces (`svc:`, `pid:`, `app:`, `shared:`) provide scoping for executive services, per-task channels, application domains, and broadcast streams respectively.

### 4.2 Data Structures

#### 4.2.1 Mailbox Descriptor
The descriptor is the central control structure for a mailbox instance.

| Field | Type | Description |
|-------|------|-------------|
| `descriptor_id` | uint16 | Unique identifier within the executive's descriptor pool. |
| `namespace` | enum | One of `MBX_NS_SVC`, `MBX_NS_PID`, `MBX_NS_APP`, `MBX_NS_SHARED`. |
| `name` | string | Name within namespace (ASCII, max `HSX_MBX_MAX_NAME_BYTES`). |
| `owner_pid` | int | Owning task PID; used for `pid:` namespace and cleanup on task exit. |
| `capacity` | uint16 | Maximum queue size in bytes (payload + header overhead). |
| `mode_mask` | bitfield | Flags: `RDONLY`, `WRONLY`, `RDWR`, `TAP`, `FANOUT`, `FANOUT_DROP`, `FANOUT_BLOCK`. |
| `queue` | deque | Message queue (`deque[MailboxMessage]`); single-reader or fan-out. |
| `bytes_used` | uint16 | Current queue occupancy in bytes. |
| `waiters` | list | PIDs blocked on receive or send (depending on mode). |
| `taps` | list | PIDs registered as non-blocking observers. |
| `head_seq` | uint32 | Oldest message sequence number (fan-out tracking). |
| `next_seq` | uint32 | Next message sequence number to assign. |
| `ref_count` | uint8 | Number of open handles; descriptor freed when zero. |

Capacity enforcement: Each enqueued message costs `payload_len + 8` (header overhead). Mode flags determine blocking and fan-out behavior; see section 4.4 for semantics.

#### 4.2.2 Handle State
Per-task handle records track open mailbox references.

| Field | Type | Description |
|-------|------|-------------|
| `handle_id` | uint16 | Task-local handle identifier returned by `MAILBOX_OPEN`. |
| `descriptor_id` | uint16 | Reference to the underlying descriptor. |
| `last_seq` | uint32 | Last consumed sequence (fan-out mode only). |
| `pending_overrun` | bool | Set when messages were dropped; cleared on next recv. |
| `is_sender` | bool | True if handle opened with `WRONLY` or `RDWR`. |

#### 4.2.3 Mailbox Message
Message structure compatible with `hsx_mbx_msg_header_t` for firmware interoperability.

| Field | Type | Description |
|-------|------|-------------|
| `length` | uint16 | Payload length in bytes. |
| `flags` | uint8 | `HSX_MBX_FLAG_OVERRUN`, etc. |
| `channel` | uint8 | Optional sub-channel or priority hint. |
| `src_pid` | uint16 | Sending task PID. |
| `seq` | uint32 | Sequence number (fan-out tracking). |
| `payload` | bytes | Message data (max size per descriptor capacity). |

#### 4.2.4 Wait Queues
- Descriptor-level list of blocked PIDs awaiting receive or send completion.
- Timeout metadata (absolute deadline in microseconds) consulted by executive scheduler each scheduling tick.
- Waiters removed on wake (message arrival or capacity available) or timeout expiry.

#### 4.2.5 Namespace Index
- Dictionary keyed by `(namespace, name, owner_pid)` mapping to `descriptor_id`.
- Ensures deterministic lookups across Python and C implementations.
- Namespace rules:
  - `svc:` reserved for executive services (stdio, control channels).
  - `pid:<n>` auto-generated per task for private channels.
  - `app:<name>` for application domain sharing.
  - `shared:<name>` for broadcast/fan-out streams.

### 4.3 Execution Model
- All mailbox operations are synchronous SVC calls (module 0x05, functions 0x00–0x06).
- Blocking operations (`MAILBOX_RECV`, `MAILBOX_SEND` with `FANOUT_BLOCK`) transition the calling task to `WAIT_MBX` state until data arrives, capacity frees, or timeout expires.
- Non-blocking operations return immediately with status codes indicating success, would-block, or error conditions.
- Zero-length payloads serve as wake hints and always succeed regardless of capacity constraints.

### 4.4 Delivery Modes

#### 4.4.1 Single-Reader Mode (default)
- One active reader per descriptor.
- Messages are consumed (removed from queue) on `MAILBOX_RECV`.
- Send operations append to queue and wake exactly one blocked receiver (FIFO order).
- When capacity exhausted, senders block (or fail if policy prohibits blocking).

#### 4.4.2 Fan-Out Mode (`HSX_MBX_MODE_FANOUT`)
- Multiple readers receive independent copies of each message.
- Messages remain in queue until all readers have consumed them (tracked via per-handle `last_seq`).
- Reclamation: messages acknowledged by all readers are removed to free capacity.
- Two sub-policies:
  - `FANOUT_BLOCK`: senders block when queue is full until space is freed.
  - `FANOUT_DROP`: oldest unacknowledged messages are dropped to make room; affected readers see `HSX_MBX_FLAG_OVERRUN`.

#### 4.4.3 Tap Mode (`HSX_MBX_MODE_TAP`)
- Non-destructive observers receive copies without affecting primary readers.
- Taps do not block senders; messages are dropped for taps on overflow with `HSX_MBX_FLAG_OVERRUN`.
- Taps should not block the descriptor owner; best-effort delivery only.

#### 4.4.4 Blocking and Timeouts
- **Blocking:** Tasks calling `MAILBOX_RECV` or `MAILBOX_SEND` (when capacity full and policy is `FANOUT_BLOCK`) transition to `WAIT_MBX` state.
- **Timeout values:**
  - `HSX_MBX_TIMEOUT_POLL` (0): return immediately if data/space unavailable.
  - `1..0xFFFE`: millisecond deadline (host prototype uses monotonic clock).
  - `HSX_MBX_TIMEOUT_INFINITE` (0xFFFF): block indefinitely.
- **Timeout handling:** Scheduler decrements timers for blocked tasks; on expiry, removes PID from wait queue, transitions to `READY`, emits `mailbox_timeout`, and returns `HSX_MBX_STATUS_WOULDBLOCK` (upgrade to dedicated timeout code pending ABI update).

#### 4.4.5 Wake Hints
- Zero-length payloads always succeed regardless of capacity.
- Used to wake blocked receivers when actual data will be sent later or as coordination signals.

### 4.5 Operational Behavior

#### 4.5.1 Bind/Open
- **`MAILBOX_BIND`**: Parse target string, normalize namespace, create descriptor if not present. Mode mask and capacity configure behavior.
  - `svc:` namespace initializes stdio/control mailboxes per PID.
  - `pid:` provides private per-task control channels.
  - `shared:` defaults to fan-out mode for telemetry and broadcast.
- **`MAILBOX_OPEN`**: Acquire handle to existing descriptor; flags indicate read/write intent. Returns handle ID or error if descriptor not found.

#### 4.5.2 Send
1. Validate handle and ensure sender permissions.
2. Build `MailboxMessage` with payload, src_pid, channel, and assign `next_seq`.
3. Check capacity:
   - If available: enqueue message, update `bytes_used`, advance `next_seq`.
   - If full and non-blocking: return `HSX_MBX_STATUS_WOULDBLOCK`.
   - If full and blocking policy: add PID to sender wait queue, transition to `WAIT_MBX`.
4. Wake blocked receivers (single-reader: one PID; fan-out: all readers with pending data).
5. Update taps with non-destructive copies; drop on overflow with overrun flag.
6. Emit `mailbox_send` event for instrumentation.

#### 4.5.3 Receive
1. Validate handle and ensure receiver permissions.
2. Check for pending messages:
   - **Single-reader:** Pop queue head, update `bytes_used`, return message data.
   - **Fan-out:** Deliver next message by `last_seq`, advance handle's `last_seq`, check for reclamation.
3. If no data available:
   - `timeout == POLL`: return `HSX_MBX_STATUS_NO_DATA` immediately.
   - `timeout != POLL`: add PID to receiver wait queue, transition to `WAIT_MBX`, record deadline.
4. Emit `mailbox_recv` event for instrumentation.
5. Check and clear `pending_overrun` flag; set `HSX_MBX_FLAG_OVERRUN` in return flags if set.

#### 4.5.4 Tap Management
- **`MAILBOX_TAP`**: Toggle tap membership for handle.
- Taps receive non-destructive copies on send; delivery is best-effort.
- Overflows set `HSX_MBX_FLAG_OVERRUN` but do not block the sender.
- Taps do not participate in message acknowledgment or reclamation.

#### 4.5.5 Close
- **`MAILBOX_CLOSE`**: Release handle, decrement descriptor `ref_count`.
- When `ref_count` reaches zero, free descriptor and reclaim memory.
- Remove PID from all wait queues associated with the descriptor.

### 4.6 Fairness and Resource Management
- **FIFO wait queues:** Waiters wake in order of arrival to prevent starvation.
- **Scheduler counters:** Track `MAILBOX_STEP`, `MAILBOX_WAKE`, `MAILBOX_TIMEOUT` for diagnostics and fairness analysis.
- **Resource quotas:** Descriptor pool size, per-task handle limit, default capacity, and message overhead follow `docs/resource_budgets.md`.
  - Embedded AVR profile: ≈16 descriptors, 64-byte default rings, ≤1 KiB total metadata.
  - Python prototype: larger pools for development and testing.
- **Resource monitoring:** Mailbox manager exposes current descriptor depth and `bytes_used` vs. configured capacity; tests assert SRAM usage stays within budgets.

### 4.7 State Transitions

#### 4.7.1 Receive-side State Diagram
```text
                   +-------------+
                   |   READY     |
                   +------+------+
                          |
                          | scheduler selects PID
                          v
                   +-------------+
                   |   RUNNING   |
                   +------+------+-------------------------------+
                          |                                      |
        MAILBOX_RECV with | data                                 | MAILBOX_RECV (no data)
        data available    v                                      v  (blocking & timeout ≠ POLL)
                  +---------------+                     +---------------------+
                  | delivery path |                     |     WAIT_MBX        |
                  +-------+-------+                     +----+----------+-----+
                          |                                  |          |
                          |                                  | timeout  | mailbox wake
                          |                                  v          v
                          |                           +--------------+  |
                          |                           |  TIMEOUT (*) |  |
                          |                           +------+-------+  |
                          |                                  |          |
                          | scheduler yields                  | status   |
                          v                                  v          |
                   +-------------+                       +-------------+
                   |   READY     |<-----------------------|   READY     |
                   +-------------+        unblock         +-------------+
```
(*) Timeout currently returns `HSX_MBX_STATUS_WOULDBLOCK`; ABI will add a dedicated timeout code.

#### 4.7.2 Send-side Back-pressure
```text
RUNNING --MAILBOX_SEND-->
    success -------------------------------> READY (post-quantum)
    |
    +-- ring full + blocking policy ------> WAIT_MBX (sender queue)
                                             |
                                             | space freed / wake
                                             v
                                           READY
```

### 4.8 Wait/Wake Flow Example
1. Task A issues `MAILBOX_RECV` with `timeout = HSX_MBX_TIMEOUT_INFINITE`. No messages are present, so the executive adds PID(A) to the descriptor wait list, marks the task `WAIT_MBX`, and emits `mailbox_wait`.
2. Task B sends a message. The descriptor enqueues the payload, sets overrun flags if required, and wakes PID(A). Events `mailbox_send` and `mailbox_wake` are emitted.
3. Scheduler picks PID(A); the pending `MAILBOX_RECV` completes with `HSX_MBX_STATUS_OK`, returning length/flags/channel/src_pid in `R1–R4`.
4. If the timeout expired first, the scheduler would emit `mailbox_timeout`, transition PID(A) back to `READY`, and the trap would return `HSX_MBX_STATUS_WOULDBLOCK` (upgrade to dedicated timeout once available).

## 5. External Interfaces

### 5.1 SVC API (Module 0x05: Mailbox Services)

> Authoritative definitions live in [abi_syscalls.md](../../docs/abi_syscalls.md) and [include/hsx_mailbox.h](../../include/hsx_mailbox.h).

| Fn | Name | Arguments (`R0..R4`) | Return (`R0..R4`) | Errors | Notes |
|----|------|----------------------|-------------------|--------|-------|
| 0x00 | `MAILBOX_OPEN` | `R0=target_ptr`, `R1=flags` | `R0=status`, `R1=handle` | `INVALID_HANDLE`, `NO_DESCRIPTOR`, `EINVAL` | Acquire handle to existing descriptor; flags indicate read/write intent. |
| 0x01 | `MAILBOX_BIND` | `R0=target_ptr`, `R1=capacity`, `R2=mode_mask` | `R0=status`, `R1=descriptor` | `NO_DESCRIPTOR`, `EINVAL`, `ENOSPC` | Create or configure descriptor; capacity 0 uses default from `resource_budgets.md`. |
| 0x02 | `MAILBOX_SEND` | `R0=handle`, `R1=payload_ptr`, `R2=length`, `R3=flags`, `R4=channel` | `R0=status`, `R1=bytes_sent` | `INVALID_HANDLE`, `WOULDBLOCK`, `MSG_TOO_LARGE` | Returns `WOULDBLOCK` if capacity full and policy forbids drop; zero-length succeeds. |
| 0x03 | `MAILBOX_RECV` | `R0=handle`, `R1=buffer_ptr`, `R2=max_len`, `R3=timeout`, `R4=info_ptr` | `R0=status`, `R1=len`, `R2=flags`, `R3=channel`, `R4=src_pid` | `INVALID_HANDLE`, `WOULDBLOCK`, `NO_DATA` | Blocking integrates with scheduler; optional info struct for metadata. |
| 0x04 | `MAILBOX_PEEK` | `R0=handle` | `R0=status`, `R1=depth`, `R2=bytes_used`, `R3=next_len` | `INVALID_HANDLE` | Non-destructive queue stats; fan-out aware. |
| 0x05 | `MAILBOX_TAP` | `R0=handle`, `R1=enable` | `R0=status` | `INVALID_HANDLE`, `EINVAL` | Toggle tap membership for non-blocking observation. |
| 0x06 | `MAILBOX_CLOSE` | `R0=handle` | `R0=status` | `INVALID_HANDLE` | Release handle; descriptor freed when refcount reaches zero. |

#### 5.1.1 Status Codes
Status codes follow `include/hsx_mailbox.h`:

| Code | Value | Description |
|------|-------|-------------|
| `HSX_MBX_STATUS_OK` | 0 | Operation succeeded. |
| `HSX_MBX_STATUS_WOULDBLOCK` | 1 | Non-blocking operation would block. |
| `HSX_MBX_STATUS_INVALID_HANDLE` | 2 | Handle not found or invalid. |
| `HSX_MBX_STATUS_NO_DATA` | 3 | No messages available (non-blocking recv). |
| `HSX_MBX_STATUS_MSG_TOO_LARGE` | 4 | Payload exceeds capacity. |
| `HSX_MBX_STATUS_NO_DESCRIPTOR` | 5 | Descriptor pool exhausted. |
| `HSX_MBX_STATUS_INTERNAL_ERROR` | 6 | Internal error; check logs. |
| `HSX_MBX_STATUS_TIMEOUT` | 7 | *(Pending ABI update)* Timeout expired before completion. |

#### 5.1.2 Timeout Semantics
- `HSX_MBX_TIMEOUT_POLL` (0): return immediately if data/space unavailable.
- `1..0xFFFE`: millisecond deadline (host prototype uses monotonic clock; embedded uses timer ticks).
- `HSX_MBX_TIMEOUT_INFINITE` (0xFFFF): block indefinitely until wake or explicit task termination.

#### 5.1.3 Namespace Rules
- `svc:` reserved for executive services (stdio, control channels); created on task initialization.
- `pid:<n>` auto-generated per task for private IPC channels.
- `app:<name>` for application-specific domain sharing.
- `shared:<name>` for broadcast/fan-out telemetry streams.
- Enforce `HSX_MBX_MAX_NAME_BYTES` (typically 32) and ASCII-only characters for predictable footprints and interoperability.

### 5.2 Executive Integration
- **Wait/Wake coordination:** Mailbox operations integrate with executive scheduler via wait list management. Blocked tasks transition to `WAIT_MBX`; scheduler wakes on message arrival, capacity available, or timeout.
- **Event emission:** Mailbox operations emit structured events (`mailbox_send`, `mailbox_recv`, `mailbox_wait`, `mailbox_wake`, `mailbox_timeout`, `mailbox_overrun`) for debugger and tooling consumption per `docs/executive_protocol.md`.
- **Resource accounting:** Descriptor usage, queue depth, and memory footprint tracked against budgets in `docs/resource_budgets.md`.

### 5.3 Instrumentation and Observability
- **Trace logging:** Optional trace file logs SVC invocations with timestamp, PID, operation, and outcome.
- **RPC snapshots:** Executive RPC command `mailbox_snapshot` exposes live descriptor stats (depth, bytes_used, waiters, taps) for runtime diagnostics.
- **Event stream:** Structured events enable debugger breakpoints, watchpoints on descriptor state, and visualization of IPC flow.

## 6. Edge Cases and Error Handling
- **Descriptor exhaustion:** Return `HSX_MBX_STATUS_NO_DESCRIPTOR` with diagnostic trace; caller must retry or report error.
- **Handle leaks:** On task exit, executive iterates handle table, closes handles, and decrements descriptor `ref_count`; descriptors with zero refs are freed.
- **Stdio tapping:** Ensure stdout fan-out prioritizes owner before taps; apply rate limits to prevent tap starvation of owner.
- **Embedded profile constraints:** Obey SRAM caps from `docs/resource_budgets.md`; namespace features may be compile-time disabled per target profile.
- **Provisioning reload:** Flush descriptors tied to terminated PIDs; revoke handles; notify taps of descriptor closure.
- **Value/command subscription storms:** Coalesce notification bursts before mailbox publish to avoid saturation; use throttling or aggregation.
- **Sender starvation:** Maintain FIFO order for wake-ups so slow taps or fan-out readers cannot indefinitely starve senders.

## 7. Testing Strategy
- **Unit coverage:**
  - Bind/open permutations across all namespace types and mode flags.
  - Blocking send/recv with timeout variations (poll, finite, infinite).
  - Overrun signaling and flag propagation for fan-out and tap modes.
  - Descriptor lifecycle (create, ref increment, decrement, free).
- **Integration coverage:**
  - Stdio bridging: task stdout/stderr to shell via `svc:stdout`, `svc:stderr`.
  - Value subscription pipelines: `val.sub` delivering updates via mailbox fan-out.
  - Shell `listen` flows: debugger tap on telemetry descriptors.
- **Stress tests:**
  - High-rate producers saturating descriptor capacity; verify blocking/drop policies.
  - Mixed drop/block policies with concurrent readers at varying consumption rates.
  - Slow tap consumers; verify tap drop-on-overflow does not block owner.
- **Fairness validation:**
  - Confirm FIFO waiter rotation with instrumented scheduler counters.
  - Verify absence of starvation under sustained high load with mixed priorities.
- **Resource budget validation:**
  - Compare runtime descriptor depth and SRAM usage against `docs/resource_budgets.md` targets.
  - Trigger exhaustion scenarios; validate graceful degradation and error reporting.

## 8. Verification
- See [Mailbox_tests.md](../06--Test/system/Mailbox_tests.md) (if available).
- **Contract coverage:**
  - FIFO ordering for single-reader and fan-out modes.
  - Correct timeout behavior (poll, finite, infinite) with scheduler integration.
  - Handle ref-counting and descriptor cleanup on task exit.
  - Overrun flag propagation and tap isolation from blocking.
- **Behavioral coverage:**
  - Fan-out reclamation paths with mixed reader consumption rates.
  - Tap drop-on-overflow without sender/owner blocking.
  - Wake priority: owner before taps in fan-out mode.
- **Limits testing:**
  - Descriptor pool exhaustion; handle table saturation per task.
  - SRAM usage within embedded profile constraints.

## 9. Traceability
- **Design Requirements:** DR-1.1, DR-1.3, DR-5.1, DR-5.2, DR-6.1, DR-8.1.
- **Design Goals:** DG-1.2, DG-1.3, DG-1.4, DG-5.1, DG-5.2, DG-5.3, DG-6.1, DG-6.2, DG-6.3, DG-6.4, DG-8.2.
- **Design Options:** DO-6.a (mailbox delivery mode extensions).

