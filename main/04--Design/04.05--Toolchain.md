# Design Spec - Toolchain & Artefacts
# 04.05--Toolchain Design (v3, repo style)
**Status:** DRAFT | **Date:** 2025-10-28 | **Owner:** HSX Core

> **Design stance:** The toolchain is a build-time transformation pipeline. It performs no runtime orchestration, embeds no VM logic, and produces deterministic artefacts validated by the loader. All ABI contracts are specified externally; the toolchain implements but does not define them.

**Authoritative context (repo-local):**
- Architecture: [03.05--Toolchain](../03--Architecture/03.05--Toolchain.md), [03.00--Architecture](../03--Architecture/03.00--Architecture.md)
- Study & Requirements: [02--Study](../02--Study/02--Study.md), [02.01--Requirements](../02--Study/02.01--Requirements.md)
- Implementation-phase specs (normative inputs referenced by design):
  [docs/MVASM_SPEC.md](../../docs/MVASM_SPEC.md), [docs/hxe_format.md](../../docs/hxe_format.md),
  [docs/abi_syscalls.md](../../docs/abi_syscalls.md), [docs/hsx_llc.md](../../docs/hsx_llc.md)

**Traceability (fill from 02.01--Requirements):** Refs DR[..], DG[..], DO[..].

## 1. Scope
- LLVM-based lowering pipeline (`hsx-llc.py`) converting IR to MVASM with register allocation and ABI compliance (DR-2.2, DR-2.1a, DG-3.2).
- Assembler (`asm.py`) and linker (`hld.py`) producing HXO objects and HXE executables with relocation and debug metadata (DR-3.1, DG-3.1, DG-3.3).
- Build scripts and packaging workflows for SDK distribution and sample artefacts (DR-1.2, DR-2.5, DG-3.5).
- Debug metadata generation (symbols, line info, value/command descriptors) for tooling consumption (DR-3.1, DG-3.3, DG-3.5).

## 2. Preconditions
- Source language front-ends (clang/llc) produce LLVM IR compatible with `hsx-llc.py` lowering and legalization (DR-3.1, DG-3.2).
- MiniVM and Executive ISA and ABI contracts are stable per [04.01--VM.md](04.01--VM.md) and [04.02--Executive.md](04.02--Executive.md) (DR-2.2, DR-2.3, DR-2.5, DG-2.1–2.3).
- Build environment provides Python 3.11+, LLVM toolchain (clang-16+), and packaging dependencies per project README (DR-1.3, DG-3.2).
- HXE format specification ([docs/hxe_format.md](../../docs/hxe_format.md)) and MVASM spec ([docs/MVASM_SPEC.md](../../docs/MVASM_SPEC.md)) are stable (DR-3.1, DG-3.1).

## 3. Postconditions
- Toolchain emits `.hxo` object files and `.hxe` executables with deterministic layouts, complete relocation info, and optional debug metadata for debugger/tooling consumption (DR-3.1, DG-3.1, DG-3.3, DG-3.5).
- Register allocation, spill handling, and instruction lowering satisfy MiniVM constraints including ABI compliance and pass comprehensive regression test suites (DR-2.1a, DR-2.2, DG-3.2).
- Build and publishing scripts assemble SDK packages with documentation, sample artefacts, and metadata aligned with HSX release process (DR-1.2, DR-2.5).
- Generated code and artefacts exhibit no behavioral drift between Python prototype and future native toolchain implementations (DR-1.3, DG-1.4).

## 4. Architectural Overview

### 4.1 Design Principles
- **Deterministic output:** Given identical input IR and toolchain version, produce bit-identical `.hxo` and `.hxe` artefacts.
- **ABI compliance:** Enforce calling convention, register usage, stack alignment, and SVC encoding per [docs/abi_syscalls.md](../../docs/abi_syscalls.md).
- **Modular pipeline:** Clear separation between lowering (IR→MVASM), assembly (MVASM→HXO), and linking (HXO→HXE) stages.
- **Standard toolchain practice (v0.2.0):** Assembler emits object files by default; linker is sole entry point for executable creation. This follows industry practice (GCC, LLVM) and simplifies architecture.
- **Declarative metadata:** Process preprocessor directives (`#pragma hsx_value`, `#pragma hsx_command`, `#pragma hsx_mailbox`) to generate `.value`, `.cmd`, `.mailbox` metadata sections.
- **Debug-friendly:** Emit rich symbol, line, and value/command metadata for tooling without impacting runtime performance.
- **Extensible formats:** HXO (JSON+binary) and HXE (binary header+sections) support versioning and future extensions without breaking loaders.

### 4.2 Pipeline Stages

**Toolchain Flow (Standard Practice):**
Following industry-standard toolchain practice (GCC, LLVM), the assembler always emits object files (`.hxo`), and the linker is the sole point for creating executables (`.hxe`). This ensures:
- Single source of truth for executable format (linker only)
- Simpler assembler architecture (no executable format knowledge required)
- Consistent build flow for all programs (single-file or multi-module)
- Future-ready for library support and advanced linking features

#### 4.2.1 LLVM Lowering (`hsx-llc.py`)
- **Input:** LLVM IR (.ll or .bc files) from clang or other front-ends, with embedded pragma annotations and optional LLVM debug metadata.
- **Output:** MVASM source (.asm) with register assignments, relocations, and metadata sections. Optional intermediate .dbg JSON file with debug information.
- **Processing:**
  1. **Parse pragma directives**: Extract `#pragma hsx_value`, `#pragma hsx_command`, `#pragma hsx_mailbox` from IR.
  2. **Parse debug metadata** (when `--emit-debug` specified): Extract `!DILocation`, `!DISubprogram`, `!DIFile` nodes from LLVM IR for line number preservation.
  3. Legalize LLVM IR (expand unsupported ops, lower intrinsics).
  4. Perform register allocation (linear scan, caller/callee-saved conventions).
  5. Lower arithmetic, control flow, and SVC calls to MVASM opcodes.
  6. **Track instruction mappings** (when debug enabled): Map LLVM instructions to MVASM line numbers for line info preservation.
  7. Emit prologue/epilogue sequences per ABI.
  8. Generate relocation entries for symbols and external references.
  9. **Emit metadata directives**: Generate `.value`, `.cmd`, `.mailbox` section directives for assembler.
  10. **Emit debug info** (optional): Write .dbg JSON file with function names, line mappings, and LLVM→MVASM instruction correlations.

**Debug Metadata Extraction:**
When compiled with `-g`, Clang embeds LLVM debug metadata nodes:
- `!DISubprogram`: Function definitions (name, file, line)
- `!DILocation`: Line/column for each instruction
- `!DIFile`: Source file paths
- `!DILocalVariable`: Local variable declarations (Phase 3)

The `--emit-debug` flag triggers parsing of these nodes and generation of an intermediate .dbg JSON file containing:
```json
{
  "version": 1,
  "source_file": "main.c",
  "functions": [
    {"name": "main", "start_line": 10, "mvasm_start": 0}
  ],
  "line_map": [
    {"mvasm_line": 5, "source_line": 12, "source_file": "main.c"}
  ]
}
```

This enables 3-phase implementation:
- Phase 1 (MVP): Function-level debug info (names, start lines)
- Phase 2: Instruction-level line tracking
- Phase 3: Variable tracking for watch expressions

#### 4.2.2 Assembly (`asm.py`)
- **Input:** MVASM source with directives (`.text`, `.data`, `.bss`, `.value`, `.cmd`, `.mailbox`, labels, symbols).
- **Output:** HXO object file (JSON header + binary sections including metadata) - **ALWAYS**
- **Design Decision (v0.2.0):** Assembler **always** emits `.hxo` object files. The assembler contains **no HXE creation logic**—it only produces object files.
- **Convenience Mode (`--emit-hxe`):** For single-file workflows, `--emit-hxe` provides a convenience wrapper that:
  1. Creates a temporary `.hxo` object file
  2. Invokes `hld.py` to generate the `.hxe` executable
  3. Cleans up the temporary `.hxo` file
  
  This ensures the linker remains the sole entry point for `.hxe` creation while providing ergonomic single-command compilation.
- **Processing:**
  1. Parse MVASM syntax and resolve local labels.
  2. Encode opcodes and operands per [docs/MVASM_SPEC.md](../../docs/MVASM_SPEC.md).
  3. **Process metadata directives**: Parse `.value`/`.cmd`/`.mailbox` sections and encode per HXE format spec.
  4. Build relocation table for unresolved external symbols.
  5. Emit symbol table with section offsets.
  6. Optionally generate listing file and JSON debug metadata (`--dump-json`).

#### 4.2.3 Linking (`hld.py`)
- **Input:** One or more HXO files plus optional linker script and app metadata (app_name, allow_multiple_instances flag).
- **Output:** HXE executable (version 0x0002) with header, code/data sections, metadata sections, section table, and embedded manifest.
- **Design Decision (v0.2.0):** Linker is the **single point for creating `.hxe` executables**. All build flows (single-file or multi-module) must invoke the linker, ensuring consistent executable generation and simplifying the assembler architecture.
- **Processing:**
  1. Merge sections from all HXO inputs (.text, .data, .bss, .value, .cmd, .mailbox).
  2. Resolve external symbol references and apply relocations.
  3. Allocate final addresses and compute entry point.
  4. **Build metadata section table**: Create section table entries for `.value`, `.cmd`, `.mailbox` sections with offsets/sizes.
  5. Generate HXE header (v0x0002) with magic, version=0x0002, flags (including allow_multiple_instances), app_name, section sizes, meta_offset, meta_count, CRC32.
  6. Optionally embed provisioning manifest (FRAM keys, values) per [docs/hxe_format.md](../../docs/hxe_format.md).
  7. **Emit debug symbols** (when `--emit-sym` and `--debug-info` provided):
     - Load .dbg files from compilation units
     - Map MVASM addresses to final HXE addresses after relocation
     - Merge symbol tables, line mappings, and function boundaries
     - Generate .sym JSON file with complete debug information

**Symbol File Generation:**
When `--emit-sym` flag is provided along with `--debug-info <.dbg files>`, the linker generates a .sym JSON file containing:

```json
{
  "version": 1,
  "hxe_path": "app.hxe",
  "hxe_crc": 0x12345678,
  "symbols": {
    "functions": [
      {
        "name": "main",
        "address": 0x0100,
        "size": 64,
        "file": "main.c",
        "line": 10
      }
    ],
    "variables": [
      {
        "name": "counter",
        "address": 0x2000,
        "size": 4,
        "type": "uint32_t",
        "scope": "global"
      }
    ],
    "labels": {
      "0x0100": ["main", "_start"],
      "0x0120": ["loop_top"]
    }
  },
  "instructions": [
    {
      "pc": 0x0100,
      "word": 0x01020304,
      "mnemonic": "LDI",
      "operands": "R1, 0x5",
      "file": "main.c",
      "line": 12
    }
  ],
  "memory_regions": [
    {
      "name": "code",
      "start": 0x0000,
      "end": 0x1FFF,
      "type": "text"
    },
    {
      "name": "data",
      "start": 0x2000,
      "end": 0x2FFF,
      "type": "data"
    },
    {
      "name": "stack",
      "start": 0x7000,
      "end": 0x7FFF,
      "type": "stack"
    }
  ]
}
```

The .sym file is loaded by the executive at runtime (desktop variant) or by the debugger directly (MCU variant) to provide symbol annotations for disassembly, stack traces, and watch expressions.

#### 4.2.4 Source Path Handling for Debugger

**Challenge:** Clang embeds absolute paths in LLVM IR debug metadata by default, which causes portability issues when debugging on different machines or in CI environments.

**Solution:** Use Clang's `-fdebug-prefix-map` flag to replace absolute paths with relative paths during compilation.

**Compilation Flags:**
```makefile
PROJECT_ROOT := $(shell pwd)
CFLAGS_DEBUG := -g -fdebug-prefix-map=$(PROJECT_ROOT)=.
```

**Example:**
```bash
# Without prefix map (absolute paths):
clang -g test.c -S -emit-llvm -o test.ll
# Result: !DIFile(filename: "test.c", directory: "/home/user/project")

# With prefix map (relative paths):
clang -g -fdebug-prefix-map=/home/user/project=. test.c -S -emit-llvm -o test.ll
# Result: !DIFile(filename: "test.c", directory: ".")
```

**Source List Generation:**
To aid debugger path resolution, the build system generates `sources.json` mapping relative paths to absolute paths:

**File:** `build/debug/sources.json`
```json
{
  "version": 1,
  "project_root": "/home/user/hsx-project",
  "build_time": "2025-10-31T08:00:00Z",
  "sources": [
    {
      "file": "main.c",
      "path": "/home/user/hsx-project/main.c",
      "relative": "./main.c"
    },
    {
      "file": "src/utils.c",
      "path": "/home/user/hsx-project/src/utils.c",
      "relative": "./src/utils.c"
    }
  ],
  "include_paths": [
    "/home/user/hsx-project/include",
    "/usr/local/include/hsx"
  ]
}
```

**Generation Script:**
```python
#!/usr/bin/env python3
# scripts/generate-sources-json.py
import os
import json
from pathlib import Path
from datetime import datetime

def generate_source_list(project_root: Path, sources: list) -> dict:
    """Generate source list JSON for debugger path resolution"""
    data = {
        'version': 1,
        'project_root': str(project_root.resolve()),
        'build_time': datetime.utcnow().isoformat() + 'Z',
        'sources': []
    }
    
    for src in sources:
        src_path = Path(src)
        abs_path = (project_root / src_path).resolve()
        
        data['sources'].append({
            'file': str(src_path),
            'path': str(abs_path),
            'relative': f"./{src_path}"
        })
    
    return data

# Usage in Makefile:
# $(PYTHON) scripts/generate-sources-json.py $(SOURCES) > build/debug/sources.json
```

**Debugger Path Resolution:**
When the debugger loads a .sym file with relative paths, it uses `sources.json` to resolve them:

1. Check if path exists as absolute path
2. Check `sources.json` for mapping
3. Try relative to project root (from sources.json)
4. Try configured search paths
5. Prompt user if not found

**Toolchain Integration:**
The unified build script (`hsx-cc-build.py`) automatically:
1. Compiles with `-fdebug-prefix-map` for relative paths
2. Generates sources.json during debug builds
3. Places both .sym and sources.json in `build/debug/`
4. Ensures paths are consistent across all generated files

**Design Rationale - Standardized Toolchain Flow (v0.2.0):**

The toolchain was refactored to follow standard practice where the assembler always emits object files (`.hxo`) and the linker is the sole point for creating executables (`.hxe`). This decision was made to:

1. **Single Source of Truth:** Only the linker knows about the final executable format (HXE), reducing complexity and maintenance burden.
2. **Architectural Simplicity:** The assembler focuses solely on instruction encoding and object file generation, without needing HXE format knowledge.
3. **Consistency:** All build flows (single-file or multi-module) follow the same path: assemble → link.
4. **Future-Ready:** Simplifies future enhancements like:
   - Library support with standard values/commands/mailboxes
   - Advanced linking features (LTO, whole-program optimization)
   - Metadata section merging and deduplication
5. **Industry Alignment:** Matches the architecture of GCC, LLVM, and other production toolchains.

The assembler retains `--emit-hxe` flag for backward compatibility and convenience, but all production builds should use the standard flow through the linker.

**App Name Handling:**
- Linker accepts `--app-name <name>` parameter (required for HXE v0.0002).
- Linker accepts `--allow-multiple-instances` flag (optional, sets bit 1 in flags field).
- App name is stored in header at offset 0x20 (32-byte field, null-terminated, max 31 characters).

**Metadata Section Handling:**
- Merge `.value`, `.cmd`, `.mailbox` sections from all HXO inputs.
- Build string tables for names, units, help text.
- Generate section table with offsets pointing to each metadata section.
- CRC calculation includes all metadata sections.

### 4.3 Data Structures

#### 4.3.1 LLVM Lowering State
- `available_regs`: Pool of physical registers (R0-R15, subset for caller/callee-saved).
- `virt_to_phys`: Mapping from virtual to physical registers.
- `live_intervals`: Per-basic-block liveness analysis for register allocation.
- `spill_slots`: Stack frame offsets for spilled virtual registers.

#### 4.3.2 MVASM Instruction Model
- Opcode enum (ADD, SUB, LD, ST, SVC, etc.) per [docs/MVASM_SPEC.md](../../docs/MVASM_SPEC.md).
- Operand descriptors: register (Rn), immediate (signed/unsigned), label (symbol reference).
- Encoding: 16-bit primary word with optional extension words for immediates and displacements.

#### 4.3.3 HXO Object Format
JSON header with binary section blobs:
```json
{
  "version": 1,
  "sections": {
    "text": "<hex>",
    "data": "<hex>",
    "bss_size": 256
  },
  "relocs": [
    {"offset": 0x10, "type": "ABS16", "symbol": "main"}
  ],
  "symbols": [
    {"name": "_start", "section": "text", "value": 0, "size": 32}
  ]
}
```

#### 4.3.4 HXE Executable Header
Fixed binary layout per [docs/hxe_format.md](../../docs/hxe_format.md):
- Magic: `HSXE` (4 bytes)
- Version: uint16
- Code length, rodata length, BSS size: uint32 each
- Entry offset: uint32
- Capability flags: uint16 (requires_f16, needs_mailbox, etc.)
- CRC32: uint32 (covers all sections)

#### 4.3.5 Debug Metadata
Optional JSON sidecar or embedded section:
- PC → (file, line, symbol) mapping
- Value/command descriptor export (group, name, unit, range)
- Stack frame layout for debugger stack reconstruction

## 5. External Interfaces

### 5.1 Toolchain Commands

| Tool | Input | Output | Key Options |
|------|-------|--------|-------------|
| `hsx-llc.py` | LLVM IR (.ll, .bc) | MVASM (.asm) | `--target=hsx`, `--opt-level=0-3` |
| `asm.py` | MVASM (.asm) | **HXO (.hxo)** (always) | `--emit-hxe` (convenience wrapper), `--dump-json`, `--listing` |
| `hld.py` | HXO files (.hxo) | **HXE (.hxe)** | `--output`, `--manifest`, `--strip-debug`, `--app-name`, `--allow-multiple-instances` |

**Standard Build Flow (v0.2.0):**
```bash
# Step 1: Lower IR to MVASM
hsx-llc.py input.ll -o output.asm

# Step 2: Assemble to object (always produces .hxo)
asm.py output.asm -o output.hxo

# Step 3: Link to executable (linker is sole entry point for .hxe)
hld.py output.hxo -o program.hxe --app-name myapp
```

**Convenience Mode (for single-file workflows):**
```bash
# Assembler internally creates temp .hxo and invokes linker
asm.py output.asm -o program.hxe --emit-hxe
```

**Note:** The `--emit-hxe` flag is a convenience wrapper that internally invokes the linker. The assembler contains no HXE creation logic—all executable generation flows through `hld.py`.

### 5.2 Integration with Build Systems
- Makefile targets: `make build`, `make test`, `make package`
- CMake support (future): `add_hsx_executable(target sources...)`
- Continuous integration: toolchain regression tests on each commit

## 6. Edge Cases and Error Handling
- **Unsupported LLVM IR:** Emit diagnostic with suggested rewrites; fallback patterns for complex constructs.
- **Relocation overflow:** Detect at link time if symbol offsets exceed encoding limits; suggest code reorganization.
- **CRC mismatch:** Linker validates all inputs before emission; provisioning detects corrupted `.hxe` files at load time.
- **Version incompatibility:** `.hxe` version field enables loader compatibility checks; tooling warns on mismatch.
- **Debug metadata size:** Large symbol tables can be stripped via `--strip-debug` for production builds.

## 7. Testing Strategy
- **Unit tests:**
  - LLVM lowering patterns (arithmetic, control flow, SVC encoding).
  - Register allocation correctness (no overlapping live ranges, ABI compliance).
  - Assembler directive parsing and opcode encoding.
  - Linker relocation resolution and section merging.
- **Integration tests:**
  - End-to-end compilation: C source → LLVM IR → MVASM → HXO → HXE → VM execution.
  - CRC and header integrity validation.
  - Symbol metadata consumed correctly by debugger.
- **Regression tests:**
  - Golden `.hxe` fixtures for deterministic output verification.
  - Toolchain version compatibility matrix.

## 8. Verification
- See [Toolchain_tests.md](../06--Test/system/Toolchain_tests.md) (if available).
- **Contract coverage:**
  - ABI compliance (calling convention, register usage, stack alignment).
  - Deterministic output (bit-identical builds from same inputs).
  - CRC correctness (detect any binary corruption).
- **Behavioral coverage:**
  - Complex control flow (nested loops, switch statements).
  - Floating-point operations (f16 encoding/decoding).
  - Large programs (stress section limits, relocation counts).

## 9. Traceability
- **Design Requirements:** DR-1.2, DR-1.3, DR-2.1a, DR-2.2, DR-2.3, DR-2.5, DR-3.1.
- **Design Goals:** DG-1.3, DG-1.4, DG-2.1, DG-2.2, DG-2.3, DG-3.1, DG-3.2, DG-3.3, DG-3.4, DG-3.5.
- **Design Options:** DO-3.a (toolchain extensions), DO-hxe-sym (symbol metadata format).





