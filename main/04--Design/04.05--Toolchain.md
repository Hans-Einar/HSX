# Design Spec - Toolchain & Artefacts
# 04.05--Toolchain Design (v3, repo style)
**Status:** DRAFT | **Date:** 2025-10-28 | **Owner:** HSX Core

> **Design stance:** The toolchain is a build-time transformation pipeline. It performs no runtime orchestration, embeds no VM logic, and produces deterministic artefacts validated by the loader. All ABI contracts are specified externally; the toolchain implements but does not define them.

**Authoritative context (repo-local):**
- Architecture: [03.05--Toolchain](../03--Architecture/03.05--Toolchain.md), [03.00--Architecture](../03--Architecture/03.00--Architecture.md)
- Study & Requirements: [02--Study](../02--Study/02--Study.md), [02.01--Requirements](../02--Study/02.01--Requirements.md)
- Implementation-phase specs (normative inputs referenced by design):
  [docs/MVASM_SPEC.md](../../docs/MVASM_SPEC.md), [docs/hxe_format.md](../../docs/hxe_format.md),
  [docs/abi_syscalls.md](../../docs/abi_syscalls.md), [docs/hsx_llc.md](../../docs/hsx_llc.md)

**Traceability (fill from 02.01--Requirements):** Refs DR[..], DG[..], DO[..].

## 1. Scope
- LLVM-based lowering pipeline (`hsx-llc.py`) converting IR to MVASM with register allocation and ABI compliance (DR-2.2, DR-2.1a, DG-3.2).
- Assembler (`asm.py`) and linker (`hld.py`) producing HXO objects and HXE executables with relocation and debug metadata (DR-3.1, DG-3.1, DG-3.3).
- Build scripts and packaging workflows for SDK distribution and sample artefacts (DR-1.2, DR-2.5, DG-3.5).
- Debug metadata generation (symbols, line info, value/command descriptors) for tooling consumption (DR-3.1, DG-3.3, DG-3.5).

## 2. Preconditions
- Source language front-ends (clang/llc) produce LLVM IR compatible with `hsx-llc.py` lowering and legalization (DR-3.1, DG-3.2).
- MiniVM and Executive ISA and ABI contracts are stable per [04.01--VM.md](04.01--VM.md) and [04.02--Executive.md](04.02--Executive.md) (DR-2.2, DR-2.3, DR-2.5, DG-2.1–2.3).
- Build environment provides Python 3.11+, LLVM toolchain (clang-16+), and packaging dependencies per project README (DR-1.3, DG-3.2).
- HXE format specification ([docs/hxe_format.md](../../docs/hxe_format.md)) and MVASM spec ([docs/MVASM_SPEC.md](../../docs/MVASM_SPEC.md)) are stable (DR-3.1, DG-3.1).

## 3. Postconditions
- Toolchain emits `.hxo` object files and `.hxe` executables with deterministic layouts, complete relocation info, and optional debug metadata for debugger/tooling consumption (DR-3.1, DG-3.1, DG-3.3, DG-3.5).
- Register allocation, spill handling, and instruction lowering satisfy MiniVM constraints including ABI compliance and pass comprehensive regression test suites (DR-2.1a, DR-2.2, DG-3.2).
- Build and publishing scripts assemble SDK packages with documentation, sample artefacts, and metadata aligned with HSX release process (DR-1.2, DR-2.5).
- Generated code and artefacts exhibit no behavioral drift between Python prototype and future native toolchain implementations (DR-1.3, DG-1.4).

## 4. Architectural Overview

### 4.1 Design Principles
- **Deterministic output:** Given identical input IR and toolchain version, produce bit-identical `.hxo` and `.hxe` artefacts.
- **ABI compliance:** Enforce calling convention, register usage, stack alignment, and SVC encoding per [docs/abi_syscalls.md](../../docs/abi_syscalls.md).
- **Modular pipeline:** Clear separation between lowering (IR→MVASM), assembly (MVASM→HXO), and linking (HXO→HXE) stages.
- **Standard toolchain practice (v0.2.0):** Assembler emits object files by default; linker is sole entry point for executable creation. This follows industry practice (GCC, LLVM) and simplifies architecture.
- **Declarative metadata:** Process preprocessor directives (`#pragma hsx_value`, `#pragma hsx_command`, `#pragma hsx_mailbox`) to generate `.value`, `.cmd`, `.mailbox` metadata sections.
- **Debug-friendly:** Emit rich symbol, line, and value/command metadata for tooling without impacting runtime performance.
- **Extensible formats:** HXO (JSON+binary) and HXE (binary header+sections) support versioning and future extensions without breaking loaders.

### 4.2 Pipeline Stages

**Toolchain Flow (Standard Practice):**
Following industry-standard toolchain practice (GCC, LLVM), the assembler always emits object files (`.hxo`), and the linker is the sole point for creating executables (`.hxe`). This ensures:
- Single source of truth for executable format (linker only)
- Simpler assembler architecture (no executable format knowledge required)
- Consistent build flow for all programs (single-file or multi-module)
- Future-ready for library support and advanced linking features

#### 4.2.1 LLVM Lowering (`hsx-llc.py`)
- **Input:** LLVM IR (.ll or .bc files) from clang or other front-ends, with embedded pragma annotations.
- **Output:** MVASM source (.asm) with register assignments, relocations, and metadata sections.
- **Processing:**
  1. **Parse pragma directives**: Extract `#pragma hsx_value`, `#pragma hsx_command`, `#pragma hsx_mailbox` from IR.
  2. Legalize LLVM IR (expand unsupported ops, lower intrinsics).
  3. Perform register allocation (linear scan, caller/callee-saved conventions).
  4. Lower arithmetic, control flow, and SVC calls to MVASM opcodes.
  5. Emit prologue/epilogue sequences per ABI.
  6. Generate relocation entries for symbols and external references.
  7. **Emit metadata directives**: Generate `.value`, `.cmd`, `.mailbox` section directives for assembler.

#### 4.2.2 Assembly (`asm.py`)
- **Input:** MVASM source with directives (`.text`, `.data`, `.bss`, `.value`, `.cmd`, `.mailbox`, labels, symbols).
- **Output:** HXO object file (JSON header + binary sections including metadata) - **DEFAULT OUTPUT**
- **Design Decision (v0.2.0):** Assembler defaults to emitting `.hxo` object files, following standard toolchain practice. Direct `.hxe` executable generation is available via `--emit-hxe` flag for backward compatibility/convenience only.
- **Processing:**
  1. Parse MVASM syntax and resolve local labels.
  2. Encode opcodes and operands per [docs/MVASM_SPEC.md](../../docs/MVASM_SPEC.md).
  3. **Process metadata directives**: Parse `.value`/`.cmd`/`.mailbox` sections and encode per HXE format spec.
  4. Build relocation table for unresolved external symbols.
  5. Emit symbol table with section offsets.
  6. Optionally generate listing file and JSON debug metadata (`--dump-json`).

#### 4.2.3 Linking (`hld.py`)
- **Input:** One or more HXO files plus optional linker script and app metadata (app_name, allow_multiple_instances flag).
- **Output:** HXE executable (version 0x0002) with header, code/data sections, metadata sections, section table, and embedded manifest.
- **Design Decision (v0.2.0):** Linker is the **single point for creating `.hxe` executables**. All build flows (single-file or multi-module) must invoke the linker, ensuring consistent executable generation and simplifying the assembler architecture.
- **Processing:**
  1. Merge sections from all HXO inputs (.text, .data, .bss, .value, .cmd, .mailbox).
  2. Resolve external symbol references and apply relocations.
  3. Allocate final addresses and compute entry point.
  4. **Build metadata section table**: Create section table entries for `.value`, `.cmd`, `.mailbox` sections with offsets/sizes.
  5. Generate HXE header (v0x0002) with magic, version=0x0002, flags (including allow_multiple_instances), app_name, section sizes, meta_offset, meta_count, CRC32.
  6. Optionally embed provisioning manifest (FRAM keys, values) per [docs/hxe_format.md](../../docs/hxe_format.md).
  7. Emit combined symbol/line info for debugger.

**Design Rationale - Standardized Toolchain Flow (v0.2.0):**

The toolchain was refactored to follow standard practice where the assembler always emits object files (`.hxo`) and the linker is the sole point for creating executables (`.hxe`). This decision was made to:

1. **Single Source of Truth:** Only the linker knows about the final executable format (HXE), reducing complexity and maintenance burden.
2. **Architectural Simplicity:** The assembler focuses solely on instruction encoding and object file generation, without needing HXE format knowledge.
3. **Consistency:** All build flows (single-file or multi-module) follow the same path: assemble → link.
4. **Future-Ready:** Simplifies future enhancements like:
   - Library support with standard values/commands/mailboxes
   - Advanced linking features (LTO, whole-program optimization)
   - Metadata section merging and deduplication
5. **Industry Alignment:** Matches the architecture of GCC, LLVM, and other production toolchains.

The assembler retains `--emit-hxe` flag for backward compatibility and convenience, but all production builds should use the standard flow through the linker.

**App Name Handling:**
- Linker accepts `--app-name <name>` parameter (required for HXE v0.0002).
- Linker accepts `--allow-multiple-instances` flag (optional, sets bit 1 in flags field).
- App name is stored in header at offset 0x20 (32-byte field, null-terminated, max 31 characters).

**Metadata Section Handling:**
- Merge `.value`, `.cmd`, `.mailbox` sections from all HXO inputs.
- Build string tables for names, units, help text.
- Generate section table with offsets pointing to each metadata section.
- CRC calculation includes all metadata sections.

### 4.3 Data Structures

#### 4.3.1 LLVM Lowering State
- `available_regs`: Pool of physical registers (R0-R15, subset for caller/callee-saved).
- `virt_to_phys`: Mapping from virtual to physical registers.
- `live_intervals`: Per-basic-block liveness analysis for register allocation.
- `spill_slots`: Stack frame offsets for spilled virtual registers.

#### 4.3.2 MVASM Instruction Model
- Opcode enum (ADD, SUB, LD, ST, SVC, etc.) per [docs/MVASM_SPEC.md](../../docs/MVASM_SPEC.md).
- Operand descriptors: register (Rn), immediate (signed/unsigned), label (symbol reference).
- Encoding: 16-bit primary word with optional extension words for immediates and displacements.

#### 4.3.3 HXO Object Format
JSON header with binary section blobs:
```json
{
  "version": 1,
  "sections": {
    "text": "<hex>",
    "data": "<hex>",
    "bss_size": 256
  },
  "relocs": [
    {"offset": 0x10, "type": "ABS16", "symbol": "main"}
  ],
  "symbols": [
    {"name": "_start", "section": "text", "value": 0, "size": 32}
  ]
}
```

#### 4.3.4 HXE Executable Header
Fixed binary layout per [docs/hxe_format.md](../../docs/hxe_format.md):
- Magic: `HSXE` (4 bytes)
- Version: uint16
- Code length, rodata length, BSS size: uint32 each
- Entry offset: uint32
- Capability flags: uint16 (requires_f16, needs_mailbox, etc.)
- CRC32: uint32 (covers all sections)

#### 4.3.5 Debug Metadata
Optional JSON sidecar or embedded section:
- PC → (file, line, symbol) mapping
- Value/command descriptor export (group, name, unit, range)
- Stack frame layout for debugger stack reconstruction

## 5. External Interfaces

### 5.1 Toolchain Commands

| Tool | Input | Output | Key Options |
|------|-------|--------|-------------|
| `hsx-llc.py` | LLVM IR (.ll, .bc) | MVASM (.asm) | `--target=hsx`, `--opt-level=0-3` |
| `asm.py` | MVASM (.asm) | **HXO (.hxo)** (default) or HXE (.hxe) with `--emit-hxe` | `--emit-hxe` (legacy mode), `--dump-json`, `--listing` |
| `hld.py` | HXO files (.hxo) | **HXE (.hxe)** | `--output`, `--manifest`, `--strip-debug`, `--app-name`, `--allow-multiple-instances` |

**Standard Build Flow (v0.2.0):**
```bash
# Step 1: Lower IR to MVASM
hsx-llc.py input.ll -o output.asm

# Step 2: Assemble to object (default behavior)
asm.py output.asm -o output.hxo

# Step 3: Link to executable (always required)
hld.py output.hxo -o program.hxe --app-name myapp
```

**Legacy Single-File Mode (for convenience only):**
```bash
# Direct executable generation (skips linker)
asm.py output.asm -o program.hxe --emit-hxe
```

### 5.2 Integration with Build Systems
- Makefile targets: `make build`, `make test`, `make package`
- CMake support (future): `add_hsx_executable(target sources...)`
- Continuous integration: toolchain regression tests on each commit

## 6. Edge Cases and Error Handling
- **Unsupported LLVM IR:** Emit diagnostic with suggested rewrites; fallback patterns for complex constructs.
- **Relocation overflow:** Detect at link time if symbol offsets exceed encoding limits; suggest code reorganization.
- **CRC mismatch:** Linker validates all inputs before emission; provisioning detects corrupted `.hxe` files at load time.
- **Version incompatibility:** `.hxe` version field enables loader compatibility checks; tooling warns on mismatch.
- **Debug metadata size:** Large symbol tables can be stripped via `--strip-debug` for production builds.

## 7. Testing Strategy
- **Unit tests:**
  - LLVM lowering patterns (arithmetic, control flow, SVC encoding).
  - Register allocation correctness (no overlapping live ranges, ABI compliance).
  - Assembler directive parsing and opcode encoding.
  - Linker relocation resolution and section merging.
- **Integration tests:**
  - End-to-end compilation: C source → LLVM IR → MVASM → HXO → HXE → VM execution.
  - CRC and header integrity validation.
  - Symbol metadata consumed correctly by debugger.
- **Regression tests:**
  - Golden `.hxe` fixtures for deterministic output verification.
  - Toolchain version compatibility matrix.

## 8. Verification
- See [Toolchain_tests.md](../06--Test/system/Toolchain_tests.md) (if available).
- **Contract coverage:**
  - ABI compliance (calling convention, register usage, stack alignment).
  - Deterministic output (bit-identical builds from same inputs).
  - CRC correctness (detect any binary corruption).
- **Behavioral coverage:**
  - Complex control flow (nested loops, switch statements).
  - Floating-point operations (f16 encoding/decoding).
  - Large programs (stress section limits, relocation counts).

## 9. Traceability
- **Design Requirements:** DR-1.2, DR-1.3, DR-2.1a, DR-2.2, DR-2.3, DR-2.5, DR-3.1.
- **Design Goals:** DG-1.3, DG-1.4, DG-2.1, DG-2.2, DG-2.3, DG-3.1, DG-3.2, DG-3.3, DG-3.4, DG-3.5.
- **Design Options:** DO-3.a (toolchain extensions), DO-hxe-sym (symbol metadata format).





