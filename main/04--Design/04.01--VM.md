# Design Spec – MiniVM

## Scope
- Implement the HSX instruction-set architecture (ISA) for a single task on both reference (Python) and embedded (C) targets, without bundling an in-VM operating system (DR-2.1, DG-4.1).
- Provide deterministic execution regardless of whether an executive is attached, so very small targets can run a single HSX program autonomously (DR-1.1, DG-1.4).
- Surface consistent debugging, trap, and syscall behaviour that the executive, tooling, and HAL layers can rely on (DR-8.1, DG-5.2, DG-8.1).

## Preconditions
- Toolchain emits `.hxe` binaries with entry point and section metadata, plus optional symbol/line tables for debugging (DR-3.1, DG-3.3).
- Executive (when present) allocates per-task register/stack arenas, drives clocking, and routes syscalls/events through its RPC surface (DR-5.1, DG-5.3).
- HAL shims are available to handle a subset of syscalls locally when the executive is detached (see `04.08--HAL.md`) (DR-6.1, DG-6.1).

## Postconditions
- MiniVM instances can be swapped between Python reference and C port without behavioural drift at the ISA, ABI, or syscall level (DR-1.3, DG-1.4).
- Tasks can be loaded, executed, paused, restarted, and context switched purely by adjusting workspace pointers and stacks—no whole-register copies required (DR-2.1a, DG-4.1).
- Debug traps (`BRK`, single-step), SVC invocations, and error events emit structured payloads compatible with the executive event protocol (DR-8.1, DG-5.2).

## Architectural Overview
- **Fetch/Decode/Execute loop:** The VM fetches 16-bit opcodes from the code segment, optionally loads extension words, decodes operation class, resolves operands (register, immediate, memory), executes, and updates `pc`.
- **Three-stage model:** *Fetch* (read opcode + ext words), *Decode* (determine opcode group, operand addressing), *Execute* (perform ALU/memory/syscall, update PSW). Pipeline is sequential; there is no speculative execution.
- **Endian & alignment:** Memory is little-endian; aligned 32-bit accesses are preferred, but unaligned word/halfword loads store the sane byte order for portability.

## Register Model
- **General registers:** 16 × 32-bit (`R0..R15`) arranged in a workspace; `R15` doubles as link register on call/return. Workspace pointer (`reg_base`) selects the active 16-word window.
- **Special registers:**
  - `pc` (program counter, byte address).
  - `psw` (flags: Z, C, N, V, E for error latch, plus interrupt mask).
  - `sp` (stack pointer) relative to `stack_base`.
  - `stack_base`, `stack_limit` define the stack arena.
- **Workspace pointer control:** Executive (or standalone host) updates `reg_base` to switch tasks. The VM exposes helpers `snapshot_context()` / `restore_context(ctx)` that only read/write metadata; register contents remain in RAM at addresses `reg_base + 4*n`.

## Memory Model
- **Segments:** Code (execute-only), read-only data, zero-initialised BSS, stack, and heap (optional). Each task has its own stack/heap; code and rodata may be shared if desired by the loader.
- **Address space:** 16-bit word addresses translated to byte addresses internally (`word_addr << 1`). Extended opcodes support 24-bit effective addresses for future large-memory profiles.
- **Alignment & access rules:** LD/ST instructions operate on 8/16/32-bit units; misaligned accesses trap with `HSX_ERR_ALIGN` so platform HALs can decide whether to emulate or fault.

## Instruction Encoding & Execution
- **Opcode format:** Primary 16-bit word: upper 6 bits = opcode group, next 4 bits = destination register, lower 6 bits = operand specifier. Extension words carry immediates, displacement, or literal data.
- **Categories:** ALU (ADD, SUB, AND, OR, XOR, SHIFT), compare/branch, load/store, control (CALL, RET, BRK, SVC), floating-point (FADD, FMUL, FCONV), system (SETPSW, GETPSW).
- **Execution invariants:**
  - All arithmetic updates `psw` (Z, N, C, V) unless the opcode explicitly suppresses flags (e.g., MOV.NF).
  - CALL pushes return address to stack (aligned 32-bit), updates `R15` with new frame pointer if required by ABI.
  - SVC/BRK cause the VM to pause execution after posting an event; the executive (or standalone HAL) must resume.
- **Implementation guidance:** Python VM decodes into callable dispatch table; C port should generate a jump table to maintain constant execution cost per opcode.

## Execution Modes
- **Attached mode:** Executive owns the clock. It calls `step(n)` to retire exactly `n` instructions per PID. Detached auto-loop is halted; time base is driven by host scheduling.
- **Standalone mode:** VM runs its own loop (`run_until(stop_condition)`), using an internal tick (µs resolution on MCU, simulated time on host). Syscalls are routed to HAL shims where available; unsupported traps raise `HSX_ERR_ENOSYS`.
- **Mode switching:** When an executive attaches, `MiniVM.attached = True` pauses the internal loop after the current instruction, hands control to the executive, and enables per-instruction event streaming. Detaching resumes internal clock with the last known tick delta.

## ABI & Calling Convention
- **Calling convention:**
  - Arguments 0–3 in `R0..R3`; return value in `R0`.
  - `R4..R7` caller-saved; `R8..R12` callee-saved; `R13` reserved for TLS pointer; `R14` frame pointer; `R15` link register.
  - Additional arguments spill to stack as 32-bit words (little-endian). Callee reads them via `SP + 16`.
  - Stack grows downward; 8-byte alignment maintained at call boundaries.
- **Prologue/Epilogue sequence:**
  1. Push saved registers (`R8..R12`) and prior `R15` if using frame pointer.
  2. Allocate local storage by decrementing `sp`.
  3. Restore in reverse order on return; pop return address into `pc` or use `RET`.
- **Varargs support:** `R0..R3` include count in `R0` (low 8 bits) when function flagged as varargs; callee walks stack for overflow arguments.

## Syscall Interface (SVC)
- **Trap entry:** `SVC #imm` places module/function in immediate (8-bit module, 8-bit function). `R0..R3` carry parameters; `psw.E` flag records error state returned from handler.
- **Return path:** HAL/executive writes result to `R0`, status in `psw.E` (0 success, 1 failure). Errors also encode canonical `HSX_ERR_*` IDs in upper 16 bits of `R0`.
- **Standalone behaviour:** When detached, a HAL shim resolves core services: stdio, timers, lightweight mailbox loopback. For advanced services (e.g., CAN provisioning) the shim returns `HSX_ERR_ENOSYS`.
- **Instrumenting events:** Each SVC generates `svc_call` and optional `svc_return` events; handlers set `payload = {module, function, args, rc}`.
- **Authoritative list:** `docs/abi_syscalls.md` enumerates modules; this design document summarises the ABI usage and ensures each module definition matches the spec.

## Context Switching & Workspace Management
- Executive stores per-task contexts: `{pc, psw, sp, stack_base, stack_limit, reg_base, sleep_until, wait_channel}`.
- Task switch algorithm:
  1. `snapshot_context()` writes CPU state into context struct (no register copies).
  2. Executive selects next PID, sets `reg_base`, `stack_base`, `sp`, `pc`, `psw`.
  3. Calls `resume()` or `step()` to continue.
- Register banks reside in contiguous RAM buffers allocated during task load. Retasking `reg_base` is O(1), which is the key design requirement for an eventual C port with tight SRAM budgets.

## Standalone Runtime Behaviour
- **Single-task loop:** `run()` fetches opcodes, executes, handles SVC via HAL shim, and exits when program sets `HSX_ERR_EXIT` or hits `BRK`.
- **I/O surfaces:** Minimal stdio and timer services exposed via HAL; mailbox operations degrade to local queues without multi-tasking.
- **Deterministic timing:** Optionally uses hardware timer interrupts to pace instruction retirement (e.g., 10 kHz). When instructions block on SVC lacking HAL support the VM returns error to application.

## Debug & Instrumentation
- **Breakpoints:** `BRK` opcode and software patching breakpoints inject a trap that emits `debug_break` with `pc`, `cause`.
- **Single-step:** `single_step_remaining` counter (set by executive) decrements each instruction; when zero, VM pauses and raises `debug_step`.
- **Register dumps:** Snapshot of workspace emitted on breaks when the executive requests `include_regs=true`.
- **Trace stream:** Optional trace flag causes each retired instruction to emit `trace_step` (opcode, operands, psw, reg diffs) for simulator validation.

## HAL Integration & Shims
- When the executive is absent, SVC handlers call into HAL modules (`04.08--HAL.md`) for UART, timers, persistent storage, etc.
- Attached mode defers to the executive, which itself uses the HAL for hardware access—ensuring a single source of truth for drivers.
- HAL exposes capability negotiation so the VM can query which services are locally available versus executive-provided; unsupported services trigger fallback or error.

## Testing Considerations
- ISA regression: assembler/compiler round-trips, reference traces vs. implementation.
- ABI compliance: call/return prologues, stack alignment checks, varargs stress.
- Syscall coverage: ensure return codes, error propagation, and HAL shims behave identically in standalone and attached modes.
- Context switch tests: repeated PID swaps, register integrity, wake-after-sleep while preserving workspace contents.
- Standalone stress: run repetitive workloads without executive to validate HAL shims and timing.

## Traceability
- **Design Requirements:** DR-1.3, DR-2.1, DR-2.1a, DR-2.2, DR-2.3, DR-3.1, DR-5.1, DR-5.2, DR-6.1, DR-7.1, DR-8.1.
- **Design Goals:** DG-1.3, DG-1.4, DG-2.1–2.4, DG-3.1–3.3, DG-4.1–4.3, DG-5.1–5.4, DG-6.1, DG-7.2.
- **Design Options:** DO-2.a, DO-VM-hotset, DO-VM-adaptive, DO-4.b.
