# Design Spec - MiniVM
# 04.01--VM Design (v3, repo style)
**Status:** DRAFT | **Date:** 2025-10-28 | **Owner:** HSX Core

> **Design stance:** The MiniVM is a dumb machine. It does no scheduling, performs no automatic context switching, and services no syscalls or HAL work on its own. It always runs under an executive that drives stepping, context selection, and externally managed debug (including breakpoints).

**Authoritative context (repo-local):**
- Architecture: [03.01--VM](../03--Architecture/03.01--VM.md), [03.00--Architecture](../03--Architecture/03.00--Architecture.md)
- Study & Requirements: [02--Study](../02--Study/02--Study.md), [02.01--Requirements](../02--Study/02.01--Requirements.md)
- Implementation-phase specs (normative inputs referenced by design):
  [docs/abi_syscalls.md](../../docs/abi_syscalls.md), [docs/MVASM_SPEC.md](../../docs/MVASM_SPEC.md),
  [docs/hxe_format.md](../../docs/hxe_format.md), [docs/executive_protocol.md](../../docs/executive_protocol.md),
  [docs/resource_budgets.md](../../docs/resource_budgets.md)

**Traceability (fill from 02.01--Requirements):** Refs DR[..], DG[..], DO[..].

## 1. Scope
- Implement the HSX instruction-set architecture (ISA) for a single task on both reference (Python) and embedded (C) targets without embedding an in-VM operating system (DR-2.1, DG-4.1).
- Provide deterministic execution with or without an attached executive so very small targets can run a single HSX program autonomously (DR-1.1, DG-1.4).
- Surface consistent debugging, trap, and syscall behaviour that the executive, tooling, and HAL layers can rely on (DR-8.1, DG-5.2, DG-8.1).

## 2. Preconditions
- Toolchain emits `.hxe` binaries with entry point and section metadata, plus optional symbol and line tables for debugging (DR-3.1, DG-3.3).
- Executive (when present) allocates per-task register and stack arenas, drives clocking, and routes syscalls or events through its RPC surface (DR-5.1, DG-5.3).
- HAL shims are available to handle a subset of syscalls locally when the executive is detached (see `04.08--HAL.md`) (DR-6.1, DG-6.1).

## 3. Postconditions
- MiniVM instances can be swapped between Python reference and C port without behavioural drift at the ISA, ABI, or syscall level (DR-1.3, DG-1.4).
- Tasks can be loaded, executed, paused, restarted, and context switched purely by adjusting workspace pointers and stacks; no whole-register copies are required (DR-2.1a, DG-4.1).

## 4. Architectural Overview

### 4.1 Execution Model
- Opcode format: primary 16-bit word with the upper 6 bits as opcode group, next 4 bits as destination register, and the lower 6 bits as operand specifier. Extension words carry immediates, displacements, or literal data.
- Opcode categories: arithmetic and logic (ADD, SUB, AND, OR, XOR, NOT), compare and branch, load/store, control transfer (CALL, RET, BRK, SVC), floating point helpers (FADD, FSUB, FMUL, FDIV, I2F, F2I), and system helpers (e.g., future SETPSW/GETPSW).
- Execution invariants:
  - Arithmetic instructions update the program status word (Z, N, C, V) unless the opcode explicitly suppresses flag writes.
  - CALL pushes the return address to the stack (aligned 32-bit), and updates `R15` as the link register when required by the ABI.
  - SVC and BRK pause instruction retirement after the result is recorded; the executive (or a standalone HAL shim) must explicitly resume execution.
- Implementation guidance: the Python VM decodes opcodes into a callable dispatch table; the C port should prefer a jump table or computed-goto model to keep per-opcode overhead constant.

### 4.2 Instruction Set
- Summary categories:
  - Data movement: LDI, LD, ST, MOV, byte and halfword variants, PUSH, POP, LDI32.
  - Integer ALU: ADD, SUB, MUL, DIV, AND, OR, XOR, NOT, CMP.
  - Control flow: JMP, JZ, JNZ, CALL, RET, BRK.
  - Floating point helpers: FADD, FSUB, FMUL, FDIV, I2F, F2I (operate on f16 payloads stored in 32-bit registers).
  - System services: SVC encodes module and function identifiers within the 12-bit immediate field.
- Opcode map:

| Opcode (hex) | Mnemonic | Meaning | Operand value types |
|--------------|----------|---------|---------------------|
| 0x01 | LDI | Load immediate | Rd:GPR32, Imm12:signed literal or reloc |
| 0x02 | LD | Load word | Rd:GPR32, [Rs:GPR32 + Imm12:signed byte offset] |
| 0x03 | ST | Store word | Mem32[Rs:GPR32 + Imm12:signed byte offset] <- Rt:GPR32 |
| 0x04 | MOV | Register move | Rd:GPR32, Rs:GPR32 |
| 0x06 | LDB | Load byte | Rd:GPR32, [Rs:GPR32 + Imm12:signed byte offset] (8-bit) |
| 0x07 | LDH | Load halfword | Rd:GPR32, [Rs:GPR32 + Imm12:signed byte offset] (16-bit) |
| 0x08 | STB | Store byte | Mem8[Rs:GPR32 + Imm12:signed byte offset] <- Rt:GPR32 |
| 0x09 | STH | Store halfword | Mem16[Rs:GPR32 + Imm12:signed byte offset] <- Rt:GPR32 |
| 0x10 | ADD | Integer add | Rd:GPR32, Rs:GPR32, Rt:GPR32 |
| 0x11 | SUB | Integer subtract | Rd:GPR32, Rs:GPR32, Rt:GPR32 |
| 0x12 | MUL | Integer multiply | Rd:GPR32, Rs:GPR32, Rt:GPR32 |
| 0x13 | DIV | Integer divide | Rd:GPR32, Rs:GPR32, Rt:GPR32 |
| 0x14 | AND | Bitwise AND | Rd:GPR32, Rs:GPR32, Rt:GPR32 |
| 0x15 | OR | Bitwise OR | Rd:GPR32, Rs:GPR32, Rt:GPR32 |
| 0x16 | XOR | Bitwise XOR | Rd:GPR32, Rs:GPR32, Rt:GPR32 |
| 0x17 | NOT | Bitwise NOT | Rd:GPR32, Rs:GPR32 |
| 0x20 | CMP | Compare | Rs:GPR32, Rt:GPR32 (updates PSW flags) |
| 0x21 | JMP | Unconditional jump | Imm12: zero-extended absolute PC target |
| 0x22 | JZ | Jump if zero | Imm12: zero-extended absolute PC target (taken if PSW.Z = 1) |
| 0x23 | JNZ | Jump if non-zero | Imm12: zero-extended absolute PC target (taken if PSW.Z = 0) |
| 0x24 | CALL | Call subroutine | Rs:GPR32 (optional base, 0 -> current PC), Imm12: signed word offset (scaled by 4) |
| 0x25 | RET | Return from subroutine | None |
| 0x30 | SVC | Supervisor call | Imm4: module, Imm8: function (packed in imm12) |
| 0x40 | PUSH | Push register | Rs:GPR32 |
| 0x41 | POP | Pop register | Rd:GPR32 |
| 0x50 | FADD | f16 add | Rd:GPR32 (f16 lower half), Rs:GPR32 (f16), Rt:GPR32 (f16) |
| 0x51 | FSUB | f16 subtract | Rd:GPR32 (f16 lower half), Rs:GPR32 (f16), Rt:GPR32 (f16) |
| 0x52 | FMUL | f16 multiply | Rd:GPR32 (f16 lower half), Rs:GPR32 (f16), Rt:GPR32 (f16) |
| 0x53 | FDIV | f16 divide | Rd:GPR32 (f16 lower half), Rs:GPR32 (f16), Rt:GPR32 (f16) |
| 0x54 | I2F | Int to f16 convert | Rd:GPR32 (f16 lower half), Rs:GPR32 (int32) |
| 0x55 | F2I | f16 to int convert | Rd:GPR32 (int32), Rs:GPR32 (f16 lower half) |
| 0x60 | LDI32 | Load 32-bit immediate | Rd:GPR32, Imm32 literal (follows opcode word) |
| 0x7F | BRK | Break/trap | Imm8: trap code (optional, default 0) |

### 4.3 Register Model
- General registers: 16 x 32-bit (`R0` through `R15`) arranged in a workspace window. `R15` doubles as the link register on call and return. The workspace pointer (`reg_base`) selects the active 16-word window in memory.
- Special registers:
  - `pc`: program counter (byte address).
  - `psw`: flags (Z, C, N, V) plus the error latch `E` and interrupt mask bits.
  - `sp`: stack pointer, relative to `stack_base`.
  - `stack_base` and `stack_limit`: delimit the active stack arena.
- Workspace pointer control: the executive (or standalone host) adjusts `reg_base` to switch tasks. VM helpers `snapshot_context()` and `restore_context(ctx)` only touch metadata; register contents remain in RAM at `reg_base + 4 * n`.

Register constant guidelines:

| Constant | Meaning |
|---|---|
| `REG_PC` = 0 | Program counter selector |
| `REG_SP` = 1 | Stack pointer selector |
| `REG_PSW` = 2 | Status and flags selector |
| `REG_WP` = 3 | Workspace pointer selector |
| `REG_R0` .. `REG_R15` = 16 .. 31 | General purpose registers windowed by `REG_WP` |

Task context structure (normative, VM-internal):

| Field | Type | Description |
|---|---|---|
| `pc` | u32 | Program counter (byte address) |
| `sp` | u32 | Stack pointer (VM stack) |
| `psw` | u32 | Processor status and flags |
| `wp` | u32 | Workspace pointer |
| `reg_base` | u32 | Base of register arena (for `R0` .. `R15` windows) |
| `stack_base` | u32 | Start of stack arena |
| `stack_limit` | u32 | Guard or limit address |
| `fault_code` | u16 | Latched fault (0 = none) |
| `pid` | u16 | Task identifier |

Invariant: `stack_base <= sp < stack_limit`. Context swaps only exchange `pc`, `sp`, `psw`, and `wp`.

### 4.4 Memory Model
- Segments: execute-only code, read-only data, zero-initialised BSS, stack, and optional heap. Each task owns its stack and heap; code and rodata may be shared by the loader.
- Address space: 16-bit word addresses translated to bytes internally (`word_addr << 1`). Extended opcodes allow 24-bit effective addresses for future large-memory profiles.
- Alignment and access rules: load and store instructions operate on 8-, 16-, and 32-bit units. Misaligned accesses raise `HSX_ERR_ALIGN` so platform HALs can emulate or fault as appropriate.
- Layout options:
  - Code: read-only, optionally pageable (for example, external FRAM or flash with a RAM cache).
  - Data and heap: read and write, optional software paging with fixed-size pages.
  - Stack: pinned region per task.
- Code paging (design option):
  - Double-buffer 256-512 byte lines; prefetch near the end of each line and abort or realign on far jumps.
  - Apply decode-assisted look-ahead for likely branch or call targets.
- Data paging (design option):
  - Maintain a 2-4 entry TLB with classes for pinned (stack, IPC), read-only (globals), and read-write (heap) regions, plus a `VMEM.FLUSH()` hint for write-back.
  - Split cross-page reads and writes explicitly; use a critical section when forced to emulate atomic word stores.

### 4.5 Execution Modes
- Attached mode: the executive owns the clock and calls `step(n)` to retire exactly `n` instructions per PID. The detached auto-loop is halted and the executive observes progress strictly through `StepResult`.
- Standalone mode: the VM drives its own loop (`run_until(stop_condition)`), using an internal tick (microsecond resolution on MCU, simulated time on host). Syscalls route to HAL shims where available; unsupported services return `HSX_ERR_ENOSYS`.
- Mode switching: when an executive attaches, `MiniVM.attached = True` pauses the internal loop after the current instruction and hands control to the executive; there is no VM-side event queue to service. Detaching resumes the internal clock with the last observed tick delta.

### 4.6 ABI and Calling Convention
- Calling convention:
  - Arguments 0-3 reside in `R0`..`R3`; return values use `R0`.
  - `R4`..`R7` are caller-saved; `R8`..`R12` are callee-saved; `R13` is reserved for a TLS pointer; `R14` is the frame pointer; `R15` is the link register.
  - Additional arguments spill to the stack as 32-bit words (little-endian). The callee reads overflow parameters at `SP + 16` and beyond.
  - The stack grows downward and stays 8-byte aligned at call boundaries.
- Prologue and epilogue sequence:
  1. Push callee-saved registers (`R8`..`R12`) and the prior `R15` if keeping a frame pointer.
  2. Allocate local storage by decrementing `sp`.
  3. Restore in reverse order on return; pop the return address into `pc` or use `RET`.
- Varargs support: for functions flagged as variadic, `R0` carries the argument count in its low 8 bits; the callee walks the stack for overflow arguments.

### 4.7 Syscall Interface (SVC)
- Trap entry: `SVC #imm` encodes module (upper 4 bits) and function (lower 8 bits) within the 12-bit immediate. `R0`..`R3` carry parameters and `psw.E` records handler status.
- Return path: the HAL or executive writes the result to `R0` and clears or sets `psw.E` (0 for success, 1 for failure). Errors also encode canonical `HSX_ERR_*` identifiers in the upper 16 bits of `R0`.
- Standalone behaviour: when detached, a HAL shim resolves core services such as stdio, timers, and lightweight mailbox loopback. Advanced services (for example CAN provisioning) may return `HSX_ERR_ENOSYS`.
- Instrumentation is supplied by the executive: the VM exposes trap outcomes through `StepResult` and register state only.
- Authoritative list: `docs/abi_syscalls.md` enumerates modules and functions; this design document summarises their usage to cross-check implementation.

### 4.8 Context Switching and Workspace Management
- The executive stores per-task contexts containing `{pc, psw, sp, stack_base, stack_limit, reg_base, sleep_until, wait_channel}`.
- Task switch algorithm:
  1. `snapshot_context()` writes CPU state into the context struct without copying register banks.
  2. The executive selects the next PID and programs `reg_base`, `stack_base`, `sp`, `pc`, and `psw`.
  3. `resume()` or `step()` continues execution for the selected task.
- Register banks reside in contiguous RAM buffers allocated at task load. Retasking `reg_base` is O(1), satisfying SRAM constraints for the C port.

### 4.9 Performance and Resource Targets

| Target | Metric | Initial target |
|---|---|---|
| Context switch | Overhead | O(1) swap of `pc`, `sp`, `psw`, `wp` |
| Step throughput | Instructions per second (M4 @ 48 MHz) | 2-4 M instr/s (design goal) |
| Code cache line | Bytes | 256-512 B |
| Data TLB | Entries | 2-4 |
| RAM budget | Bytes | See [resource_budgets.md](../../docs/resource_budgets.md) |

## 5. Runtime Behaviour (Standalone)
- Single-task loop: `run()` fetches opcodes, executes them, dispatches SVC calls via the HAL shim, and exits when the program sets `HSX_ERR_EXIT` or executes `BRK`.
- I/O surfaces: provide minimal stdio and timer services via the HAL; mailbox operations degrade to local queues when multitasking is absent.
- Deterministic timing: optionally use hardware timer interrupts to pace instruction retirement (for example 10 kHz). When instructions block on unsupported SVC modules the VM returns an error to the application.

## 6. External Interfaces
> The executive owns the control plane. The VM exposes a narrow API for orchestration plus traps for service requests and debug signalling.

### 6.1 Control-plane API (host-side calls into the VM)

| API | Args | Returns | Notes |
|---|---|---|---|
| `vm_init(mem_cfg)` | Page sizes, cache configuration, allocation hooks, optional `autorun_quanta` | `rc` | Configure paging and arenas |
| `vm_load_hxe(hxe_ptr, len)` | Descriptor for verified `.hxe` | `pid`, `rc` | Load one task and allocate arenas |
| `vm_unload(pid)` | `pid` | `rc` | Free arenas and context |
| `vm_pids()` | - | `list[int]` | Enumerate resident tasks |
| `vm_set_context(pid)` | `pid` | `rc` | Make `pid` active without implicit swap |
| `vm_step()` | - | `StepResult` | Retire exactly one instruction (or up to `autorun_quanta` when enabled) |
| `vm_clock(n)` | `n` (int) | `StepResult` | Retire `n` instructions or stop on SVC, break, or fault |
| `vm_reg_get(reg_id)` | Constant selector | `u32` | Read register in the active context |
| `vm_reg_set(reg_id, value)` | Constant selector, `u32` | `rc` | Write register in the active context (policy gated) |
| `vm_reg_get_for(pid, reg_id)` | `pid`, constant selector | `u32` | Optional helper to read without context switch |
| `vm_reg_set_for(pid, reg_id, value)` | `pid`, constant selector, `u32` | `rc` | Optional helper to write without context switch |

`StepResult` includes the fields `pc`, `reason` in `{ok, break, fault, svc}`, optional `svc_id`, and `cycles_est`.

Notes:
- Breakpoints are enforced by the executive. The VM surfaces `BRK` traps but does not maintain breakpoint tables.
- Autorun behaviour can be achieved via repeated `vm_clock(n)` calls or by passing `autorun_quanta` at init; default behaviour is single-step retirement for determinism.

### 6.2 Trap Interface (VM to Executive)
- SVC: VM raises the trap and the executive dispatches to module handlers (mailbox, value, command, provisioning, HAL proxies, and so on).
- BRK: VM halts with `reason = break` when guest code executes `BRK`; the executive decides how to resume or inspect state.
- Faults: illegal instruction, bounds errors, and misaligned accesses map to executive events for policy decisions.

Time base: in attached mode the executive scheduler defines cadence. SVC timeouts express microseconds or ticks as defined in [abi_syscalls.md](../../docs/abi_syscalls.md).

## 7. Observability and Instrumentation
- Breakpoint handling lives in the executive. The VM simply reports `BRK` traps so the executive can manage breakpoints and resume logic.
- Single-step support uses a counter set by the executive; the VM decrements it each retired instruction and halts with a `step` reason at zero.
- Register dumps: the VM can snapshot the active workspace on request so the executive can surface register state during pauses.
- Trace stream: optional tracing emits each retired instruction with opcode, operands, PSW, and register deltas for simulator validation.

## 8. Executive Integration
- MiniVM always executes under an executive. Even the smallest deployment couples the VM to a "mini-executive" that loads images, clocks the core, and services the SVC modules that firmware requires; a bare VM without an executive is unsupported.
- Executive variants share one codebase with compile-time feature switches (e.g., syscall subsets, debugging tools, multitasking). Builds can trim features to reduce RAM/flash while preserving the same VM ABI.
- All HAL access flows through the executive. The VM links no local shims, avoiding duplicated drivers and keeping the VM footprint minimal on constrained MCUs.

## 9. Testing Strategy
- ISA regression: assembler and compiler round-trips plus reference trace comparisons.
- ABI compliance: call and return prologues, stack alignment validation, and varargs stress cases.
- Syscall coverage: confirm return codes and error propagation across minimal and full executive configurations (feature flags on/off).
- Context switch tests: repeated PID swaps, register integrity checks, and wake-after-sleep scenarios while preserving workspace contents.
- Minimal-executive stress: run repetitive workloads with features stripped (no debugging, limited SVC set) to validate timing and resource budgets.

## 10. Verification
- See [MiniVM_tests.md](../06--Test/system/MiniVM_tests.md).
- Contract coverage: context swap O(1), SVC and BRK semantics, illegal opcode handling, and bounds enforcement.
- Behavioural coverage: paging (sequential, far jump, abort), data miss, evict, and flush paths.
- Limits: RAM budgets and step throughput smoke tests.

## 11. Traceability
- Design Requirements: DR-1.3, DR-2.1, DR-2.1a, DR-2.2, DR-2.3, DR-3.1, DR-5.1, DR-5.2, DR-6.1, DR-7.1, DR-8.1.
- Design Goals: DG-1.3, DG-1.4, DG-2.1 through DG-2.4, DG-3.1 through DG-3.3, DG-4.1 through DG-4.3, DG-5.1 through DG-5.4, DG-6.1, DG-7.2.
- Design Options: DO-2.a, DO-VM-hotset, DO-VM-adaptive, DO-4.b.
