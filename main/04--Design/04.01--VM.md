# Design Spec - MiniVM
# 04.01--VM Design (v3, repo style)
**Status:** DRAFT | **Date:** 2025-10-28 | **Owner:** HSX Core

> **Design stance:** The MiniVM is a dumb machine. It does no scheduling, performs no automatic context switching, and services no syscalls or HAL work on its own. It always runs under an executive that drives stepping, context selection, and externally managed debug (including breakpoints).

**Authoritative context (repo-local):**
- Architecture: [03.01--VM](../03--Architecture/03.01--VM.md), [03.00--Architecture](../03--Architecture/03.00--Architecture.md)
- Study & Requirements: [02--Study](../02--Study/02--Study.md), [02.01--Requirements](../02--Study/02.01--Requirements.md)
- Implementation-phase specs (normative inputs referenced by design):
  [docs/abi_syscalls.md](../../docs/abi_syscalls.md), [docs/MVASM_SPEC.md](../../docs/MVASM_SPEC.md),
  [docs/hxe_format.md](../../docs/hxe_format.md), [docs/executive_protocol.md](../../docs/executive_protocol.md),
  [docs/resource_budgets.md](../../docs/resource_budgets.md)

**Traceability (fill from 02.01--Requirements):** Refs DR[..], DG[..], DO[..].

## 1. Scope
- Implement the HSX instruction-set architecture (ISA) for a single task on both reference (Python) and embedded (C) targets without embedding an in-VM operating system (DR-2.1, DG-4.1).
- Provide deterministic execution with or without an attached executive so very small targets can run a single HSX program autonomously (DR-1.1, DG-1.4).
- Surface consistent debugging, trap, and syscall behaviour that the executive, tooling, and HAL layers can rely on (DR-8.1, DG-5.2, DG-8.1).

## 2. Preconditions
- Toolchain emits `.hxe` binaries with entry point and section metadata, plus optional symbol and line tables for debugging (DR-3.1, DG-3.3).
- Executive (when present) allocates per-task register and stack arenas, drives clocking, and routes syscalls or events through its RPC surface (DR-5.1, DG-5.3).
- HAL shims are available to handle a subset of syscalls locally when the executive is detached (see `04.08--HAL.md`) (DR-6.1, DG-6.1).

## 3. Postconditions
- MiniVM instances can be swapped between Python reference and C port without behavioural drift at the ISA, ABI, or syscall level (DR-1.3, DG-1.4).
- Tasks can be loaded, executed, paused, restarted, and context switched purely by adjusting workspace pointers and stacks; no whole-register copies are required (DR-2.1a, DG-4.1).

## 4. Architectural Overview

### 4.1 Execution Model
- Opcode format: primary 16-bit word with the upper 6 bits as opcode group, next 4 bits as destination register, and the lower 6 bits as operand specifier. Extension words carry immediates, displacements, or literal data.
- Opcode categories: arithmetic and logic (ADD, SUB, AND, OR, XOR, NOT), compare and branch, load/store, control transfer (CALL, RET, BRK, SVC), floating point helpers (FADD, FSUB, FMUL, FDIV, I2F, F2I), and system helpers (e.g., future SETPSW/GETPSW).
- Execution invariants:
  - Arithmetic instructions update the program status word (Z, N, C, V) unless the opcode explicitly suppresses flag writes.
  - CALL pushes the return address to the stack (aligned 32-bit), and updates `R15` as the link register when required by the ABI.
  - SVC and BRK pause instruction retirement after the result is recorded; the executive (or a standalone HAL shim) must explicitly resume execution.
- Implementation guidance: the Python VM decodes opcodes into a callable dispatch table; the C port should prefer a jump table or computed-goto model to keep per-opcode overhead constant.

### 4.2 Instruction Set
- Summary categories:
  - Data movement: LDI, LD, ST, MOV, byte and halfword variants, PUSH, POP, LDI32.
  - Integer ALU: ADD, SUB, MUL, DIV, AND, OR, XOR, NOT, CMP.
  - Control flow: JMP, JZ, JNZ, CALL, RET, BRK.
  - Floating point helpers: FADD, FSUB, FMUL, FDIV, I2F, F2I (operate on f16 payloads stored in 32-bit registers).
  - System services: SVC encodes module and function identifiers within the 12-bit immediate field.
- Opcode map:

| Opcode (hex) | Mnemonic | Meaning | Operand value types |
|--------------|----------|---------|---------------------|
| 0x01 | LDI | Load immediate | Rd:GPR32, Imm12:signed literal or reloc |
| 0x02 | LD | Load word | Rd:GPR32, [Rs:GPR32 + Imm12:signed byte offset] |
| 0x03 | ST | Store word | Mem32[Rs:GPR32 + Imm12:signed byte offset] <- Rt:GPR32 |
| 0x04 | MOV | Register move | Rd:GPR32, Rs:GPR32 |
| 0x06 | LDB | Load byte | Rd:GPR32, [Rs:GPR32 + Imm12:signed byte offset] (8-bit) |
| 0x07 | LDH | Load halfword | Rd:GPR32, [Rs:GPR32 + Imm12:signed byte offset] (16-bit) |
| 0x08 | STB | Store byte | Mem8[Rs:GPR32 + Imm12:signed byte offset] <- Rt:GPR32 |
| 0x09 | STH | Store halfword | Mem16[Rs:GPR32 + Imm12:signed byte offset] <- Rt:GPR32 |
| 0x10 | ADD | Integer add | Rd:GPR32, Rs:GPR32, Rt:GPR32 |
| 0x11 | SUB | Integer subtract | Rd:GPR32, Rs:GPR32, Rt:GPR32 |
| 0x12 | MUL | Integer multiply | Rd:GPR32, Rs:GPR32, Rt:GPR32 |
| 0x13 | DIV | Integer divide | Rd:GPR32, Rs:GPR32, Rt:GPR32 |
| 0x14 | AND | Bitwise AND | Rd:GPR32, Rs:GPR32, Rt:GPR32 |
| 0x15 | OR | Bitwise OR | Rd:GPR32, Rs:GPR32, Rt:GPR32 |
| 0x16 | XOR | Bitwise XOR | Rd:GPR32, Rs:GPR32, Rt:GPR32 |
| 0x17 | NOT | Bitwise NOT | Rd:GPR32, Rs:GPR32 |
| 0x20 | CMP | Compare | Rs:GPR32, Rt:GPR32 (updates PSW flags) |
| 0x21 | JMP | Unconditional jump | Imm12: zero-extended absolute PC target |
| 0x22 | JZ | Jump if zero | Imm12: zero-extended absolute PC target (taken if PSW.Z = 1) |
| 0x23 | JNZ | Jump if non-zero | Imm12: zero-extended absolute PC target (taken if PSW.Z = 0) |
| 0x24 | CALL | Call subroutine | Rs:GPR32 (optional base, 0 -> current PC), Imm12: signed word offset (scaled by 4) |
| 0x25 | RET | Return from subroutine | None |
| 0x30 | SVC | Supervisor call | Imm4: module, Imm8: function (packed in imm12) |
| 0x40 | PUSH | Push register | Rs:GPR32 |
| 0x41 | POP | Pop register | Rd:GPR32 |
| 0x50 | FADD | f16 add | Rd:GPR32 (f16 lower half), Rs:GPR32 (f16), Rt:GPR32 (f16) |
| 0x51 | FSUB | f16 subtract | Rd:GPR32 (f16 lower half), Rs:GPR32 (f16), Rt:GPR32 (f16) |
| 0x52 | FMUL | f16 multiply | Rd:GPR32 (f16 lower half), Rs:GPR32 (f16), Rt:GPR32 (f16) |
| 0x53 | FDIV | f16 divide | Rd:GPR32 (f16 lower half), Rs:GPR32 (f16), Rt:GPR32 (f16) |
| 0x54 | I2F | Int to f16 convert | Rd:GPR32 (f16 lower half), Rs:GPR32 (int32) |
| 0x55 | F2I | f16 to int convert | Rd:GPR32 (int32), Rs:GPR32 (f16 lower half) |
| 0x60 | LDI32 | Load 32-bit immediate | Rd:GPR32, Imm32 literal (follows opcode word) |
| 0x7F | BRK | Break/trap | Imm8: trap code (optional, default 0) |

### 4.3 Register Model
- General registers: 16 x 32-bit (`R0` through `R15`) arranged in a workspace window. `R15` doubles as the link register on call and return. The workspace pointer (`reg_base`) selects the active 16-word window in memory.
- Special registers:
  - `pc`: program counter (byte address).
  - `psw`: flags (Z, C, N, V) plus the error latch `E` and interrupt mask bits.
  - `sp`: stack pointer, relative to `stack_base`.
  - `stack_base` and `stack_limit`: delimit the active stack arena.
- Workspace pointer control: the executive (or standalone host) adjusts `reg_base` to switch tasks. VM helpers `snapshot_context()` and `restore_context(ctx)` only touch metadata; register contents remain in RAM at `reg_base + 4 * n`.

Register constant guidelines:

| Constant | Meaning |
|---|---|
| `REG_PC` = 0 | Program counter selector |
| `REG_SP` = 1 | Stack pointer selector |
| `REG_PSW` = 2 | Status and flags selector |
| `REG_WP` = 3 | Workspace pointer selector |
| `REG_R0` .. `REG_R15` = 16 .. 31 | General purpose registers windowed by `REG_WP` |

Task context structure (normative, VM-internal):

| Field | Type | Description |
|---|---|---|
| `pc` | u32 | Program counter (byte address) |
| `sp` | u32 | Stack pointer (VM stack) |
| `psw` | u32 | Processor status and flags |
| `wp` | u32 | Workspace pointer |
| `reg_base` | u32 | Base of register arena (for `R0` .. `R15` windows) |
| `stack_base` | u32 | Start of stack arena |
| `stack_limit` | u32 | Guard or limit address |
| `fault_code` | u16 | Latched fault (0 = none) |
| `pid` | u16 | Task identifier |

Invariant: `stack_base <= sp < stack_limit`. Context swaps only exchange `pc`, `sp`, `psw`, and `wp`.

### 4.4 Memory Model
- Segments: execute-only code, read-only data, zero-initialised BSS, stack, and optional heap. Each task owns its stack and heap; code and rodata may be shared by the loader.
- Address space: 16-bit word addresses translated to bytes internally (`word_addr << 1`). Extended opcodes allow 24-bit effective addresses for future large-memory profiles.
- Alignment and access rules: load and store instructions operate on 8-, 16-, and 32-bit units. Misaligned accesses raise `HSX_ERR_ALIGN` so platform HALs can emulate or fault as appropriate.
- Layout options:
  - Code: read-only, optionally pageable (for example, external FRAM or flash with a RAM cache).
  - Data and heap: read and write, optional software paging with fixed-size pages.
  - Stack: pinned region per task.
- Code paging (design option):
  - Double-buffer 256-512 byte lines; prefetch near the end of each line and abort or realign on far jumps.
  - Apply decode-assisted look-ahead for likely branch or call targets.
- Data paging (design option):
  - Maintain a 2-4 entry TLB with classes for pinned (stack, IPC), read-only (globals), and read-write (heap) regions, plus a `VMEM.FLUSH()` hint for write-back.
  - Split cross-page reads and writes explicitly; use a critical section when forced to emulate atomic word stores.

### 4.5 Execution Modes
**Production mode (executive-driven):**
The VM always runs under executive control. The executive owns the clock and calls `step(n)` to retire exactly `n` instructions per PID. The executive observes progress strictly through `StepResult` and handles all syscall traps. This is the only supported production mode.

**Development/test mode (standalone):**
For basic VM testing and development, the VM can be run without an executive. In this mode, the VM drives its own loop (`run_until(stop_condition)`), and syscalls either trap (returning `HSX_ERR_ENOSYS`) or route to minimal HAL shims. This mode is useful for ISA validation and unit testing but is not intended for production use. HXE applications requiring executive services (mailbox, values, commands, provisioning) cannot run in standalone mode.

The `MiniVM.attached` flag tracks whether an executive is present. In production, this should always be `True`.

### 4.6 ABI and Calling Convention
- Calling convention:
  - Arguments 0-3 reside in `R0`..`R3`; return values use `R0`.
  - `R4`..`R7` are caller-saved; `R8`..`R12` are callee-saved; `R13` is reserved for a TLS pointer; `R14` is the frame pointer; `R15` is the link register.
  - Additional arguments spill to the stack as 32-bit words (little-endian). The callee reads overflow parameters at `SP + 16` and beyond.
  - The stack grows downward and stays 8-byte aligned at call boundaries.
- Prologue and epilogue sequence:
  1. Push callee-saved registers (`R8`..`R12`) and the prior `R15` if keeping a frame pointer.
  2. Allocate local storage by decrementing `sp`.
  3. Restore in reverse order on return; pop the return address into `pc` or use `RET`.
- Varargs support: for functions flagged as variadic, `R0` carries the argument count in its low 8 bits; the callee walks the stack for overflow arguments.

### 4.7 Syscall Interface (SVC)
- Trap entry: `SVC #imm` encodes module (upper 4 bits) and function (lower 8 bits) within the 12-bit immediate. `R0`..`R3` carry parameters and `psw.E` records handler status.
- Return path: the HAL or executive writes the result to `R0` and clears or sets `psw.E` (0 for success, 1 for failure). Errors also encode canonical `HSX_ERR_*` identifiers in the upper 16 bits of `R0`.
- Standalone behaviour: when detached, a HAL shim resolves core services such as stdio, timers, and lightweight mailbox loopback. Advanced services (for example CAN provisioning) may return `HSX_ERR_ENOSYS`.
- Instrumentation is supplied by the executive: the VM exposes trap outcomes through `StepResult` and register state only.
- Authoritative list: `docs/abi_syscalls.md` enumerates modules and functions; this design document summarises their usage to cross-check implementation.

### 4.8 Context Switching and Workspace Management
**VM-owned context state:**
The VM internally stores per-task contexts containing `{pc, psw, sp, stack_base, stack_limit, reg_base, sleep_until, wait_channel}`. This context state is private to the VM and not directly accessible to the executive, ensuring security and proper encapsulation.

**Context switching interface:**
- Executive calls `vm_set_context(pid)` to switch to a different task
- VM handles all context swapping internally:
  1. Saves current task's CPU state (PC, PSW, SP, register workspace pointer)
  2. Loads the selected PID's context
  3. Updates internal `reg_base` to point to the task's register workspace
- Executive never directly manipulates PC, SP, or register values during normal operation
- Register banks reside in contiguous RAM buffers allocated at task load
- Workspace pointer (`reg_base`) swapping is O(1), satisfying SRAM constraints for the C port

**Security boundary:**
The workspace pointer (WP/`reg_base`) remains VM-internal and is never exposed externally. This prevents:
- Accidental or malicious corruption of task register state
- Executive or external code from directly accessing task workspaces
- Cross-task register leakage or interference

**Debug mode exception:**
Debug executives may use `vm_reg_set()` to modify PC/SP/registers for debugging purposes. This access is policy-gated and disabled in production builds.

### 4.9 Performance and Resource Targets

| Target | Metric | Initial target |
|---|---|---|
| Context switch | Overhead | O(1) swap of `pc`, `sp`, `psw`, `wp` |
| Step throughput | Instructions per second (M4 @ 48 MHz) | 2-4 M instr/s (design goal) |
| Code cache line | Bytes | 256-512 B |
| Data TLB | Entries | 2-4 |
| RAM budget | Bytes | See [resource_budgets.md](../../docs/resource_budgets.md) |

## 5. Runtime Behaviour (Development/Test Standalone Mode)
**Note:** Standalone mode is for VM development and testing only. Production deployments always use an executive.

When run without an executive (development/test only):
- Single-task loop: `run()` fetches opcodes, executes them, and exits when the program executes `BRK` or reaches a syscall that requires an executive.
- Minimal I/O shims: basic stdio may be provided via HAL stubs for testing. Most syscalls return `HSX_ERR_ENOSYS`.
- No multitasking: mailbox operations, value/command services, and provisioning are unavailable.
- Deterministic timing: optionally use hardware timer interrupts to pace instruction retirement (for example 10 kHz) for testing purposes.

This mode is useful for ISA validation, opcode testing, and basic functionality checks, but HXE applications requiring executive services cannot run standalone.

## 6. External Interfaces
> The executive owns the control plane. The VM exposes a narrow API for orchestration plus traps for service requests and debug signalling.

### 6.1 Control-plane API (host-side calls into the VM)

The host executive is responsible for delivering HSX application binaries into the VM. 

MiniVM does not embed a filesystem and has no knowledge of transports such as CAN or UART. Instead, the host executive delivers HSX application binaries (`.hxe`) via a loader interface—typically through `vm_load_hxe()` or a streaming variant.

As HXE bytes arrive, the VM allocates a new task arena, assigns a unique PID, and initializes the workspace pointer. Payload bytes are written directly into the code and data regions without requiring the executive to buffer the full image in memory. This model supports low-RAM targets and enables lightweight transfers over constrained links like CAN.

The VM performs streaming validation as data is received. It can reject malformed headers or sections early, emitting an error code before the full file is consumed. Upon successful transfer, it performs a final integrity check (e.g. CRC), and if valid, marks the task ready for execution.

### 6.1 Control-plane API (host-side calls into VM)

MiniVM owns only “probe + execute.” It does not know about filesystems or transports (CAN/UART/etc.). HXE payloads are supplied by the Executive through this control-plane API. Two loading modes are supported:

- **Monolithic load** via `vm_load_hxe(hxe_ptr,len)` when the full HXE is already resident in host memory.
- **Streaming load** via `vm_load_{begin,write,end,abort}` for byte-by-byte ingestion (ideal for low-RAM targets and direct CAN/serial ingestion).

#### 6.1.1 API summary

| API                            | Args                                     | Returns            | Errors (examples)                      | Notes                                                                 |
|--------------------------------|------------------------------------------|--------------------|----------------------------------------|------------------------------------------------------------------------|
| `vm_init(mem_cfg)`             | `mem_cfg` (see *6.1.4*)                  | `rc`               | `EINVAL`, `ENOSPC`                     | (Re)initialise VM; configure optional paging/cache; set `autorun_quanta` (default **1**). Baseline must work with all options off. |
| `vm_load_hxe`                  | `hxe_ptr, len`                           | `pid, rc`          | `EBADMSG`, `ENOSPC`, `EIO`             | Monolithic load: allocate arenas, create PID, map code/rodata, init `.data/.bss`, init `WP`. |
| `vm_load_begin`                | —                                        | `pid, rc`          | `ENOSPC`, `EBUSY`                      | Start streaming mode: allocate arenas, create PID, enter `LOADING` state.                     |
| `vm_load_write`                | `pid, chunk*, n`                         | `rc`               | `EBADMSG`, `ESRCH`, `EBUSY`            | Append `n` bytes into PID’s code/data areas; early reject on bad header/sections; accumulate CRC. |
| `vm_load_end`                  | `pid`                                    | `rc`               | `EBADMSG`, `ESRCH`                     | Finalise: validate header/sections and final CRC; transition PID to `READY` on success.       |
| `vm_load_abort`                | `pid`                                    | `rc`               | `ESRCH`                                 | Abort streaming; tear down arenas and free PID.                                               |
| `vm_unload`                    | `pid`                                    | `rc`               | `ESRCH`                                 | Free arenas/context; invalidate PID.                                                          |
| `vm_pids`                      | —                                        | `list<int>`        | —                                      | Enumerate active PIDs (states may include `READY/BLOCKED/STOPPED/LOADING`).                   |
| `vm_set_context`               | `pid`                                    | `rc`               | `ESRCH`                                 | Select active PID. **VM never auto-switches context.**                                        |
| `vm_step`                      | —                                        | `StepResult`       | —                                      | Retires **one** instruction (or up to `autorun_quanta`).                                      |
| `vm_clock`                     | `n`                                      | `StepResult`       | `ETIMEDOUT?`                           | Retires up to `n` instructions; stops on `svc/break/fault`.                                   |
| `vm_reg_get`                   | `reg_id`                                 | `u32`              | `EINVAL`                                | Read register in **active** context (includes `PC/SP/PSW/WP`, `R0..R15`).                     |
| `vm_reg_set`                   | `reg_id, value`                          | `rc`               | `EINVAL`, `EPERM`                      | Write register in **active** context (policy gated by Executive).                             |
| `vm_reg_get_for` *(optional)*  | `pid, reg_id`                            | `u32`              | `ESRCH`, `EINVAL`                      | Read register for given PID without changing active context.                                  |
| `vm_reg_set_for` *(optional)*  | `pid, reg_id, value`                     | `rc`               | `ESRCH`, `EINVAL`, `EPERM`             | Write register for given PID without changing active context.                                 |
| `vm_mem_read`                  | `addr, len`                              | `bytes/rc`         | `EFAULT`                                | Bounds-checked read from active PID’s arena.                                                  |
| `vm_mem_write`                 | `addr, buf*`                             | `rc`               | `EFAULT`, `EPERM`                      | Bounds-checked write into active PID’s arena (policy gated by Executive).                     |

*`chunk*`/`buf*` are host pointers to contiguous octet buffers.

**Trace accessor APIs (for executive-side trace):**
- `vm_get_last_pc()` → `u32`: Returns PC of last executed instruction
- `vm_get_last_opcode()` → `u32`: Returns instruction word of last executed instruction
- `vm_get_last_regs()` → `regs[16]`: Returns register snapshot before last instruction (debug builds only)

These APIs allow the executive to read the VM's minimal trace state after each `vm_step()` or `vm_clock()` call. The executive stores trace records in its own buffers, sized according to variant (minimal, development, full debugger).

**StepResult fields:** `pc`, `reason ∈ { ok, break, fault, svc }`, optional `svc_id`, optional `events_emitted`, optional `cycles_est`.

**Breakpoints:** enforced **only** by the Executive. The VM surfaces `BRK` traps (when present in bytecode) but does not maintain breakpoint tables.

**Autorun:** use repeated `vm_clock(n)` or pass `autorun_quanta` to `vm_init` (default `1` for deterministic single-instruction stepping).

---

#### 6.1.2 Loader model (streaming)

- **Begin/Write/End/Abort** provide byte-granularity ingestion into a fresh PID’s arenas.  
- **Early rejection:** `vm_load_write` performs incremental header/section checks and CRC accumulation; malformed data is rejected immediately (no need to buffer full HXE in host RAM).  
- **Finalisation:** `vm_load_end` completes header/section validation and final CRC check, then marks the PID `READY`.  
- **Failure path:** `vm_load_abort` must reclaim all transient allocations and remove the PID.

This model enables direct ingestion from constrained transports (e.g. CAN/UART) and supports very small RAM footprints.

---

#### 6.1.3 Function semantics (preconditions/effects/errors)

- **`vm_init(mem_cfg)`**  
  *Pre:* VM may be uninitialised or resettable.  
  *Effect:* Clears all internal state (PIDs/arenas), applies `mem_cfg` (see below), sets `autorun_quanta` (default `1`). Must operate correctly even if paging/cache options are disabled.  
  *Errors:* `EINVAL` (bad profile), `ENOSPC` (insufficient base memory).

- **`vm_load_hxe(hxe_ptr,len)`** (monolithic)  
  *Pre:* `hxe_ptr` references a complete, verifiable HXE.  
  *Effect:* Allocates arenas; creates PID; maps code/rodata; prepares `.data/.bss`; initialises `WP`.  
  *Errors:* `EBADMSG` (header/CRC/sections invalid), `ENOSPC`, `EIO`.

- **`vm_load_begin` / `vm_load_write` / `vm_load_end` / `vm_load_abort`** (streaming)  
  *Pre:* `begin` requires capacity; `write/end` require PID in `LO/ADING`.  
  *Effect:* Byte-wise ingest with early header/section checks and CRC accumulation; `end` validates final state; `abort` tears down allocations.  
  *Errors:* `EBADMSG`, `ENOSPC`, `ESRCH`, `EBUSY` (wrong PID state).

- **`vm_set_context(pid)`**  
  *Pre:* PID exists.  
  *Effect:* Selects active PID; VM never switches context implicitly.  
  *Errors:* `ESRCH`.

- **`vm_step` / `vm_clock(n)`**  
  *Pre:* An active PID exists.  
  *Effect:* Retire 1 (or up to `autorun_quanta`) / up to `n` instructions; stop on `svc/break/fault`.  
  *Errors/Result:* `StepResult.reason` ∈ `{ ok, break, fault, svc }`; `ETIMEDOUT` is permitted if a time budget is enforced by the caller.

- **`vm_reg_*`, `vm_mem_*`**  
  *Pre:* For “_for” variants, PID must exist; otherwise active PID required. Writes are policy-gated by the Executive.  
  *Effect:* Read/Write registers (including `PC/SP/PSW/WP` and `R0..R15`) and bounded memory windows.  
  *Errors:* `ESRCH`, `EINVAL`, `EFAULT`, `EPERM`.

---

#### 6.1.4 `mem_cfg` (baseline + optional tuning)

`mem_cfg` is an extensible, versioned struct. **Baseline must run with all knobs off.** Suggested fields:

- `code_line_bytes` *(uint, optional)* — code cache line size (e.g. 256/512).  
- `data_page_bytes` *(uint, optional)* — data page size when data-paging is enabled.  
- `autorun_quanta` *(uint, default=1)* — max retired instructions per `vm_step`.  
- `alloc_hooks` *(ptrs, optional)* — host-provided arena alloc/free.  
- `limits.{ max_pids, code_max, data_max }` *(optional)* — hard resource caps.  
- `policy_flags` *(bitset, optional)* — e.g. deny `mem_write` in RUN, allow `reg_set(PC)` in STOPPED.

VM must ignore unknown fields gracefully and operate without paging/cache.

---

#### 6.1.5 Note on HXE header (stack/heap sizing)

The HXE header **may** carry optional sizing hints to streamline arena creation:

- `stack_size_bytes` — stack arena size (used unless overridden by policy).  
- `heap_size_bytes` *(optional)* — only needed if the runtime/app uses `new/malloc`.  
- Capability/version flags (e.g. `requires_f16`, `needs_mailbox=N`) to influence arena layout.

A heap is **not required** unless the app genuinely performs dynamic allocation. Keep heap support **optional**; define header fields now to avoid format churn later.

Notes:
- Breakpoints are enforced by the executive. The VM surfaces `BRK` traps but does not maintain breakpoint tables.
- Autorun behaviour can be achieved via repeated `vm_clock(n)` calls or by passing `autorun_quanta` at init; default behaviour is single-step retirement for determinism.

### 6.2 Trap Interface (VM to Executive)
- SVC: VM raises the trap and the executive dispatches to module handlers (mailbox, value, command, provisioning, HAL proxies, and so on).
- BRK: VM halts with `reason = break` when guest code executes `BRK`; the executive decides how to resume or inspect state.
- Faults: illegal instruction, bounds errors, and misaligned accesses map to executive events for policy decisions.

Time base: in attached mode the executive scheduler defines cadence. SVC timeouts express microseconds or ticks as defined in [abi_syscalls.md](../../docs/abi_syscalls.md).

## 7. Observability and Instrumentation
- Breakpoint handling lives in the executive. The VM simply reports `BRK` traps so the executive can manage breakpoints and resume logic.
- Single-step support uses a counter set by the executive; the VM decrements it each retired instruction and halts with a `step` reason at zero.
- Register dumps: the VM can snapshot the active workspace on request so the executive can surface register state during pauses.

### 7.1 Trace Record (Last Instruction State)
**VM retains minimal trace state:**
The VM maintains a snapshot of the last executed instruction to support debugging and trace:
- `last_pc`: Program counter before instruction execution
- `last_opcode`: Full instruction word (32-bit)
- `last_regs`: Optional register snapshot before execution (debug builds only)

**Capture timing:**
The VM captures this state *before* executing each instruction during `step()`. This ensures the trace is accurate even for jumps, calls, and branches.

**Executive access:**
The executive reads this state after each `vm_step()` or `vm_clock()` call via:
- `vm_get_last_pc()` - Returns PC of last executed instruction
- `vm_get_last_opcode()` - Returns instruction word
- `vm_get_last_regs()` - Returns register snapshot (if enabled)

**Design rationale:**
- VM keeps only the *last* instruction—trace buffers live in the executive
- Executive controls trace buffer size based on variant (minimal, development, full debugger)
- Minimal overhead in VM (just 3 fields updated per instruction)
- Works correctly with all instruction types (jumps, calls, branches)
- Can be disabled entirely by not reading these fields

## 8. Executive Integration
**VM always runs under an executive:** MiniVM always executes under an executive. There is no production standalone mode—even the smallest deployment couples the VM to an executive that loads images, clocks the core, and services the SVC modules that firmware requires.

**Modular executive design:**
The executive consists of pluggable backend modules selected at compile/link time:
- **Filesystem backends:** Host filesystem (Python/desktop), SPI SD card (MCU), CAN provisioning
- **Shell/protocol backends:** JSON-RPC over TCP (Python), direct C API (MCU), UART command interface
- **Hardware abstraction:** Different HAL implementations for simulation vs. embedded targets

On desktop (Python), the executive is a separate process that communicates with tooling via TCP/IP. On MCU targets, the VM and executive are compiled and linked together into a single flash image with the appropriate backend modules.

**Feature configuration:** Executive variants share one codebase with compile-time feature switches (e.g., syscall subsets, debugging tools, multitasking). Builds can trim features to reduce RAM/flash while preserving the same VM ABI. All HAL access flows through the executive—the VM links no local shims, avoiding duplicated drivers and keeping the VM footprint minimal on constrained MCUs.

## 9. Testing Strategy
- ISA regression: assembler and compiler round-trips plus reference trace comparisons.
- ABI compliance: call and return prologues, stack alignment validation, and varargs stress cases.
- Syscall coverage: confirm return codes and error propagation across minimal and full executive configurations (feature flags on/off).
- Context switch tests: repeated PID swaps, register integrity checks, and wake-after-sleep scenarios while preserving workspace contents.
- Minimal-executive stress: run repetitive workloads with features stripped (no debugging, limited SVC set) to validate timing and resource budgets.

## 10. Verification
- See [MiniVM_tests.md](../06--Test/system/MiniVM_tests.md).
- Contract coverage: context swap O(1), SVC and BRK semantics, illegal opcode handling, and bounds enforcement.
- Behavioural coverage: paging (sequential, far jump, abort), data miss, evict, and flush paths.
- Limits: RAM budgets and step throughput smoke tests.

## 11. Traceability
- Design Requirements: DR-1.3, DR-2.1, DR-2.1a, DR-2.2, DR-2.3, DR-3.1, DR-5.1, DR-5.2, DR-6.1, DR-7.1, DR-8.1.
- Design Goals: DG-1.3, DG-1.4, DG-2.1 through DG-2.4, DG-3.1 through DG-3.3, DG-4.1 through DG-4.3, DG-5.1 through DG-5.4, DG-6.1, DG-7.2.
- Design Options: DO-2.a, DO-VM-hotset, DO-VM-adaptive, DO-4.b.
