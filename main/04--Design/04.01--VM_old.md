# Design Spec – MiniVM
# 04.01--VM — Design (v3, repo style)
**Status:** DRAFT • **Date:** 2025-10-28 • **Owner:** HSX Core

> **Design stance:** VM is a **dumb machine**. It does **no scheduling**, performs **no automatic context switching**, and services **no syscalls/HAL**. It always runs **under an Executive** which drives stepping, context selection, and debug (incl. breakpoints).

**Authoritative context (repo‑local):**
- Architecture: [03.01--VM](../03--Architecture/03.01--VM.md), [03.00--Architecture](../03--Architecture/03.00--Architecture.md)
- Study & Requirements: [02--Study](../02--Study/02--Study.md), [02.01--Requirements](../02--Study/02.01--Requirements.md)
- Implementation‑phase specs (normative inputs referenced by design):  
  [docs/abi_syscalls.md](../../docs/abi_syscalls.md) • [docs/MVASM_SPEC.md](../../docs/MVASM_SPEC.md) •
  [docs/hxe_format.md](../../docs/hxe_format.md) • [docs/executive_protocol.md](../../docs/executive_protocol.md) •
  [docs/resource_budgets.md](../../docs/resource_budgets.md)

**Traceability (fill from 02.01--Requirements):** Refs DR[..], DG[..], DO[..].

## Scope
- Implement the HSX instruction-set architecture (ISA) for a single task on both reference (Python) and embedded (C) targets, without bundling an in-VM operating system (DR-2.1, DG-4.1).
- Provide deterministic execution regardless of whether an executive is attached, so very small targets can run a single HSX program autonomously (DR-1.1, DG-1.4).
- Surface consistent debugging, trap, and syscall behaviour that the executive, tooling, and HAL layers can rely on (DR-8.1, DG-5.2, DG-8.1).

## Preconditions
- Toolchain emits `.hxe` binaries with entry point and section metadata, plus optional symbol/line tables for debugging (DR-3.1, DG-3.3).
- Executive (when present) allocates per-task register/stack arenas, drives clocking, and routes syscalls/events through its RPC surface (DR-5.1, DG-5.3).
- HAL shims are available to handle a subset of syscalls locally when the executive is detached (see `04.08--HAL.md`) (DR-6.1, DG-6.1).

## Postconditions
- MiniVM instances can be swapped between Python reference and C port without behavioural drift at the ISA, ABI, or syscall level (DR-1.3, DG-1.4).
- Tasks can be loaded, executed, paused, restarted, and context switched purely by adjusting workspace pointers and stacks—no whole-register copies required (DR-2.1a, DG-4.1).

## Instruction Encoding & Execution
- **Opcode format:** Primary 16-bit word: upper 6 bits = opcode group, next 4 bits = destination register, lower 6 bits = operand specifier. Extension words carry immediates, displacement, or literal data.
- **Categories:** ALU (ADD, SUB, AND, OR, XOR, SHIFT), compare/branch, load/store, control (CALL, RET, BRK, SVC), floating-point (FADD, FMUL, FCONV), system (SETPSW, GETPSW).
- **Execution invariants:**
  - All arithmetic updates `psw` (Z, N, C, V) unless the opcode explicitly suppresses flags (e.g., MOV.NF).
  - CALL pushes return address to stack (aligned 32-bit), updates `R15` with new frame pointer if required by ABI.
  - SVC/BRK cause the VM to pause execution after posting an event; the executive (or standalone HAL) must resume.
- **Implementation guidance:** Python VM decodes into callable dispatch table; C port should generate a jump table to maintain constant execution cost per opcode.

**Opcode map:**  
| Opcode (hex) | Mnemonic | Operand value types |
|--------------|----------|---------------------|
| 0x01 | LDI | Rd:GPR32, Imm12:signed literal/reloc |
| 0x02 | LD | Rd:GPR32, [Rs:GPR32 + Imm12:signed byte offset] |
| 0x03 | ST | Mem32[Rs:GPR32 + Imm12:signed byte offset] <- Rt:GPR32 |
| 0x04 | MOV | Rd:GPR32, Rs:GPR32 |
| 0x06 | LDB | Rd:GPR32, [Rs:GPR32 + Imm12:signed byte offset] (8-bit) |
| 0x07 | LDH | Rd:GPR32, [Rs:GPR32 + Imm12:signed byte offset] (16-bit) |
| 0x08 | STB | Mem8[Rs:GPR32 + Imm12:signed byte offset] <- Rt:GPR32 |
| 0x09 | STH | Mem16[Rs:GPR32 + Imm12:signed byte offset] <- Rt:GPR32 |
| 0x10 | ADD | Rd:GPR32, Rs:GPR32, Rt:GPR32 |
| 0x11 | SUB | Rd:GPR32, Rs:GPR32, Rt:GPR32 |
| 0x12 | MUL | Rd:GPR32, Rs:GPR32, Rt:GPR32 |
| 0x13 | DIV | Rd:GPR32, Rs:GPR32, Rt:GPR32 |
| 0x14 | AND | Rd:GPR32, Rs:GPR32, Rt:GPR32 |
| 0x15 | OR | Rd:GPR32, Rs:GPR32, Rt:GPR32 |
| 0x16 | XOR | Rd:GPR32, Rs:GPR32, Rt:GPR32 |
| 0x17 | NOT | Rd:GPR32, Rs:GPR32 |
| 0x20 | CMP | Rs:GPR32, Rt:GPR32 (updates PSW flags) |
| 0x21 | JMP | Imm12:zero-extended absolute PC target |
| 0x22 | JZ | Imm12:zero-extended absolute PC target (taken if PSW.Z=1) |
| 0x23 | JNZ | Imm12:zero-extended absolute PC target (taken if PSW.Z=0) |
| 0x24 | CALL | Rs:GPR32 (optional base, 0->current PC), Imm12:signed word offset (scaled by 4) |
| 0x25 | RET | None |
| 0x30 | SVC | Imm4:module, Imm8:function (packed in imm12) |
| 0x40 | PUSH | Rs:GPR32 |
| 0x41 | POP | Rd:GPR32 |
| 0x50 | FADD | Rd:GPR32(f16 lower half), Rs:GPR32(f16), Rt:GPR32(f16) |
| 0x51 | FSUB | Rd:GPR32(f16 lower half), Rs:GPR32(f16), Rt:GPR32(f16) |
| 0x52 | FMUL | Rd:GPR32(f16 lower half), Rs:GPR32(f16), Rt:GPR32(f16) |
| 0x53 | FDIV | Rd:GPR32(f16 lower half), Rs:GPR32(f16), Rt:GPR32(f16) |
| 0x54 | I2F | Rd:GPR32(f16 lower half), Rs:GPR32(int32) |
| 0x55 | F2I | Rd:GPR32(int32), Rs:GPR32(f16 lower half) |
| 0x60 | LDI32 | Rd:GPR32, Imm32:literal (follows opcode word) |
| 0x7F | BRK | Imm8:trap code (optional, default 0) |

- **Fetch/Decode/Execute loop:** The VM fetches 16-bit opcodes from the code segment, optionally loads extension words, decodes operation class, resolves operands (register, immediate, memory), executes, and updates `pc`.
- **Three-stage model:** *Fetch* (read opcode + ext words), *Decode* (determine opcode group, operand addressing), *Execute* (perform ALU/memory/syscall, update PSW). Pipeline is sequential; there is no speculative execution.
- **Endian & alignment:** Memory is little-endian; aligned 32-bit accesses are preferred, but unaligned word/halfword loads store the sane byte order for portability.

## Register Model
- **General registers:** 16 × 32-bit (`R0..R15`) arranged in a workspace; `R15` doubles as link register on call/return. Workspace pointer (`reg_base`) selects the active 16-word window.
- **Special registers:**
  - `pc` (program counter, byte address).
  - `psw` (flags: Z, C, N, V, E for error latch, plus interrupt mask).
  - `sp` (stack pointer) relative to `stack_base`.
  - `stack_base`, `stack_limit` define the stack arena.
- **Workspace pointer control:** Executive (or standalone host) updates `reg_base` to switch tasks. The VM exposes helpers `snapshot_context()` / `restore_context(ctx)` that only read/write metadata; register contents remain in RAM at addresses `reg_base + 4*n`.


//new_start
## 3. Registers & Enumeration
### 3.1 Register constants (design guideline)
| Constant | Meaning |
|---|---|
| `REG_PC` = 0 | Program Counter |
| `REG_SP` = 1 | Stack Pointer |
| `REG_PSW` = 2 | Status/flags |
| `REG_WP` = 3 | Workspace pointer |
| `REG_R0`..`REG_R15` = 16..31 | General purpose registers windowed by `WP` |

> Exact values can be frozen in a shared header during implementation; VM must expose them consistently to Executive/tooling.

### 3.2 TaskContext (normative, VM‑internal)
| Field | Type | Description |
|---|---|---|
| `pc` | u32 | Program counter (byte address) |
| `sp` | u32 | Stack pointer (VM stack) |
| `psw` | u32 | Processor status/flags |
| `wp` | u32 | Workspace pointer |
| `reg_base` | u32 | Base of register arena (for R0..R15 windows) |
| `stack_base` | u32 | Start of stack arena |
| `stack_limit` | u32 | Guard/limit |
| `fault_code` | u16 | Latched fault (0 = none) |
| `pid` | u16 | Task id |

**Invariant:** `stack_base ≤ sp < stack_limit`. Context swap = swap a few words (`pc/sp/psw/wp`).


//new_stop


## Memory Model
- **Segments:** Code (execute-only), read-only data, zero-initialised BSS, stack, and heap (optional). Each task has its own stack/heap; code and rodata may be shared if desired by the loader.
- **Address space:** 16-bit word addresses translated to byte addresses internally (`word_addr << 1`). Extended opcodes support 24-bit effective addresses for future large-memory profiles.
- **Alignment & access rules:** LD/ST instructions operate on 8/16/32-bit units; misaligned accesses trap with `HSX_ERR_ALIGN` so platform HALs can decide whether to emulate or fault.

//new_start
## 5. Memory Model
### 5.1 Layout
- **Code**: read‑only, design option: pageable (e.g., external FRAM/flash + RAM cache).  
- **Data/heap**: read/write; optional **software paging** (fixed‑size pages).  
- **Stack**: pinned.

### 5.2 Code paging (design‑option)
- **Double‑buffer** 256–512 B lines; prefetch near line end; far jump aborts & aligns new burst.  
- Heuristic: decode‑assisted look‑ahead for branch/call targets.

### 5.3 Data paging (design-optionn )
- TLB 2–4 entries; classes: pinned(stack, IPC), RO(globals), RW(heap); write‑back + `VMEM.FLUSH()` hint.  
- Cross‑page R/W split; atomic word stores via critical section when required.
//new_stop

## Execution Modes
- **Attached mode:** Executive owns the clock. It calls `step(n)` to retire exactly `n` instructions per PID. Detached auto-loop is halted; time base is driven by host scheduling.
- **Standalone mode:** VM runs its own loop (`run_until(stop_condition)`), using an internal tick (µs resolution on MCU, simulated time on host). Syscalls are routed to HAL shims where available; unsupported traps raise `HSX_ERR_ENOSYS`.
- **Mode switching:** When an executive attaches, `MiniVM.attached = True` pauses the internal loop after the current instruction, hands control to the executive, and enables per-instruction event streaming. Detaching resumes internal clock with the last known tick delta.

## ABI & Calling Convention
- **Calling convention:**
  - Arguments 0–3 in `R0..R3`; return value in `R0`.
  - `R4..R7` caller-saved; `R8..R12` callee-saved; `R13` reserved for TLS pointer; `R14` frame pointer; `R15` link register.
  - Additional arguments spill to stack as 32-bit words (little-endian). Callee reads them via `SP + 16`.
  - Stack grows downward; 8-byte alignment maintained at call boundaries.
- **Prologue/Epilogue sequence:**
  1. Push saved registers (`R8..R12`) and prior `R15` if using frame pointer.
  2. Allocate local storage by decrementing `sp`.
  3. Restore in reverse order on return; pop return address into `pc` or use `RET`.
- **Varargs support:** `R0..R3` include count in `R0` (low 8 bits) when function flagged as varargs; callee walks stack for overflow arguments.

## Syscall Interface (SVC)
- **Trap entry:** `SVC #imm` places module/function in immediate (8-bit module, 8-bit function). `R0..R3` carry parameters; `psw.E` flag records error state returned from handler.
- **Return path:** HAL/executive writes result to `R0`, status in `psw.E` (0 success, 1 failure). Errors also encode canonical `HSX_ERR_*` IDs in upper 16 bits of `R0`.
- **Standalone behaviour:** When detached, a HAL shim resolves core services: stdio, timers, lightweight mailbox loopback. For advanced services (e.g., CAN provisioning) the shim returns `HSX_ERR_ENOSYS`.
- **Instrumenting events:** Each SVC generates `svc_call` and optional `svc_return` events; handlers set `payload = {module, function, args, rc}`.
- **Authoritative list:** `docs/abi_syscalls.md` enumerates modules; this design document summarises the ABI usage and ensures each module definition matches the spec.

## Context Switching & Workspace Management
- Executive stores per-task contexts: `{pc, psw, sp, stack_base, stack_limit, reg_base, sleep_until, wait_channel}`.
- Task switch algorithm:
  1. `snapshot_context()` writes CPU state into context struct (no register copies).
  2. Executive selects next PID, sets `reg_base`, `stack_base`, `sp`, `pc`, `psw`.
  3. Calls `resume()` or `step()` to continue.
- Register banks reside in contiguous RAM buffers allocated during task load. Retasking `reg_base` is O(1), which is the key design requirement for an eventual C port with tight SRAM budgets.

## Performance & Resource Targets
| Target | Metric | Initial target |
|---|---|---|
| Context switch | overhead | O(1) swap `pc/sp/psw/wp` |
| Step throughput | instr/s (M4 @ 48 MHz) | 2–4 M instr/s (design goal) |
| Code cache line | bytes | 256–512 B |
| Data TLB | entries | 2–4 |
| RAM budget | bytes | see [resource_budgets.md](../../docs/resource_budgets.md) |
| Event rate | events/s | bounded by Exec rate‑limit |


## Standalone Runtime Behaviour
- **Single-task loop:** `run()` fetches opcodes, executes, handles SVC via HAL shim, and exits when program sets `HSX_ERR_EXIT` or hits `BRK`.
- **I/O surfaces:** Minimal stdio and timer services exposed via HAL; mailbox operations degrade to local queues without multi-tasking.
- **Deterministic timing:** Optionally uses hardware timer interrupts to pace instruction retirement (e.g., 10 kHz). When instructions block on SVC lacking HAL support the VM returns error to application.


//new_start


## 2. External Interfaces (VM ↔ Executive)
> The Executive owns the control plane. VM exposes a **narrow** API and traps (SVC/BRK).

### 2.1 Control‑plane API (host‑side calls into VM)
| API | Args | Returns | Notes |
|---|---|---|---|
| `vm_init(mem_cfg)` | page sizes, cache configs, alloc hooks, *autorun_quanta?* | rc | Configure paging/arenas. |
| `vm_load_hxe(hxe_ptr, len)` | pointer/descriptor to verified `.hxe` | pid (int), rc | Load one task; allocate arenas. |
| `vm_unload(pid)` | pid | rc | Free arenas and context. |
| `vm_pids()` | – | list[int] | Enumerate tasks. |
| `vm_set_context(pid)` | pid | rc | Make **pid** active; **no** implicit swap. |
| `vm_step()` | – | StepResult | **One instruction** for the active task *(or up to `autorun_quanta` if configured)*. |
| `vm_clock(n)` | n (int) | StepResult | Execute **n** instructions (or stop on svc/break/fault). |
| `vm_reg_get(reg_id)` | const | u32 | Read register in **active** context (PC/SP/… included). |
| `vm_reg_set(reg_id, value)` | const, u32 | rc | Write register in **active** context (policy‑gated). |
| `vm_reg_get_for(pid, reg_id)` | pid, const | u32 | (Optional sugar) Read register for **pid** without state change. |
| `vm_reg_set_for(pid, reg_id, value)` | pid, const, u32 | rc | (Optional sugar) Write register for **pid**. |

**StepResult**: `pc`, `reason ∈ {ok, break, fault, svc}`, optional `svc_id`, `events_emitted`, `cycles_est`.

**Notes**
- **Breakpoints are not a VM concern.** Executive checks PC vs breakpoint table **before** calling `vm_step/clock`.  
- The **autorun** behavior can be achieved either by `vm_clock(n)` or via an optional `autorun_quanta` init parameter; default is **1** for deterministic stepping.

### 2.2 Trap interface (VM → Executive)
- **SVC**: VM raises; Executive dispatches to module handlers (mailbox/val/cmd/provisioning/HAL).  
- **BRK**: VM halts with `reason=break` if the bytecode explicitly executes BRK.  
- **Faults**: illegal instruction, bounds, misaligned access → mapped to Executive events.

**Time base:** In attached mode, cadence is defined by the Executive scheduler. SVC timeouts carry units (µs/ticks) per [abi_syscalls.md](../../docs/abi_syscalls.md).

//new_stop



//remove_start: the breakpoint  handling will be done by executive. VM should not do this, to make sure we keep VM light weight
## Debug & Instrumentation
- **Breakpoints:** `BRK` opcode and software patching breakpoints inject a trap that emits `debug_break` with `pc`, `cause`.
- **Single-step:** `single_step_remaining` counter (set by executive) decrements each instruction; when zero, VM pauses and raises `debug_step`.
- **Register dumps:** Snapshot of workspace emitted on breaks when the executive requests `include_regs=true`.
- **Trace stream:** Optional trace flag causes each retired instruction to emit `trace_step` (opcode, operands, psw, reg diffs) for simulator validation.
//remove_stop


## HAL Integration & Shims
- When the executive is absent, SVC handlers call into HAL modules (`04.08--HAL.md`) for UART, timers, persistent storage, etc.
- Attached mode defers to the executive, which itself uses the HAL for hardware access—ensuring a single source of truth for drivers.
- HAL exposes capability negotiation so the VM can query which services are locally available versus executive-provided; unsupported services trigger fallback or error.

## Testing Considerations
- ISA regression: assembler/compiler round-trips, reference traces vs. implementation.
- ABI compliance: call/return prologues, stack alignment checks, varargs stress.
- Syscall coverage: ensure return codes, error propagation, and HAL shims behave identically in standalone and attached modes.
- Context switch tests: repeated PID swaps, register integrity, wake-after-sleep while preserving workspace contents.
- Standalone stress: run repetitive workloads without executive to validate HAL shims and timing.


## 10. Verification (links to tests)
- See **[MiniVM_tests.md](../06--Test/system/MiniVM_tests.md)**.  
- Contract: context swap O(1), SVC/BRK semantics, illegal ops, bounds.  
- Behaviour: paging (sequential/far jump/abort), data miss/evict/flush.  
- Limits: RAM budgets; step throughput (smoke).


## Traceability
- **Design Requirements:** DR-1.3, DR-2.1, DR-2.1a, DR-2.2, DR-2.3, DR-3.1, DR-5.1, DR-5.2, DR-6.1, DR-7.1, DR-8.1.
- **Design Goals:** DG-1.3, DG-1.4, DG-2.1–2.4, DG-3.1–3.3, DG-4.1–4.3, DG-5.1–5.4, DG-6.1, DG-7.2.
- **Design Options:** DO-2.a, DO-VM-hotset, DO-VM-adaptive, DO-4.b.
