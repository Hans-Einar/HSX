# Design Spec - Hardware Abstraction Layer (HAL)
# 04.08--HAL Design (v3, repo style)
**Status:** DRAFT | **Date:** 2025-10-28 | **Owner:** HSX Core

> **Design stance:** The HAL is a portability abstraction layer. It performs no autonomous scheduling, embeds no business logic, and provides only thin wrappers around platform-specific drivers. All policy decisions (retry, buffering, error handling) live in the executive or application layers.

**Authoritative context (repo-local):**
- Architecture: [03.08--HAL](../03--Architecture/03.08--HAL.md), [03.00--Architecture](../03--Architecture/03.00--Architecture.md)
- Study & Requirements: [02--Study](../02--Study/02--Study.md), [02.01--Requirements](../02--Study/02.01--Requirements.md)
- Implementation-phase specs (normative inputs referenced by design):
  [docs/abi_syscalls.md](../../docs/abi_syscalls.md), [docs/resource_budgets.md](../../docs/resource_budgets.md)

**Traceability (fill from 02.01--Requirements):** Refs DR[..], DG[..], DO[..].

## 1. Scope
- Provide portable abstraction for UART, CAN, timers, GPIO, persistent storage (FRAM/EEPROM), filesystem, and peripherals used by MiniVM and executive (DR-1.1, DR-5.3, DG-5.3).
- Support two deployment modes:
  1. **Executive-attached:** HAL backs executive services; MiniVM SVC traps forwarded to executive, which calls HAL drivers.
  2. **Standalone VM:** lightweight HAL shim handles essential syscalls directly for single-program deployments without executive (DG-1.4, DG-4.1).
- Offer consistent capability discovery enabling higher layers to adapt to target-specific peripheral availability (DG-5.2, DG-7.3).

## 2. Preconditions
- Target platform supplies low-level driver primitives (register-level API, OS drivers, or Python mocks) for each supported peripheral (DR-1.1, DG-5.3).
- Build system links appropriate HAL implementation (desktop mock, MCU C drivers) matching deployment profile (DR-1.3, DG-1.4).
- MiniVM and executive agree on HAL version and capabilities via `HAL_GET_CAPS` syscall (module 0x10) per [docs/abi_syscalls.md](../../docs/abi_syscalls.md) (DR-6.1, DG-6.2).

## 3. Postconditions
- All hardware interactions flow through HAL interfaces, ensuring feature parity across Python reference and embedded builds (DR-1.3, DG-1.4).
- Syscalls complete locally via HAL shim (standalone VM) or route through executive which invokes same HAL drivers (DR-6.1, DG-6.2).
- Capability negotiation allows tooling and apps to detect unsupported peripherals early and degrade gracefully (DR-7.1, DG-7.3).
- Platform-specific drivers integrate seamlessly without changes to MiniVM or executive core logic (DR-1.1, DG-5.3).

## 4. Architectural Overview

### 4.1 HAL Modules & Interfaces
| Module | ID | Responsibilities | Notes |
|--------|----|------------------|-------|
| UART   | 0x10 | Bidirectional serial I/O, console redirection | Blocking/non-blocking writes, line buffering, optional RTS/CTS. |
| CAN    | 0x11 | 11/29-bit CAN frames, provisioning channel | Chunked transfers, filters, error counters. |
| TIMER  | 0x12 | Monotonic tick, sleep delays | µs-resolution timer, sleep/wake interrupts for scheduler. |
| FRAM   | 0x13 | Persistent key/value storage | Read/write blocks, CRC helpers, wear management. |
| FS     | 0x14 | File abstraction (SD/host) | Open/read/write/close, directory listing. |
| GPIO   | 0x15 | Digital IO for instrumentation | Optional; mainly for diagnostics. |
| EXEC   | 0x16 | Provisioning loader support | Bridges to HXE staging with executive. |

Each module exposes C interface (function table) and Python analogue; both are thin wrappers around target drivers.

### 4.2 Design Principles
- **Thin abstraction:** HAL provides minimal wrappers; policy (retry, buffering) lives in executive/application.
- **Capability-driven:** `hal_caps_t` advertises supported modules, buffer sizes, limits dynamically.
- **Consistent error model:** Functions return `hal_status_t` mapped to HSX error codes during syscall translation.
- **Portable threading:** MCU uses interrupt-driven ISRs; desktop simulates with async loops for parity.

## 5. External Interfaces

### 5.1 Syscall Bridging
- **Standalone VM:** MiniVM invokes HAL handlers directly (e.g., `SVC 0x10 UART_WRITE` → `hal_uart_write(buf, len)`); errors via `psw.E`.
- **Executive-attached:** SVC forwarded to executive over RPC; executive calls HAL drivers, returns codes. HAL remains authority.
- **Fallback strategy:** Unavailable service returns `HAL_STATUS_UNSUPPORTED` → MiniVM translates to `HSX_ERR_ENOSYS`.

### 5.2 Data Structures
- `hal_caps_t`: bitfields per module, buffer sizes, max tasks.
- `hal_uart_config_t`: baud rate, parity, flow control.
- `hal_can_frame_t`: id, dlc, data[8], timestamp.
- `hal_timer_tick_t`: current tick (64-bit), scaling (ticks/µs).
- `hal_fram_entry_t`: base address, length, CRC, wear counters.
- `hal_fs_handle_t`: opaque file descriptor.

## 6. Configuration & Initialisation
- **Init sequence:** `hal_init()` detects hardware, populates `hal_caps_t`, initializes drivers, registers ISR callbacks.
- **Profile overlays:** Desktop uses mock drivers (Python socket for CAN); MCU links static drivers.
- **Build-time options:** Flags enable/disable modules to trim firmware size.

## 7. Integration with MiniVM & Executive
- MiniVM exposes `hal_dispatch(module, function, args)` for standalone and executive bridging.
- Executive uses HAL for provisioning, stdio, mailbox shims, persistence I/O.
- HAL provides notification hooks (`hal_uart_on_rx`, `hal_can_on_frame`) for event queuing.

## 8. Testing Strategy
- **Unit tests:** Per-module with mock drivers (loopback UART, simulated CAN, memory FRAM).
- **Integration tests:** Standalone VM syscalls without executive (stdout, sleep, val.persist).
- **Stress tests:** Large CAN transfers, FRAM wear patterns.
- **Hardware-in-loop:** ISR latency and throughput validation.

## 9. Verification
- See [HAL_tests.md](../06--Test/system/HAL_tests.md) (if available).
- **Contract coverage:** Capability discovery, error code mapping, ISR responsiveness.
- **Behavioral coverage:** All module functions across mock and real hardware.
- **Portability validation:** Python and C implementations produce equivalent behavior.

## 10. Traceability
- **Design Requirements:** DR-1.1, DR-1.3, DR-5.1, DR-5.3, DR-6.1, DR-7.1.
- **Design Goals:** DG-1.4, DG-5.1, DG-5.2, DG-5.3, DG-6.1, DG-6.2, DG-6.3, DG-7.3.
- **Design Options:** DO-relay (future distributed HAL), DO-5.a (priority scheduling timer integration).
