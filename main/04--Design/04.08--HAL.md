# Design Spec – Hardware Abstraction Layer (HAL)

## Scope
- Provide a portable abstraction for UART, CAN, timers, GPIO, persistent storage (FRAM/EEPROM), filesystem, and other peripherals used by the MiniVM and executive (DR-1.1, DR-5.3, DG-5.3).
- Support two deployment modes:
  1. **Executive-attached:** HAL backs executive services; MiniVM SVC traps are forwarded to the executive, which calls into HAL drivers.
  2. **Standalone VM:** a lightweight HAL shim handles essential syscalls directly so single-program deployments can run without an executive (DG-1.4, DG-4.1).
- Offer consistent capability discovery so higher layers can adapt to what the target exposes (DG-5.2, DG-7.3).

## Preconditions
- Target platform supplies low-level driver primitives (register-level API, OS drivers, or Python mocks) for each supported peripheral.
- Build system links the appropriate HAL implementation (desktop mock, MCU C drivers) matching the deployment profile.
- MiniVM and executive agree on HAL version and capabilities via `HAL_GET_CAPS` syscall (module 0x10).

## Postconditions
- All hardware interactions flow through HAL interfaces, ensuring feature parity across Python reference and embedded builds (DR-1.3, DG-1.4).
- Syscalls either complete locally via HAL shim (standalone VM) or are routed through the executive, which ultimately invokes the same HAL drivers (DR-6.1, DG-6.2).
- Capability negotiation allows tooling and apps to detect unsupported peripherals early and degrade gracefully (DR-7.1, DG-7.3).

## HAL Modules & Interfaces
| Module | ID | Responsibilities | Notes |
|--------|----|------------------|-------|
| UART   | 0x10 | Bidirectional serial I/O, console redirection | Provides blocking/non-blocking writes, line buffering, and optional RTS/CTS control. |
| CAN    | 0x11 | 11/29-bit CAN frames, provisioning channel | Supports chunked transfers, filters, and error counters. |
| TIMER  | 0x12 | Monotonic tick, sleep delays | Exposes µs-resolution timer and sleep/wake interrupts for scheduler. |
| FRAM   | 0x13 | Persistent key/value storage | Read/write blocks, CRC helpers, wear management. |
| FS     | 0x14 | File abstraction (for SD/host) | Open/read/write/close plus directory listing. |
| GPIO   | 0x15 | Digital IO for instrumentation/future sensors | Optional; mainly for diagnostics. |
| EXEC   | 0x16 | Provisioning loader support | Shared with executive packaging (bridges to HXE staging). |

Each module exposes an idiomatic C interface (function table) and a Python analogue; both are thin wrappers around target-specific drivers.

## Architectural Overview
- **Driver adapters:** Each module has an adapter (`hal_uart`, `hal_can`, etc.) that translates high-level operations into platform APIs.
- **Capability table:** `hal_caps_t` structure advertises supported modules, buffer sizes, and limits (e.g., `max_can_payload`, `fram_capacity`).
- **Error model:** Functions return `hal_status_t` (OK, BUSY, TIMEOUT, CRC_FAIL, IO_ERROR). These map to HSX error codes (`HSX_ERR_*`) during syscall translation.
- **Threading model:** On MCUs the HAL is interrupt-driven (ISR posts events for UART/CAN). On desktop, asynchronous loops simulate interrupts for parity.

## Syscall Bridging
- **Standalone VM:** MiniVM invokes HAL handlers directly. For example, `SVC 0x10 UART_WRITE` calls `hal_uart_write(buf, len)`; errors propagate via `psw.E`.
- **Executive-attached:** SVC arguments are forwarded to the executive over RPC; the executive calls HAL drivers and returns result codes. This keeps the HAL as the ultimate authority even when complex orchestration is required.
- **Fallback strategy:** If a service is unavailable, HAL returns `HAL_STATUS_UNSUPPORTED`; MiniVM translates to `HSX_ERR_ENOSYS`, while the executive can choose to schedule work elsewhere (e.g., remote CAN bridge).

## Data Structures
- `hal_caps_t`: bitfields per module, buffer sizes, max tasks supported.
- `hal_uart_config_t`: baud rate, parity, flow control flags.
- `hal_can_frame_t`: id, dlc, data[8], timestamp.
- `hal_timer_tick_t`: current tick (64-bit) and scaling (ticks per microsecond).
- `hal_fram_entry_t`: base address, length, crc, wear counters.
- `hal_fs_handle_t`: opaque file descriptor bridging to platform FS.

## Configuration & Initialisation
- **init sequence:** `hal_init()` detects hardware, populates `hal_caps_t`, initialises drivers, and registers ISR callbacks where required.
- **Profile overlays:** Desktop profile uses mock drivers that interface with host OS (e.g., Python socket for CAN). MCU profile links static drivers.
- **Build-time options:** Flags enable/disable modules (`HAL_ENABLE_CAN`, `HAL_ENABLE_GPIO`) to trim firmware size.

## Interaction with MiniVM & Executive
- MiniVM exposes `hal_dispatch(module, function, args)` used by both standalone mode and executive bridging.
- Executive uses HAL for provisioning, stdio redirection, mailbox host shims, and persistence I/O, guaranteeing a single implementation path across modes.
- HAL provides notification hooks (`hal_uart_on_rx`, `hal_can_on_frame`) that enqueue events consumed by the executive scheduler or the standalone VM shim.

## Testing Considerations
- Unit tests per module using mock drivers (loopback UART, simulated CAN bus, memory-backed FRAM).
- Integration tests for standalone VM verifying syscalls succeed without executive (stdout, sleep, val.persist).
- Stress tests for provisioning flows (large CAN transfers, FRAM wear patterns).
- Hardware-in-the-loop tests to validate ISR latency and throughput.

## Traceability
- **Design Requirements:** DR-1.1, DR-1.3, DR-5.1, DR-5.3, DR-6.1, DR-7.1.
- **Design Goals:** DG-1.4, DG-5.1–5.3, DG-6.1–6.3, DG-7.3.
- **Design Options:** DO-relay, DO-5.a (future priority scheduling relies on timer HAL).
