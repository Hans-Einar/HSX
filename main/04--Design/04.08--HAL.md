# Design Spec - Hardware Abstraction Layer (HAL)
# 04.08--HAL Design (v3, repo style)
**Status:** DRAFT | **Date:** 2025-10-28 | **Owner:** HSX Core

> **Design stance:** The HAL is a portability abstraction layer. It performs no autonomous scheduling, embeds no business logic, and provides only thin wrappers around platform-specific drivers. All policy decisions (retry, buffering, error handling) live in the executive or application layers.

**Authoritative context (repo-local):**
- Architecture: [03.08--HAL](../03--Architecture/03.08--HAL.md), [03.00--Architecture](../03--Architecture/03.00--Architecture.md)
- Study & Requirements: [02--Study](../02--Study/02--Study.md), [02.01--Requirements](../02--Study/02.01--Requirements.md)
- Implementation-phase specs (normative inputs referenced by design):
  [docs/abi_syscalls.md](../../docs/abi_syscalls.md), [docs/resource_budgets.md](../../docs/resource_budgets.md)

**Traceability (fill from 02.01--Requirements):** Refs DR[..], DG[..], DO[..].

## 1. Scope
- Provide portable abstraction for UART, CAN, timers, GPIO, persistent storage (FRAM/EEPROM), filesystem, and peripherals used by MiniVM and executive (DR-1.1, DR-5.3, DG-5.3).
- Support two deployment modes:
  1. **Executive-attached:** HAL backs executive services; MiniVM SVC traps forwarded to executive, which calls HAL drivers.
  2. **Standalone VM:** lightweight HAL shim handles essential syscalls directly for single-program deployments without executive (DG-1.4, DG-4.1).
- Offer consistent capability discovery enabling higher layers to adapt to target-specific peripheral availability (DG-5.2, DG-7.3).

## 2. Preconditions
- Target platform supplies low-level driver primitives (register-level API, OS drivers, or Python mocks) for each supported peripheral (DR-1.1, DG-5.3).
- Build system links appropriate HAL implementation (desktop mock, MCU C drivers) matching deployment profile (DR-1.3, DG-1.4).
- MiniVM and executive agree on HAL version and capabilities via `HAL_GET_CAPS` syscall (module 0x10) per [docs/abi_syscalls.md](../../docs/abi_syscalls.md) (DR-6.1, DG-6.2).

## 3. Postconditions
- All hardware interactions flow through HAL interfaces, ensuring feature parity across Python reference and embedded builds (DR-1.3, DG-1.4).
- Syscalls complete locally via HAL shim (standalone VM) or route through executive which invokes same HAL drivers (DR-6.1, DG-6.2).
- Capability negotiation allows tooling and apps to detect unsupported peripherals early and degrade gracefully (DR-7.1, DG-7.3).
- Platform-specific drivers integrate seamlessly without changes to MiniVM or executive core logic (DR-1.1, DG-5.3).

## 4. Architectural Overview

### 4.1 HAL Modules & Interfaces
| Module | ID | Responsibilities | Notes |
|--------|----|------------------|-------|
| UART   | 0x10 | Bidirectional serial I/O, console redirection | Blocking/non-blocking writes, line buffering, optional RTS/CTS. |
| CAN    | 0x11 | 11/29-bit CAN frames, provisioning channel | Chunked transfers, filters, error counters. |
| TIMER  | 0x12 | Monotonic tick, sleep delays | µs-resolution timer, sleep/wake interrupts for scheduler. |
| FRAM   | 0x13 | Persistent key/value storage | Read/write blocks, CRC helpers, wear management. |
| FS     | 0x14 | File abstraction (SD/host) | Open/read/write/close, directory listing. |
| GPIO   | 0x15 | Digital IO for instrumentation | Optional; mainly for diagnostics. |
| EXEC   | 0x16 | Provisioning loader support | Bridges to HXE staging with executive. |

Each module exposes C interface (function table) and Python analogue; both are thin wrappers around target drivers.

### 4.2 Design Principles
- **Thin abstraction:** HAL provides minimal wrappers; policy (retry, buffering) lives in executive/application.
- **Capability-driven:** `hal_caps_t` advertises supported modules, buffer sizes, limits dynamically.
- **Consistent error model:** Functions return `hal_status_t` mapped to HSX error codes during syscall translation.
- **Portable threading:** MCU uses interrupt-driven ISRs; desktop simulates with async loops for parity.

## 5. External Interfaces

### 5.1 Syscall Bridging
- **Standalone VM:** MiniVM invokes HAL handlers directly (e.g., `SVC 0x10 UART_WRITE` → `hal_uart_write(buf, len)`); errors via `psw.E`.
- **Executive-attached:** SVC forwarded to executive over RPC; executive calls HAL drivers, returns codes. HAL remains authority.
- **Fallback strategy:** Unavailable service returns `HAL_STATUS_UNSUPPORTED` → MiniVM translates to `HSX_ERR_ENOSYS`.

### 5.2 Data Structures
- `hal_caps_t`: bitfields per module, buffer sizes, max tasks.
- `hal_uart_config_t`: baud rate, parity, flow control.
- `hal_can_frame_t`: id, dlc, data[8], timestamp.
- `hal_timer_tick_t`: current tick (64-bit), scaling (ticks/µs).
- `hal_fram_entry_t`: base address, length, CRC, wear counters.
- `hal_fs_handle_t`: opaque file descriptor.

## 6. Configuration & Initialisation
- **Init sequence:** `hal_init()` detects hardware, populates `hal_caps_t`, initializes drivers, registers ISR callbacks.
- **Profile overlays:** Desktop uses mock drivers (Python socket for CAN); MCU links static drivers.
- **Build-time options:** Flags enable/disable modules to trim firmware size.

## 7. Integration with MiniVM & Executive
- MiniVM exposes `hal_dispatch(module, function, args)` for standalone and executive bridging.
- Executive uses HAL for provisioning, stdio, mailbox shims, persistence I/O.
- HAL provides notification hooks (`hal_uart_on_rx`, `hal_can_on_frame`) for event queuing.

## 8. Testing Strategy
- **Unit tests:** Per-module with mock drivers (loopback UART, simulated CAN, memory FRAM).
- **Integration tests:** Standalone VM syscalls without executive (stdout, sleep, val.persist).
- **Stress tests:** Large CAN transfers, FRAM wear patterns.
- **Hardware-in-loop:** ISR latency and throughput validation.

## 9. Verification
- See [HAL_tests.md](../06--Test/system/HAL_tests.md) (if available).
- **Contract coverage:** Capability discovery, error code mapping, ISR responsiveness.
- **Behavioral coverage:** All module functions across mock and real hardware.
- **Portability validation:** Python and C implementations produce equivalent behavior.

## 10. Two-Layer HAL Architecture

The HAL is organized into two complementary layers to provide separation between kernel-space operations and user-space convenience:

### 10.1 Architecture Overview

1. **Executive-Space HAL** (kernel space) - Modules in the executive that handle hardware operations
2. **User-Space HAL** (application space) - Libraries linked into HSX apps that provide convenient API

```text
┌─────────────────────────────────────────────────┐
│         HSX Application Code                    │
│   (uses hsx_uart.h, hsx_gpio.h, etc.)          │
└──────────────┬──────────────────────────────────┘
               │ Links against libhsx_hal.a
               ↓
┌─────────────────────────────────────────────────┐
│      User-Space HAL Libraries                   │
│  (hsx_uart.c, hsx_gpio.c, hsx_timer.c, etc.)   │
│  - Wraps syscalls (SVC instructions)           │
│  - Opens/manages mailboxes for events          │
│  - Provides convenient API                      │
└──────────────┬──────────────────────────────────┘
               │ SVC or Mailbox
               ↓
┌─────────────────────────────────────────────────┐
│     Executive SVC Dispatcher / Mailbox Mgr      │
└──────────────┬──────────────────────────────────┘
               │
               ↓
┌─────────────────────────────────────────────────┐
│      Executive-Space HAL Modules                │
│  (uart_hal.c, can_hal.c, gpio_hal.c, etc.)     │
│  - Implements syscall handlers                  │
│  - Posts mailbox events on interrupts           │
│  - Wraps platform drivers                       │
└──────────────┬──────────────────────────────────┘
               │
               ↓
┌─────────────────────────────────────────────────┐
│       Platform Drivers (AVR, STM32, etc.)       │
└─────────────────────────────────────────────────┘
```

### 10.2 Executive-Space HAL Modules

Executive-space modules implement syscall handlers and post events to mailboxes on hardware interrupts.

| Module | ID | Executive Source | Syscall Module | Mailbox Namespace |
|--------|----|-----------------|-----------------|--------------------|
| UART   | 0x10 | `exec/hal/uart_hal.c` | 0x10 | `hal:uart:*` |
| CAN    | 0x11 | `exec/hal/can_hal.c` | 0x11 | `hal:can:*` |
| Timer  | 0x12 | `exec/hal/timer_hal.c` | 0x12 | `hal:timer:*` |
| FRAM   | 0x13 | `exec/hal/fram_hal.c` | 0x13 | N/A |
| FS     | 0x14 | `exec/hal/fs_hal.c` | 0x14 | N/A |
| GPIO   | 0x15 | `exec/hal/gpio_hal.c` | 0x15 | `hal:gpio:*` |

#### 10.2.1 UART Module (0x10)
**Responsibilities:**
- Handle UART_WRITE syscall (synchronous transmit)
- Handle UART_CONFIG syscall (baud rate, parity, etc.)
- Post received bytes to `hal:uart:rx` mailbox (async)
- Manage TX/RX buffers

**Syscalls:**
- `0x10, 0x00 UART_WRITE(port, buf_ptr, length)` → bytes_written
- `0x10, 0x01 UART_READ_POLL(port, buf_ptr, max_len)` → bytes_read (non-blocking)
- `0x10, 0x02 UART_CONFIG(port, baud, parity, stop_bits)` → status
- `0x10, 0x03 UART_GET_STATUS(port)` → status flags

**Mailbox Events:**
- `hal:uart:0:rx` - Received data on UART 0
- `hal:uart:1:rx` - Received data on UART 1

#### 10.2.2 CAN Module (0x11)
**Responsibilities:**
- Handle CAN_TX syscall (synchronous transmit)
- Handle CAN_CONFIG syscall (filters, bitrate)
- Post received frames to `hal:can:rx` mailbox (async)
- Manage TX/RX queues

**Syscalls:**
- `0x11, 0x00 CAN_TX(can_id, buf_ptr, dlc, flags)` → status
- `0x11, 0x01 CAN_CONFIG(bitrate, mode)` → status
- `0x11, 0x02 CAN_SET_FILTER(filter_id, mask, id)` → status
- `0x11, 0x03 CAN_GET_STATUS()` → status flags

**Mailbox Events:**
- `hal:can:rx` - Received CAN frame

#### 10.2.3 Timer Module (0x12)
**Responsibilities:**
- Handle TIMER_GET_TICK syscall (read monotonic counter)
- Handle TIMER_SLEEP syscall (delegated to EXEC_SLEEP_MS)
- Handle TIMER_CREATE syscall (create periodic timer)
- Post timer expiry to mailbox (async)

**Syscalls:**
- `0x12, 0x00 TIMER_GET_TICK()` → tick_count (us)
- `0x12, 0x01 TIMER_GET_TICK_FREQ()` → ticks_per_second
- `0x12, 0x02 TIMER_CREATE(period_us, one_shot)` → timer_id
- `0x12, 0x03 TIMER_CANCEL(timer_id)` → status

**Mailbox Events:**
- `hal:timer:<id>` - Timer expiry for timer <id>

#### 10.2.4 FRAM Module (0x13)
**Responsibilities:**
- Handle FRAM_READ syscall (synchronous read)
- Handle FRAM_WRITE syscall (synchronous write)
- Manage wear leveling
- CRC validation

**Syscalls:**
- `0x13, 0x00 FRAM_READ(addr, buf_ptr, length)` → bytes_read
- `0x13, 0x01 FRAM_WRITE(addr, buf_ptr, length)` → bytes_written
- `0x13, 0x02 FRAM_GET_SIZE()` → total_bytes
- `0x13, 0x03 FRAM_GET_WEAR(addr)` → write_count

#### 10.2.5 FS Module (0x14)
**Responsibilities:**
- Handle FS_OPEN, FS_READ, FS_WRITE, FS_CLOSE syscalls
- Handle directory operations
- Manage file descriptors per task

**Syscalls:**
- `0x14, 0x00 FS_OPEN(path_ptr, flags)` → fd
- `0x14, 0x01 FS_READ(fd, buf_ptr, length)` → bytes_read
- `0x14, 0x02 FS_WRITE(fd, buf_ptr, length)` → bytes_written
- `0x14, 0x03 FS_CLOSE(fd)` → status
- `0x14, 0x0A FS_LISTDIR(path_ptr, buf_ptr, max_len)` → bytes_written
- `0x14, 0x0B FS_DELETE(path_ptr)` → status
- `0x14, 0x0C FS_RENAME(old_path_ptr, new_path_ptr)` → status
- `0x14, 0x0D FS_MKDIR(path_ptr)` → status

#### 10.2.6 GPIO Module (0x15)
**Responsibilities:**
- Handle GPIO_READ/WRITE syscalls (synchronous I/O)
- Handle GPIO_CONFIG syscall (input/output, pull-up, etc.)
- Handle GPIO_SET_INTERRUPT syscall (edge detection config)
- Post interrupt events to mailbox (async)

**Syscalls:**
- `0x15, 0x00 GPIO_READ(pin)` → value (0 or 1)
- `0x15, 0x01 GPIO_WRITE(pin, value)` → status
- `0x15, 0x02 GPIO_CONFIG(pin, mode, pull)` → status
- `0x15, 0x03 GPIO_SET_INTERRUPT(pin, edge, enable)` → status

**Mailbox Events:**
- `hal:gpio:<pin>` - Interrupt on pin <pin>

### 10.3 User-Space HAL Libraries

User-space libraries provide convenient application APIs that abstract whether operations use syscalls or mailboxes. Applications link against `libhsx_hal.a` and use standard headers (`hsx_uart.h`, `hsx_can.h`, etc.).

**Key Features:**
- Wraps syscalls with convenient C function interfaces
- Opens and manages mailboxes automatically for event-driven operations
- Provides both blocking and non-blocking operation modes
- Offers callback mechanisms for asynchronous events
- Includes helper functions (e.g., `hsx_uart_printf()`)

**Benefits of Two-Layer Architecture:**
- Applications don't need to know syscall details or mailbox protocols
- Clean, intuitive API that's easy to use and understand
- Consistent error handling and type definitions across all modules
- Event-driven programming with callbacks for hardware events
- Both blocking and non-blocking operations available as needed
- Easy to port applications between different platforms
- Separation of concerns between kernel and user space

For complete API specifications and implementation details, see [hsx_app_library.md](../../05--Implementation/HAL/hsx_app_library.md).

## 11. Traceability
- **Design Requirements:** DR-1.1, DR-1.3, DR-5.1, DR-5.3, DR-6.1, DR-7.1.
- **Design Goals:** DG-1.4, DG-5.1, DG-5.2, DG-5.3, DG-6.1, DG-6.2, DG-6.3, DG-7.3.
- **Design Options:** DO-relay (future distributed HAL), DO-5.a (priority scheduling timer integration).
