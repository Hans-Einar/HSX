# Design Spec â€” Value & Command Layer

## Scope
- Runtime tables for values and commands (group:value IDs).
- SVC implementations (register, lookup, get/set, persist, cmd call).
- Transport bindings (mailbox notifications, CAN/UART framing).
- Persistence integration (FRAM).

## Data Structures
- **Value entry (`hsx_val_entry`):** 8-byte record containing group id, value id, flags (RO, Persist, Sticky, Pin, Bool), last published f16 value, auth level, reserved byte.
- **Value descriptor (`hsx_val_desc`):** optional pointer structure with group/value names, unit (packed 4-char), epsilon, rate_ms, range bounds, persist key (FRAM address). Defaults omitted to save RAM.
- **Command entry (`hsx_cmd_entry`):** group id, value id, flags (Pin), auth level.
- **Command descriptor (`hsx_cmd_desc`):** optional names and help string references for shell/debugger display.
- **String tables:** deduplicated null-terminated strings stored once for all values/commands; referenced by descriptors.

## Algorithms / Behaviour
- **Registration:** allocate slot from fixed-size tables; create OID = group<<8 | value; store compact entry; optionally copy descriptor strings into shared table; assign persist key if provided (auto allocate if zero?).
- **Lookup:** O(1) array index by OID; fallback to hash map if sparse deployment.
- **GET/SET:** enforce auth level and flags; on set, compare new f16 against `last_f16` using epsilon; if changed and outside rate limit, update `last_f16`, persist if configured, enqueue mailbox/CAN updates.
- **Subscription:** `val.sub` stores mailbox handle; executive delivers `(oid,f16)` frames on change respecting rate limit.
- **Persistence:** `val.persist` toggles mode; on load, fetch from FRAM; on update, schedule write (debounced) to avoid wear.
- **Command call:** verify auth token if command flagged `Pin`; synchronous call returns errno; async call posts `(oid,rc)` to mailbox; commands do not carry arguments in v1 (button semantics).
- **CAN binding:** map `oid` to payload (2 bytes) with op-coded frames (GET, SET, PUB, CALL, RET); optional sequence/errno bytes; no argument payload beyond metadata.
- **Shell/CLI:** support numeric addressing `group:value` and named lookups via descriptor tables; parse floats into f16.

## Edge Cases
- Table capacity exhaustion returns error to registering task; document recommended limits per platform.
- Task restart should clear entries but allow same group:value IDs to reuse existing string/persist metadata if desired.
- FRAM read failure -> fall back to default or last known value flagged as `STALE`; ensure command watchers notified.
- Auth token mismatch results in `EPERM`; log attempt for diagnostics.
- Future array/matrix support implemented via auxiliary descriptor pools without changing base entry size.

## Testing Considerations
- Unit tests covering `val.register`, `val.get`, `val.set`, `val.persist`, `cmd.register`, `cmd.call` with combinations of flags/auth levels.
- Persistence tests simulating FRAM write/load cycles and error paths.
- Transport validation: CAN round-trip (GET/SET/PUB/CALL/RET) and UART shell flows (`val ls`, `val watch`, `cmd call`).
- Integration with debugger watch lists and value subscriptions to ensure metadata consumed correctly.
