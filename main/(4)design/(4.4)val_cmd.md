# Design Spec â€” Value & Command Layer

## Preconditions
- Executive provides mailbox/event infrastructure ((4.3)), persistence services, and session APIs for value/watch interaction (DR-6.1, DR-7.1, DR-5.3, DG-6.1, DG-7.3).
- MiniVM SVC dispatcher routes module 0x07/0x08 traps to executive handlers (DR-7.1, DG-7.2).
- Toolchain/samples define value/command descriptors aligning with runtime expectations (DR-3.1, DG-7.1).

## Postconditions
- Value/command registry supports registration, lookup, set/get, command invocation, subscriptions, and persistence as documented (DR-7.1, DR-7.3, DG-7.1–7.3).
- CLI/TUI tooling can enumerate and manipulate values/commands, receiving change notifications through the event stream (DR-8.1, DG-8.1, DG-8.2).
- Persistence and transport bindings (UART, CAN, mailbox) interoperate with the executive APIs (DR-5.3, DG-7.3).

## Scope
- Runtime tables for values and commands (group:value IDs) (DR-7.1, DG-7.1).
- SVC implementations (register, lookup, get/set, persist, cmd call) (DR-7.1, DG-7.2).
- Transport bindings (mailbox notifications, CAN/UART framing) (DR-7.1, DG-7.3).
- Persistence integration (FRAM) (DR-5.3, DG-7.3).

## Data Structures
- **Value entry (`hsx_val_entry`):** 8-byte record containing group id, value id, flags (RO, Persist, Sticky, Pin, Bool), last published f16 value, auth level, reserved byte.
- **Value descriptor (`hsx_val_desc`):** optional pointer structure with group/value names, unit (packed 4-char), epsilon, rate_ms, range bounds, persist key (FRAM address). Defaults omitted to save RAM.
- **Command entry (`hsx_cmd_entry`):** group id, value id, flags (Pin), auth level.
- **Command descriptor (`hsx_cmd_desc`):** optional names and help string references for shell/debugger display.
- **String tables:** deduplicated null-terminated strings stored once for all values/commands; referenced by descriptors.

## Algorithms / Behaviour
- **Registration:** allocate slot from fixed-size tables; create OID = group<<8 | value; store compact entry; optionally copy descriptor strings into shared table; assign persist key if provided (auto allocate if zero?).
- **Lookup:** O(1) array index by OID; fallback to hash map if sparse deployment.
- **GET/SET:** enforce auth level and flags; on set, compare new f16 against `last_f16` using epsilon; if changed and outside rate limit, update `last_f16`, persist if configured, enqueue mailbox/CAN updates.
- **Subscription:** `val.sub` stores mailbox handle; executive delivers `(oid,f16)` frames on change respecting rate limit.
- **Persistence:** `val.persist` toggles mode; on load, fetch from FRAM; on update, schedule write (debounced) to avoid wear.
- **Command call:** verify auth token if command flagged `Pin`; synchronous call returns errno; async call posts `(oid,rc)` to mailbox; commands do not carry arguments in v1 (button semantics).
- **CAN binding:** map `oid` to payload (2 bytes) with op-coded frames (GET, SET, PUB, CALL, RET); optional sequence/errno bytes; no argument payload beyond metadata.
- **Shell/CLI:** support numeric addressing `group:value` and named lookups via descriptor tables; parse floats into f16.

## Edge Cases
- Table capacity exhaustion returns error to registering task; document recommended limits per platform.
- Task restart should clear entries but allow same group:value IDs to reuse existing string/persist metadata if desired.
- FRAM read failure -> fall back to default or last known value flagged as `STALE`; ensure command watchers notified.
- Auth token mismatch results in `EPERM`; log attempt for diagnostics.
- Future array/matrix support implemented via auxiliary descriptor pools without changing base entry size.

## Testing Considerations
- Unit tests covering `val.register`, `val.get`, `val.set`, `val.persist`, `cmd.register`, `cmd.call` with combinations of flags/auth levels.
- Persistence tests simulating FRAM write/load cycles and error paths.
- Transport validation: CAN round-trip (GET/SET/PUB/CALL/RET) and UART shell flows (`val ls`, `val watch`, `cmd call`).
- Integration with debugger watch lists and value subscriptions to ensure metadata consumed correctly.

## Traceability
- **Design Requirements:** DR-3.1, DR-5.3, DR-6.1, DR-7.1, DR-7.3, DR-8.1.
- **Design Goals:** DG-6.1, DG-6.2, DG-7.1–7.4, DG-8.1–8.2.
- **Design Options:** DO-7.a.


