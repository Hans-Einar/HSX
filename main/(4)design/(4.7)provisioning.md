# Design Spec â€” Provisioning & Persistence

## Preconditions
- Executive services for mailbox/value/persistence available; CAN/SD transport drivers operational (DR-1.1, DR-5.3, DR-6.1, DR-7.1, DG-5.3).
- Toolchain supplies .hxe images, manifests, and integrity metadata (DR-3.1, DR-5.3, DG-3.1, DG-3.5).
- Hardware platform provisions FRAM/flash space per docs/resource_budgets.md (DR-5.2, DR-5.3).

## Postconditions
- Provisioning workflows (CAN broadcast, SD manifest, host load) reliably install/update HSX apps with integrity checks (DR-1.1, DR-3.1, DR-5.1, DR-5.3).
- Persistence layer (FRAM) stores calibration/state tied to value subsystem policies (DR-5.3, DG-7.3).
- Telemetry/CLI commands report provisioning status and recovery options (DG-5.2, DG-8.1).

## Scope
- Node startup sequence, image loading, task lifecycle (DR-1.1, DG-1.2).
- CAN and SD provisioning protocols (DR-1.1, DG-5.3).
- FRAM persistence flow for calibration/state (DR-5.3, DG-7.3).

## Data Structures
- **Provisioning manifest:** per-image metadata (target PID, required capabilities, FRAM keys, expected version) distributed alongside `.hxe`.
- **Transfer session state:** for CAN/SD, track sequence numbers, payload chunks, CRC progress, timeout timers.
- **FRAM table:** mapping of OID â†’ FRAM address, mode (volatile/load/save), checksum.
- **Boot configuration:** per-node startup script indicating which `.hxe` files to load, priority ordering, fallbacks.

## Algorithms / Behaviour
- **Boot sequence:**
  1. Bootloader loads host firmware; executive initialises HAL.
  2. Executive scans provisioning sources in priority order (host preload â†’ SD manifest â†’ CAN master).
  3. For each `.hxe` entry, verify header/CRC, allocate PID, create task via MiniVM, restore persisted values, start execution.
- **Runtime update:** when new image arrives (CAN/host CLI), load into staging, validate, stop existing PID, replace while preserving `val.persist` data, emit progress events via mailbox.
- **CAN protocol:** use `GET`, `SET`, `LOAD` opcodes (11-bit CAN ID structure), support chunked transfers with acknowledgements and retry/back-off.
- **SD manifest:** simple TOML/JSON listing image paths, version, FRAM manifest references; parsed at boot.
- **FRAM persistence:** integrate with value subsystem; writes debounced to minimise wear. On failure (CRC, write error) roll back and notify host.

## Edge Cases
- Partial downloads or CRC failure recovery.
- Version mismatches between app and host firmware.
- Power loss during persistence update.
- Duplicate PID request â†’ executive reuses or reallocates depending on manifest policy.
- Missing FRAM key referenced by manifest -> load fails with diagnostics; fallback to defaults.
- Security/policy (future): authenticate CAN payloads, restrict commands; documented in `docs/security.md` once defined.

## Testing Considerations
- Simulated CAN/SD provisioning scenarios.
- Persistence regression tests (power cycle simulations).
- Integration tests covering calibration updates and rollback.
- Fuzz hostile CAN traffic (out-of-order chunks, malformed headers) to ensure robust recovery.
- Validate persistence handshake: load values, update via `val.set`, power cycle simulation verifying restoration.

## Traceability
- **Design Requirements:** DR-1.1, DR-1.2, DR-3.1, DR-5.1, DR-5.2, DR-5.3, DR-6.1, DR-7.1.
- **Design Goals:** DG-1.2, DG-3.1, DG-3.5, DG-5.1–5.3, DG-7.3.
- **Design Options:** DO-relay (future relay considerations for provisioning status).

