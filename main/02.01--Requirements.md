# Study Traceability Catalogue

**Design Requirement (DR):** Non-negotiable behaviour or constraint derived from the mandate/study. DRs must be satisfied in the current release and map to one or more Design Goals (DG).

**Design Goal (DG):** Architectural objective captured in the study. DGs explain how we meet DRs and guide architecture/design decisions.

**Design Option (DO):** Optional enhancement or exploratory idea noted for backlog purposes. DOs are not required for the present scope but should remain traceable.

## Mapping Overview

| Label | Study section | Intent |
|-------|---------------|--------|
| DG-1.x | Introduction / Project Context | Runtime updatability on MCUs, unified host firmware, Python-to-C migration path. |
| DG-2.x | Problem Frame & Inspirations | ISA/ABI foundations (register model, workspace pointer, FP16). |
| DG-3.x | Toolchain & Artefact Studies | `.hxo/.hxe` formats, lowering pipeline, debug metadata. |
| DG-4.x | MiniVM Study | Interpreter structure, breakpoint handling, sleep semantics. |
| DG-5.x | Executive & Scheduler Study | Scheduler contract, session/event streaming, resource management. |
| DG-6.x | Mailbox Study | Delivery modes, back-pressure policies, namespace rules. |
| DG-7.x | Value & Command Study | Registry semantics, persistence, transport bindings, security. |
| DG-8.x | Toolkit Study | CLI/TUI debugger goals, event handling, packaging considerations. |
| DO-* | Optional explorations / alternatives | Future enhancements (hotset regs, alternative toolchains, relays, etc.). |

## DR Catalogue
- **DR-1.1 Runtime updatability:** Load/execute HSX apps at runtime on MCUs without reflashing host firmware (DG-1.1, DG-1.2).
- **DR-1.2 Unified host firmware:** Maintain a single host firmware image; provisioning must deliver app logic consistently (DG-1.2).
- **DR-1.3 Python-to-C migration:** Python reference implementations must not block a future C port (DG-1.3).
- **DR-2.1 Deterministic context switching:** MiniVM/executive must support constant-time workspace-pointer swaps (DG-2.1, DG-2.2).
- **DR-2.1a Context-switch acceptance:** Provide measurable acceptance (microbench/metrics) to validate DR-2.1 in CI (DG-2.1, DG-2.2).
- **DR-2.2 ARM-aligned ABI:** Calling convention aligns with ARM-style register usage to interoperate with toolchain expectations (DG-2.3).
- **DR-2.3 FP16 numeric channel:** Toolchain/runtime/tooling handle f16 payloads for telemetry/value interfaces (DG-2.4).
- **DR-2.5 ABI versioning handshake:** Single authoritative header + `EXEC_GET_VERSION` capability query shared by Python/C implementations (DG-3.4, DG-5.3).
- **DR-3.1 HXE format contract:** Freeze `.hxe` header fields (magic, version, entry, code/ro/bss sizes, CRC) and document compatibility rules; listing/debug sidecar is an artefact (DG-3.1, DG-3.5).
- **DR-5.1 Scheduler contract & time base:** Define single-instruction quantum, fairness, blocking semantics, and time units when executive attached (DG-5.1, DG-5.4).
- **DR-5.2 Resource budgets:** Establish RAM/flash budgets per target (Executive, MiniVM, mailbox pools, per-PID stacks) (DG-5.2).
- **DR-5.3 Persistence layout:** Define FRAM/E2 keyspace, CRC/rollback, lifecycle for calibration/state (DG-7.3, DG-5.3).
- **DR-6.1 Mailbox semantics:** Normative definitions for delivery modes (first-reader/all-readers/tap), back-pressure, overflow policy (DG-6.1, DG-6.2, DG-6.3, DG-6.4).
- **DR-7.1 Value/command security & policy:** Minimum auth levels/tokens for value set/command call across transports (DG-7.1, DG-7.2).
- **DR-8.1 Debug session & event stream:** Session locking, event categories, rate control, and reconnect semantics for debugger tooling (DG-5.2, DG-8.2).

## DG-1 — Runtime Goals
- **DG-1.1 Runtime updatability on MCUs** – Executive manages provisioning (CAN/SD) while MiniVM stays lightweight.
- **DG-1.2 Unified host firmware** – Standardised `.hxe` packaging and HAL abstractions enable single firmware deployments.
- **DG-1.3 Python-first path to C port** – Design highlights deterministic structures to ease port.
- **DG-1.4 Python?C parity tests** – Shared test matrix must pass on Python and C implementations before release.

## DG-2 — ISA & ABI Foundations
- **DG-2.1 16-register workspace** – ARM-like register set, 64-byte window.
- **DG-2.2 Workspace pointer addressing** – Registers addressed via `reg_base + offset`; pointer retargeting for context switches.
- **DG-2.3 ABI & calling convention** – ARM-inspired argument/return rules, preserved registers.
- **DG-2.4 FP16 numeric model** – Standard f16 payload usage, refer to `docs/HSX_F16_GUIDE.md`.
- **DO-2.a Extended ISA opcodes** – Future vector/advanced FP instructions.

## DG-3 — Toolchain & Artefact Studies
- **DG-3.1 Assembler & object model** – `.hxo/.hxe` layout, relocations, assembler directives.
- **DG-3.2 LLVM lowering & register allocation** – SSA lowering, spill strategy, register pressure.
- **DG-3.3 Debug metadata export** – Symbol/line table sidecars for tooling.
- **DG-3.4 SVC header source of truth** – Single authoritative header for module/function IDs; Python tooling scrapes same file.
- **DG-3.5 Listing + debug sidecar** – Linker must emit deterministic listing/sidecar for debugger/CI.
- **DO-3.a Alternative IR tooling** – Explore additional backends (Rust, etc.).

## DG-4 — MiniVM Study
- **DG-4.1 Workspace pointer model** – Implementation mechanics of register windows.
- **DG-4.2 Debug/breakpoint semantics** – BRK handling, instruction trace integration.
- **DG-4.3 Sleep & wait mechanisms** – Behaviour attached vs standalone.
- **DO-4.a Multi-task VM options** – Deferred multi-tasking research.

## DG-5 — Executive & Scheduler
- **DG-5.1 Scheduler goals** – Single-instruction quantum, fairness, PID locks.
- **DG-5.2 Event streaming requirements** – Event categories, rate limits, streaming vs polling.
- **DG-5.3 PID/session management** – Capability negotiation, keepalive, exclusive locks.
- **DG-5.4 Single-instruction contract** – VM yields control each instruction when attached; standalone behaviour documented separately.
- **DO-5.a Priority scheduling variants** – Future advanced scheduling.

## DG-6 — Mailbox Subsystem
- **DG-6.1 Delivery semantics** – Single-reader, fan-out, taps.
- **DG-6.2 Back-pressure & overrun handling** – Blocking vs drop policies, status codes.
- **DG-6.3 Descriptor lifecycle** – Binding, handles, namespaces.
- **DG-6.4 Reserved stdio mailboxes** – `svc:stdio.*` handles and policy.
- **DO-6.a Extended mailbox namespaces** – Additional namespace/QoS options.

## DG-7 — Value & Command Layer
- **DG-7.1 Value registry requirements** – OID scheme, metadata footprint.
- **DG-7.2 Command invocation semantics** – Flags, tokens, sync/async behaviour.
- **DG-7.3 Transport & persistence bindings** – Mailbox, UART, CAN, FRAM integration.
- **DG-7.4 Numeric addressing as canonical** – Numeric addressing required; names optional.
- **DO-7.a Bulk operations / batching** – Future bulk get/set RPCs.

## DG-8 — Toolkit & Debugger
- **DG-8.1 CLI/TUI objectives** – Panels, watch/break workflows, scripting hooks.
- **DG-8.2 Event handling & back-pressure** – Toolkit mirrors event protocol (ack, filtering).
- **DG-8.3 Packaging & cross-platform support** – Dependencies, release targets.
- **DO-8.a On-target relay/TUI footprint** – Hardware relay exploration.

## DO Catalogue
- **DO-VM-hotset** – Mirror hot registers with dirty mask (register-model analysis).
- **DO-VM-adaptive** – Adaptive promotion of registers to shadow storage.
- **DO-mailbox-ns** – Extended mailbox namespaces / QoS variants.
- **DO-val-bulk** – `val.bulk_get/set` RPCs.
- **DO-tool-altIR** – Alternative IR / Rust backend.
- **DO-hxe-sym** – Embedded symbol table within `.hxe`.
- **DO-relay** – On-target debug relay / lightweight TUI.

## Next Steps
1. Tag `main/(2)study.md` headings with DG/DO identifiers per section.
2. Reference DR/DG IDs within architecture `(3.x)` and design `(4.x)` documents (especially Preconditions/Postconditions).
3. Update SVC header/code generation to satisfy DR-2.5 (shared definitions).
4. Populate resource budget tables and event protocol specs with the normative DR expectations.
5. Track completion via `main/studyReferenceRework.md` and `main/refactorNotes.md` during implementation.

